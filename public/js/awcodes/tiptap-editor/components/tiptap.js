const uO = Object.create
const yy = Object.defineProperty
const dO = Object.getOwnPropertyDescriptor
const fO = Object.getOwnPropertyNames
const pO = Object.getPrototypeOf
const hO = Object.prototype.hasOwnProperty
const Qd = (t, e) => () => (
  e || t((e = { exports: {} }).exports, e), e.exports
)
const mO = (t, e, n, r) => {
  if ((e && typeof e === 'object') || typeof e === 'function') {
    for (const i of fO(e)) {
      !hO.call(t, i) &&
                i !== n &&
                yy(t, i, {
                  get: () => e[i],
                  enumerable: !(r = dO(e, i)) || r.enumerable
                })
    }
  }
  return t
}
const ef = (t, e, n) => (
  (n = t != null ? uO(pO(t)) : {}),
  mO(
    e || !t || !t.__esModule
      ? yy(n, 'default', { value: t, enumerable: !0 })
      : n,
    t
  )
)
const vS = Qd((mq, ES) => {
  function aS (t) {
    return (
      t instanceof Map
        ? (t.clear =
                      t.delete =
                      t.set =
                          function () {
                            throw new Error('map is read-only')
                          })
        : t instanceof Set &&
                  (t.add =
                      t.clear =
                      t.delete =
                          function () {
                            throw new Error('set is read-only')
                          }),
      Object.freeze(t),
      Object.getOwnPropertyNames(t).forEach((e) => {
        const n = t[e]
        const r = typeof n;
        (r === 'object' || r === 'function') &&
                    !Object.isFrozen(n) &&
                    aS(n)
      }),
      t
    )
  }
  const Nu = class {
    constructor (e) {
      e.data === void 0 && (e.data = {}),
      (this.data = e.data),
      (this.isMatchIgnored = !1)
    }

    ignoreMatch () {
      this.isMatchIgnored = !0
    }
  }
  function lS (t) {
    return t
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
  }
  function Ai (t, ...e) {
    const n = Object.create(null)
    for (const r in t) n[r] = t[r]
    return (
      e.forEach(function (r) {
        for (const i in r) n[i] = r[i]
      }),
      n
    )
  }
  const eH = '</span>'
  const tS = (t) => !!t.scope
  const tH = (t, { prefix: e }) => {
    if (t.startsWith('language:')) {
      return t.replace('language:', 'language-')
    }
    if (t.includes('.')) {
      const n = t.split('.')
      return [
                `${e}${n.shift()}`,
                ...n.map((r, i) => `${r}${'_'.repeat(i + 1)}`)
      ].join(' ')
    }
    return `${e}${t}`
  }
  const Im = class {
    constructor (e, n) {
      (this.buffer = ''),
      (this.classPrefix = n.classPrefix),
      e.walk(this)
    }

    addText (e) {
      this.buffer += lS(e)
    }

    openNode (e) {
      if (!tS(e)) return
      const n = tH(e.scope, { prefix: this.classPrefix })
      this.span(n)
    }

    closeNode (e) {
      tS(e) && (this.buffer += eH)
    }

    value () {
      return this.buffer
    }

    span (e) {
      this.buffer += `<span class="${e}">`
    }
  }
  const nS = (t = {}) => {
    const e = { children: [] }
    return Object.assign(e, t), e
  }
  const Dm = class t {
    constructor () {
      (this.rootNode = nS()), (this.stack = [this.rootNode])
    }

    get top () {
      return this.stack[this.stack.length - 1]
    }

    get root () {
      return this.rootNode
    }

    add (e) {
      this.top.children.push(e)
    }

    openNode (e) {
      const n = nS({ scope: e })
      this.add(n), this.stack.push(n)
    }

    closeNode () {
      if (this.stack.length > 1) return this.stack.pop()
    }

    closeAllNodes () {
      for (; this.closeNode(););
    }

    toJSON () {
      return JSON.stringify(this.rootNode, null, 4)
    }

    walk (e) {
      return this.constructor._walk(e, this.rootNode)
    }

    static _walk (e, n) {
      return (
        typeof n === 'string'
          ? e.addText(n)
          : n.children &&
                      (e.openNode(n),
                      n.children.forEach((r) => this._walk(e, r)),
                      e.closeNode(n)),
        e
      )
    }

    static _collapse (e) {
      typeof e !== 'string' &&
                e.children &&
                (e.children.every((n) => typeof n === 'string')
                  ? (e.children = [e.children.join('')])
                  : e.children.forEach((n) => {
                    t._collapse(n)
                  }))
    }
  }
  const Lm = class extends Dm {
    constructor (e) {
      super(), (this.options = e)
    }

    addText (e) {
      e !== '' && this.add(e)
    }

    startScope (e) {
      this.openNode(e)
    }

    endScope () {
      this.closeNode()
    }

    __addSublanguage (e, n) {
      const r = e.root
      n && (r.scope = `language:${n}`), this.add(r)
    }

    toHTML () {
      return new Im(this, this.options).value()
    }

    finalize () {
      return this.closeAllNodes(), !0
    }
  }
  function Ma (t) {
    return t ? (typeof t === 'string' ? t : t.source) : null
  }
  function cS (t) {
    return vo('(?=', t, ')')
  }
  function nH (t) {
    return vo('(?:', t, ')*')
  }
  function rH (t) {
    return vo('(?:', t, ')?')
  }
  function vo (...t) {
    return t.map((n) => Ma(n)).join('')
  }
  function iH (t) {
    const e = t[t.length - 1]
    return typeof e === 'object' && e.constructor === Object
      ? (t.splice(t.length - 1, 1), e)
      : {}
  }
  function Bm (...t) {
    return (
      '(' +
            (iH(t).capture ? '' : '?:') +
            t.map((r) => Ma(r)).join('|') +
            ')'
    )
  }
  function uS (t) {
    return new RegExp(t.toString() + '|').exec('').length - 1
  }
  function oH (t, e) {
    const n = t && t.exec(e)
    return n && n.index === 0
  }
  const sH = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
  function Fm (t, { joinWith: e }) {
    let n = 0
    return t
      .map((r) => {
        n += 1
        const i = n
        let o = Ma(r)
        let s = ''
        for (; o.length > 0;) {
          const l = sH.exec(o)
          if (!l) {
            s += o
            break
          }
          (s += o.substring(0, l.index)),
          (o = o.substring(l.index + l[0].length)),
          l[0][0] === '\\' && l[1]
            ? (s += '\\' + String(Number(l[1]) + i))
            : ((s += l[0]), l[0] === '(' && n++)
        }
        return s
      })
      .map((r) => `(${r})`)
      .join(e)
  }
  const aH = /\b\B/
  const dS = '[a-zA-Z]\\w*'
  const Hm = '[a-zA-Z_]\\w*'
  const fS = '\\b\\d+(\\.\\d+)?'
  const pS =
        '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'
  const hS = '\\b(0b[01]+)'
  const lH =
        '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~'
  const cH = (t = {}) => {
    const e = /^#![ ]*\//
    return (
      t.binary && (t.begin = vo(e, /.*\b/, t.binary, /\b.*/)),
      Ai(
        {
          scope: 'meta',
          begin: e,
          end: /$/,
          relevance: 0,
          'on:begin': (n, r) => {
            n.index !== 0 && r.ignoreMatch()
          }
        },
        t
      )
    )
  }
  const Na = { begin: '\\\\[\\s\\S]', relevance: 0 }
  const uH = {
    scope: 'string',
    begin: "'",
    end: "'",
    illegal: '\\n',
    contains: [Na]
  }
  const dH = {
    scope: 'string',
    begin: '"',
    end: '"',
    illegal: '\\n',
    contains: [Na]
  }
  const fH = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  }
  const Ou = function (t, e, n = {}) {
    const r = Ai({ scope: 'comment', begin: t, end: e, contains: [] }, n)
    r.contains.push({
      scope: 'doctag',
      begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0
    })
    const i = Bm(
      'I',
      'a',
      'is',
      'so',
      'us',
      'to',
      'at',
      'if',
      'in',
      'it',
      'on',
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      /[A-Za-z]+[-][a-z]+/,
      /[A-Za-z][a-z]{2,}/
    )
    return (
      r.contains.push({
        begin: vo(/[ ]+/, '(', i, /[.]?[:]?([.][ ]|[ ])/, '){3}')
      }),
      r
    )
  }
  const pH = Ou('//', '$')
  const hH = Ou('/\\*', '\\*/')
  const mH = Ou('#', '$')
  const gH = { scope: 'number', begin: fS, relevance: 0 }
  const bH = { scope: 'number', begin: pS, relevance: 0 }
  const yH = { scope: 'number', begin: hS, relevance: 0 }
  const EH = {
    begin: /(?=\/[^/\n]*\/)/,
    contains: [
      {
        scope: 'regexp',
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [
          Na,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [Na]
          }
        ]
      }
    ]
  }
  const vH = { scope: 'title', begin: dS, relevance: 0 }
  const wH = { scope: 'title', begin: Hm, relevance: 0 }
  const xH = { begin: '\\.\\s*' + Hm, relevance: 0 }
  const _H = function (t) {
    return Object.assign(t, {
      'on:begin': (e, n) => {
        n.data._beginMatch = e[1]
      },
      'on:end': (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch()
      }
    })
  }
  const Mu = Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE: aH,
    IDENT_RE: dS,
    UNDERSCORE_IDENT_RE: Hm,
    NUMBER_RE: fS,
    C_NUMBER_RE: pS,
    BINARY_NUMBER_RE: hS,
    RE_STARTERS_RE: lH,
    SHEBANG: cH,
    BACKSLASH_ESCAPE: Na,
    APOS_STRING_MODE: uH,
    QUOTE_STRING_MODE: dH,
    PHRASAL_WORDS_MODE: fH,
    COMMENT: Ou,
    C_LINE_COMMENT_MODE: pH,
    C_BLOCK_COMMENT_MODE: hH,
    HASH_COMMENT_MODE: mH,
    NUMBER_MODE: gH,
    C_NUMBER_MODE: bH,
    BINARY_NUMBER_MODE: yH,
    REGEXP_MODE: EH,
    TITLE_MODE: vH,
    UNDERSCORE_TITLE_MODE: wH,
    METHOD_GUARD: xH,
    END_SAME_AS_BEGIN: _H
  })
  function SH (t, e) {
    t.input[t.index - 1] === '.' && e.ignoreMatch()
  }
  function TH (t, e) {
    t.className !== void 0 && ((t.scope = t.className), delete t.className)
  }
  function CH (t, e) {
    e &&
            t.beginKeywords &&
            ((t.begin =
                '\\b(' +
                t.beginKeywords.split(' ').join('|') +
                ')(?!\\.)(?=\\b|\\s)'),
            (t.__beforeBegin = SH),
            (t.keywords = t.keywords || t.beginKeywords),
            delete t.beginKeywords,
            t.relevance === void 0 && (t.relevance = 0))
  }
  function AH (t, e) {
    Array.isArray(t.illegal) && (t.illegal = Bm(...t.illegal))
  }
  function MH (t, e) {
    if (t.match) {
      if (t.begin || t.end) {
        throw new Error('begin & end are not supported with match')
      }
      (t.begin = t.match), delete t.match
    }
  }
  function NH (t, e) {
    t.relevance === void 0 && (t.relevance = 1)
  }
  const kH = (t, e) => {
    if (!t.beforeMatch) return
    if (t.starts) {
      throw new Error('beforeMatch cannot be used with starts')
    }
    const n = Object.assign({}, t)
    Object.keys(t).forEach((r) => {
      delete t[r]
    }),
    (t.keywords = n.keywords),
    (t.begin = vo(n.beforeMatch, cS(n.begin))),
    (t.starts = {
      relevance: 0,
      contains: [Object.assign(n, { endsParent: !0 })]
    }),
    (t.relevance = 0),
    delete n.beforeMatch
  }
  const OH = [
    'of',
    'and',
    'for',
    'in',
    'not',
    'or',
    'if',
    'then',
    'parent',
    'list',
    'value'
  ]
  const RH = 'keyword'
  function mS (t, e, n = RH) {
    const r = Object.create(null)
    return (
      typeof t === 'string'
        ? i(n, t.split(' '))
        : Array.isArray(t)
          ? i(n, t)
          : Object.keys(t).forEach(function (o) {
            Object.assign(r, mS(t[o], e, o))
          }),
      r
    )
    function i (o, s) {
      e && (s = s.map((l) => l.toLowerCase())),
      s.forEach(function (l) {
        const u = l.split('|')
        r[u[0]] = [o, IH(u[0], u[1])]
      })
    }
  }
  function IH (t, e) {
    return e ? Number(e) : DH(t) ? 0 : 1
  }
  function DH (t) {
    return OH.includes(t.toLowerCase())
  }
  const rS = {}
  const Eo = (t) => {
    console.error(t)
  }
  const iS = (t, ...e) => {
    console.log(`WARN: ${t}`, ...e)
  }
  const fs = (t, e) => {
    rS[`${t}/${e}`] ||
            (console.log(`Deprecated as of ${t}. ${e}`),
            (rS[`${t}/${e}`] = !0))
  }
  const ku = new Error()
  function gS (t, e, { key: n }) {
    let r = 0
    const i = t[n]
    const o = {}
    const s = {}
    for (let l = 1; l <= e.length; l++) {
      (s[l + r] = i[l]), (o[l + r] = !0), (r += uS(e[l - 1]))
    }
    (t[n] = s), (t[n]._emit = o), (t[n]._multi = !0)
  }
  function LH (t) {
    if (Array.isArray(t.begin)) {
      if (t.skip || t.excludeBegin || t.returnBegin) {
        throw (
          (Eo(
            'skip, excludeBegin, returnBegin not compatible with beginScope: {}'
          ),
          ku)
        )
      }
      if (typeof t.beginScope !== 'object' || t.beginScope === null) {
        throw (Eo('beginScope must be object'), ku)
      }
      gS(t, t.begin, { key: 'beginScope' }),
      (t.begin = Fm(t.begin, { joinWith: '' }))
    }
  }
  function PH (t) {
    if (Array.isArray(t.end)) {
      if (t.skip || t.excludeEnd || t.returnEnd) {
        throw (
          (Eo(
            'skip, excludeEnd, returnEnd not compatible with endScope: {}'
          ),
          ku)
        )
      }
      if (typeof t.endScope !== 'object' || t.endScope === null) {
        throw (Eo('endScope must be object'), ku)
      }
      gS(t, t.end, { key: 'endScope' }),
      (t.end = Fm(t.end, { joinWith: '' }))
    }
  }
  function BH (t) {
    t.scope &&
            typeof t.scope === 'object' &&
            t.scope !== null &&
            ((t.beginScope = t.scope), delete t.scope)
  }
  function FH (t) {
    BH(t),
    typeof t.beginScope === 'string' &&
                (t.beginScope = { _wrap: t.beginScope }),
    typeof t.endScope === 'string' &&
                (t.endScope = { _wrap: t.endScope }),
    LH(t),
    PH(t)
  }
  function HH (t) {
    function e (s, l) {
      return new RegExp(
        Ma(s),
        'm' +
                    (t.case_insensitive ? 'i' : '') +
                    (t.unicodeRegex ? 'u' : '') +
                    (l ? 'g' : '')
      )
    }
    class n {
      constructor () {
        (this.matchIndexes = {}),
        (this.regexes = []),
        (this.matchAt = 1),
        (this.position = 0)
      }

      addRule (l, u) {
        (u.position = this.position++),
        (this.matchIndexes[this.matchAt] = u),
        this.regexes.push([u, l]),
        (this.matchAt += uS(l) + 1)
      }

      compile () {
        this.regexes.length === 0 && (this.exec = () => null)
        const l = this.regexes.map((u) => u[1]);
        (this.matcherRe = e(Fm(l, { joinWith: '|' }), !0)),
        (this.lastIndex = 0)
      }

      exec (l) {
        this.matcherRe.lastIndex = this.lastIndex
        const u = this.matcherRe.exec(l)
        if (!u) return null
        const d = u.findIndex((h, m) => m > 0 && h !== void 0)
        const f = this.matchIndexes[d]
        return u.splice(0, d), Object.assign(u, f)
      }
    }
    class r {
      constructor () {
        (this.rules = []),
        (this.multiRegexes = []),
        (this.count = 0),
        (this.lastIndex = 0),
        (this.regexIndex = 0)
      }

      getMatcher (l) {
        if (this.multiRegexes[l]) return this.multiRegexes[l]
        const u = new n()
        return (
          this.rules.slice(l).forEach(([d, f]) => u.addRule(d, f)),
          u.compile(),
          (this.multiRegexes[l] = u),
          u
        )
      }

      resumingScanAtSamePosition () {
        return this.regexIndex !== 0
      }

      considerAll () {
        this.regexIndex = 0
      }

      addRule (l, u) {
        this.rules.push([l, u]), u.type === 'begin' && this.count++
      }

      exec (l) {
        const u = this.getMatcher(this.regexIndex)
        u.lastIndex = this.lastIndex
        let d = u.exec(l)
        if (
          this.resumingScanAtSamePosition() &&
                    !(d && d.index === this.lastIndex)
        ) {
          const f = this.getMatcher(0);
          (f.lastIndex = this.lastIndex + 1), (d = f.exec(l))
        }
        return (
          d &&
                        ((this.regexIndex += d.position + 1),
                        this.regexIndex === this.count && this.considerAll()),
          d
        )
      }
    }
    function i (s) {
      const l = new r()
      return (
        s.contains.forEach((u) =>
          l.addRule(u.begin, { rule: u, type: 'begin' })
        ),
        s.terminatorEnd && l.addRule(s.terminatorEnd, { type: 'end' }),
        s.illegal && l.addRule(s.illegal, { type: 'illegal' }),
        l
      )
    }
    function o (s, l) {
      const u = s
      if (s.isCompiled) return u;
      [TH, MH, FH, kH].forEach((f) => f(s, l)),
      t.compilerExtensions.forEach((f) => f(s, l)),
      (s.__beforeBegin = null),
      [CH, AH, NH].forEach((f) => f(s, l)),
      (s.isCompiled = !0)
      let d = null
      return (
        typeof s.keywords === 'object' &&
                    s.keywords.$pattern &&
                    ((s.keywords = Object.assign({}, s.keywords)),
                    (d = s.keywords.$pattern),
                    delete s.keywords.$pattern),
        (d = d || /\w+/),
        s.keywords && (s.keywords = mS(s.keywords, t.case_insensitive)),
        (u.keywordPatternRe = e(d, !0)),
        l &&
                    (s.begin || (s.begin = /\B|\b/),
                    (u.beginRe = e(u.begin)),
                    !s.end && !s.endsWithParent && (s.end = /\B|\b/),
                    s.end && (u.endRe = e(u.end)),
                    (u.terminatorEnd = Ma(u.end) || ''),
                    s.endsWithParent &&
                        l.terminatorEnd &&
                        (u.terminatorEnd +=
                            (s.end ? '|' : '') + l.terminatorEnd)),
        s.illegal && (u.illegalRe = e(s.illegal)),
        s.contains || (s.contains = []),
        (s.contains = [].concat(
          ...s.contains.map(function (f) {
            return $H(f === 'self' ? s : f)
          })
        )),
        s.contains.forEach(function (f) {
          o(f, u)
        }),
        s.starts && o(s.starts, l),
        (u.matcher = i(u)),
        u
      )
    }
    if (
      (t.compilerExtensions || (t.compilerExtensions = []),
      t.contains && t.contains.includes('self'))
    ) {
      throw new Error(
        'ERR: contains `self` is not supported at the top-level of a language.  See documentation.'
      )
    }
    return (t.classNameAliases = Ai(t.classNameAliases || {})), o(t)
  }
  function bS (t) {
    return t ? t.endsWithParent || bS(t.starts) : !1
  }
  function $H (t) {
    return (
      t.variants &&
                !t.cachedVariants &&
                (t.cachedVariants = t.variants.map(function (e) {
                  return Ai(t, { variants: null }, e)
                })),
      t.cachedVariants
        ? t.cachedVariants
        : bS(t)
          ? Ai(t, { starts: t.starts ? Ai(t.starts) : null })
          : Object.isFrozen(t)
            ? Ai(t)
            : t
    )
  }
  const zH = '11.8.0'
  const Pm = class extends Error {
    constructor (e, n) {
      super(e), (this.name = 'HTMLInjectionError'), (this.html = n)
    }
  }
  const Rm = lS
  const oS = Ai
  const sS = Symbol('nomatch')
  const UH = 7
  const yS = function (t) {
    const e = Object.create(null)
    const n = Object.create(null)
    const r = []
    let i = !0
    const o =
            "Could not find the language '{}', did you forget to load/include a language module?"
    const s = { disableAutodetect: !0, name: 'Plain text', contains: [] }
    let l = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: 'hljs-',
      cssSelector: 'pre code',
      languages: null,
      __emitter: Lm
    }
    function u (A) {
      return l.noHighlightRe.test(A)
    }
    function d (A) {
      let D = A.className + ' '
      D += A.parentNode ? A.parentNode.className : ''
      const z = l.languageDetectRe.exec(D)
      if (z) {
        const j = q(z[1])
        return (
          j ||
                        (iS(o.replace('{}', z[1])),
                        iS(
                          'Falling back to no-highlight mode for this block.',
                          A
                        )),
          j ? z[1] : 'no-highlight'
        )
      }
      return D.split(/\s+/).find((j) => u(j) || q(j))
    }
    function f (A, D, z) {
      let j = ''
      let ie = ''
      typeof D === 'object'
        ? ((j = A), (z = D.ignoreIllegals), (ie = D.language))
        : (fs(
            '10.7.0',
            'highlight(lang, code, ...args) has been deprecated.'
          ),
          fs(
            '10.7.0',
                      `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`
          ),
          (ie = A),
          (j = D)),
      z === void 0 && (z = !0)
      const xe = { code: j, language: ie }
      ge('before:highlight', xe)
      const Ae = xe.result ? xe.result : h(xe.language, xe.code, z)
      return (Ae.code = xe.code), ge('after:highlight', Ae), Ae
    }
    function h (A, D, z, j) {
      const ie = Object.create(null)
      function xe (L, H) {
        return L.keywords[H]
      }
      function Ae () {
        if (!V.keywords) {
          _e.addText(pe)
          return
        }
        let L = 0
        V.keywordPatternRe.lastIndex = 0
        let H = V.keywordPatternRe.exec(pe)
        let X = ''
        for (; H;) {
          X += pe.substring(L, H.index)
          const se = Je.case_insensitive ? H[0].toLowerCase() : H[0]
          const Fe = xe(V, se)
          if (Fe) {
            const [rt, wr] = Fe
            if (
              (_e.addText(X),
              (X = ''),
              (ie[se] = (ie[se] || 0) + 1),
              ie[se] <= UH && (ut += wr),
              rt.startsWith('_'))
            ) {
              X += H[0]
            } else {
              const F = Je.classNameAliases[rt] || rt
              Be(H[0], F)
            }
          } else X += H[0];
          (L = V.keywordPatternRe.lastIndex),
          (H = V.keywordPatternRe.exec(pe))
        }
        (X += pe.substring(L)), _e.addText(X)
      }
      function je () {
        if (pe === '') return
        let L = null
        if (typeof V.subLanguage === 'string') {
          if (!e[V.subLanguage]) {
            _e.addText(pe)
            return
          }
          (L = h(V.subLanguage, pe, !0, yt[V.subLanguage])),
          (yt[V.subLanguage] = L._top)
        } else {
          L = b(pe, V.subLanguage.length ? V.subLanguage : null)
        }
        V.relevance > 0 && (ut += L.relevance),
        _e.__addSublanguage(L._emitter, L.language)
      }
      function Ne () {
        V.subLanguage != null ? je() : Ae(), (pe = '')
      }
      function Be (L, H) {
        L !== '' && (_e.startScope(H), _e.addText(L), _e.endScope())
      }
      function _t (L, H) {
        let X = 1
        const se = H.length - 1
        for (; X <= se;) {
          if (!L._emit[X]) {
            X++
            continue
          }
          const Fe = Je.classNameAliases[L[X]] || L[X]
          const rt = H[X]
          Fe ? Be(rt, Fe) : ((pe = rt), Ae(), (pe = '')), X++
        }
      }
      function kt (L, H) {
        return (
          L.scope &&
                        typeof L.scope === 'string' &&
                        _e.openNode(Je.classNameAliases[L.scope] || L.scope),
          L.beginScope &&
                        (L.beginScope._wrap
                          ? (Be(
                              pe,
                              Je.classNameAliases[L.beginScope._wrap] ||
                                      L.beginScope._wrap
                            ),
                            (pe = ''))
                          : L.beginScope._multi &&
                              (_t(L.beginScope, H), (pe = ''))),
          (V = Object.create(L, { parent: { value: V } })),
          V
        )
      }
      function Re (L, H, X) {
        let se = oH(L.endRe, X)
        if (se) {
          if (L['on:end']) {
            const Fe = new Nu(L)
            L['on:end'](H, Fe), Fe.isMatchIgnored && (se = !1)
          }
          if (se) {
            for (; L.endsParent && L.parent;) L = L.parent
            return L
          }
        }
        if (L.endsWithParent) return Re(L.parent, H, X)
      }
      function St (L) {
        return V.matcher.regexIndex === 0
          ? ((pe += L[0]), 1)
          : ((Ot = !0), 0)
      }
      function Xt (L) {
        const H = L[0]
        const X = L.rule
        const se = new Nu(X)
        const Fe = [X.__beforeBegin, X['on:begin']]
        for (const rt of Fe) {
          if (rt && (rt(L, se), se.isMatchIgnored)) return St(H)
        }
        return (
          X.skip
            ? (pe += H)
            : (X.excludeBegin && (pe += H),
              Ne(),
              !X.returnBegin && !X.excludeBegin && (pe = H)),
          kt(X, L),
          X.returnBegin ? 0 : H.length
        )
      }
      function pt (L) {
        const H = L[0]
        const X = D.substring(L.index)
        const se = Re(V, L, X)
        if (!se) return sS
        const Fe = V
        V.endScope && V.endScope._wrap
          ? (Ne(), Be(H, V.endScope._wrap))
          : V.endScope && V.endScope._multi
            ? (Ne(), _t(V.endScope, L))
            : Fe.skip
              ? (pe += H)
              : (Fe.returnEnd || Fe.excludeEnd || (pe += H),
                Ne(),
                Fe.excludeEnd && (pe = H))
        do {
          V.scope && _e.closeNode(),
          !V.skip && !V.subLanguage && (ut += V.relevance),
          (V = V.parent)
        } while (V !== se.parent)
        return (
          se.starts && kt(se.starts, L), Fe.returnEnd ? 0 : H.length
        )
      }
      function an () {
        const L = []
        for (let H = V; H !== Je; H = H.parent) {
          H.scope && L.unshift(H.scope)
        }
        L.forEach((H) => _e.openNode(H))
      }
      let Zt = {}
      function Tt (L, H) {
        const X = H && H[0]
        if (((pe += L), X == null)) return Ne(), 0
        if (
          Zt.type === 'begin' &&
                    H.type === 'end' &&
                    Zt.index === H.index &&
                    X === ''
        ) {
          if (((pe += D.slice(H.index, H.index + 1)), !i)) {
            const se = new Error(`0 width match regex (${A})`)
            throw (
              ((se.languageName = A), (se.badRule = Zt.rule), se)
            )
          }
          return 1
        }
        if (((Zt = H), H.type === 'begin')) return Xt(H)
        if (H.type === 'illegal' && !z) {
          const se = new Error(
            'Illegal lexeme "' +
                            X +
                            '" for mode "' +
                            (V.scope || '<unnamed>') +
                            '"'
          )
          throw ((se.mode = V), se)
        } else if (H.type === 'end') {
          const se = pt(H)
          if (se !== sS) return se
        }
        if (H.type === 'illegal' && X === '') return 1
        if (Bt > 1e5 && Bt > H.index * 3) {
          throw new Error(
            'potential infinite loop, way more iterations than matches'
          )
        }
        return (pe += X), X.length
      }
      const Je = q(A)
      if (!Je) {
        throw (
          (Eo(o.replace('{}', A)),
          new Error('Unknown language: "' + A + '"'))
        )
      }
      const jn = HH(Je)
      let Pt = ''
      let V = j || jn
      const yt = {}
      const _e = new l.__emitter(l)
      an()
      let pe = ''
      let ut = 0
      let dt = 0
      let Bt = 0
      let Ot = !1
      try {
        if (Je.__emitTokens) Je.__emitTokens(D, _e)
        else {
          for (V.matcher.considerAll(); ;) {
            Bt++,
            Ot ? (Ot = !1) : V.matcher.considerAll(),
            (V.matcher.lastIndex = dt)
            const L = V.matcher.exec(D)
            if (!L) break
            const H = D.substring(dt, L.index)
            const X = Tt(H, L)
            dt = L.index + X
          }
          Tt(D.substring(dt))
        }
        return (
          _e.finalize(),
          (Pt = _e.toHTML()),
          {
            language: A,
            value: Pt,
            relevance: ut,
            illegal: !1,
            _emitter: _e,
            _top: V
          }
        )
      } catch (L) {
        if (L.message && L.message.includes('Illegal')) {
          return {
            language: A,
            value: Rm(D),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: L.message,
              index: dt,
              context: D.slice(dt - 100, dt + 100),
              mode: L.mode,
              resultSoFar: Pt
            },
            _emitter: _e
          }
        }
        if (i) {
          return {
            language: A,
            value: Rm(D),
            illegal: !1,
            relevance: 0,
            errorRaised: L,
            _emitter: _e,
            _top: V
          }
        }
        throw L
      }
    }
    function m (A) {
      const D = {
        value: Rm(A),
        illegal: !1,
        relevance: 0,
        _top: s,
        _emitter: new l.__emitter(l)
      }
      return D._emitter.addText(A), D
    }
    function b (A, D) {
      D = D || l.languages || Object.keys(e)
      const z = m(A)
      const j = D.filter(q)
        .filter(fe)
        .map((Ne) => h(Ne, A, !1))
      j.unshift(z)
      const ie = j.sort((Ne, Be) => {
        if (Ne.relevance !== Be.relevance) {
          return Be.relevance - Ne.relevance
        }
        if (Ne.language && Be.language) {
          if (q(Ne.language).supersetOf === Be.language) {
            return 1
          }
          if (q(Be.language).supersetOf === Ne.language) {
            return -1
          }
        }
        return 0
      })
      const [xe, Ae] = ie
      const je = xe
      return (je.secondBest = Ae), je
    }
    function g (A, D, z) {
      const j = (D && n[D]) || z
      A.classList.add('hljs'), A.classList.add(`language-${j}`)
    }
    function E (A) {
      let D = null
      const z = d(A)
      if (u(z)) return
      if (
        (ge('before:highlightElement', { el: A, language: z }),
        A.children.length > 0 &&
                    (l.ignoreUnescapedHTML ||
                        (console.warn(
                          'One of your code blocks includes unescaped HTML. This is a potentially serious security risk.'
                        ),
                        console.warn(
                          'https://github.com/highlightjs/highlight.js/wiki/security'
                        ),
                        console.warn('The element with unescaped HTML:'),
                        console.warn(A)),
                    l.throwUnescapedHTML))
      ) {
        throw new Pm(
          'One of your code blocks includes unescaped HTML.',
          A.innerHTML
        )
      }
      D = A
      const j = D.textContent
      const ie = z ? f(j, { language: z, ignoreIllegals: !0 }) : b(j);
      (A.innerHTML = ie.value),
      g(A, z, ie.language),
      (A.result = {
        language: ie.language,
        re: ie.relevance,
        relevance: ie.relevance
      }),
      ie.secondBest &&
                    (A.secondBest = {
                      language: ie.secondBest.language,
                      relevance: ie.secondBest.relevance
                    }),
      ge('after:highlightElement', {
        el: A,
        result: ie,
        text: j
      })
    }
    function w (A) {
      l = oS(l, A)
    }
    const S = () => {
      T(),
      fs(
        '10.6.0',
        'initHighlighting() deprecated.  Use highlightAll() now.'
      )
    }
    function O () {
      T(),
      fs(
        '10.6.0',
        'initHighlightingOnLoad() deprecated.  Use highlightAll() now.'
      )
    }
    let k = !1
    function T () {
      if (document.readyState === 'loading') {
        k = !0
        return
      }
      document.querySelectorAll(l.cssSelector).forEach(E)
    }
    function P () {
      k && T()
    }
    typeof window < 'u' &&
            window.addEventListener &&
            window.addEventListener('DOMContentLoaded', P, !1)
    function I (A, D) {
      let z = null
      try {
        z = D(t)
      } catch (j) {
        if (
          (Eo(
            "Language definition for '{}' could not be registered.".replace(
              '{}',
              A
            )
          ),
          i)
        ) {
          Eo(j)
        } else throw j
        z = s
      }
      z.name || (z.name = A),
      (e[A] = z),
      (z.rawDefinition = D.bind(null, t)),
      z.aliases && Q(z.aliases, { languageName: A })
    }
    function Y (A) {
      delete e[A]
      for (const D of Object.keys(n)) n[D] === A && delete n[D]
    }
    function ne () {
      return Object.keys(e)
    }
    function q (A) {
      return (A = (A || '').toLowerCase()), e[A] || e[n[A]]
    }
    function Q (A, { languageName: D }) {
      typeof A === 'string' && (A = [A]),
      A.forEach((z) => {
        n[z.toLowerCase()] = D
      })
    }
    function fe (A) {
      const D = q(A)
      return D && !D.disableAutodetect
    }
    function we (A) {
      A['before:highlightBlock'] &&
                !A['before:highlightElement'] &&
                (A['before:highlightElement'] = (D) => {
                  A['before:highlightBlock'](
                    Object.assign({ block: D.el }, D)
                  )
                }),
      A['after:highlightBlock'] &&
                    !A['after:highlightElement'] &&
                    (A['after:highlightElement'] = (D) => {
                      A['after:highlightBlock'](
                        Object.assign({ block: D.el }, D)
                      )
                    })
    }
    function me (A) {
      we(A), r.push(A)
    }
    function Ce (A) {
      const D = r.indexOf(A)
      D !== -1 && r.splice(D, 1)
    }
    function ge (A, D) {
      const z = A
      r.forEach(function (j) {
        j[z] && j[z](D)
      })
    }
    function ye (A) {
      return (
        fs(
          '10.7.0',
          'highlightBlock will be removed entirely in v12.0'
        ),
        fs('10.7.0', 'Please use highlightElement now.'),
        E(A)
      )
    }
    Object.assign(t, {
      highlight: f,
      highlightAuto: b,
      highlightAll: T,
      highlightElement: E,
      highlightBlock: ye,
      configure: w,
      initHighlighting: S,
      initHighlightingOnLoad: O,
      registerLanguage: I,
      unregisterLanguage: Y,
      listLanguages: ne,
      getLanguage: q,
      registerAliases: Q,
      autoDetection: fe,
      inherit: oS,
      addPlugin: me,
      removePlugin: Ce
    }),
    (t.debugMode = function () {
      i = !1
    }),
    (t.safeMode = function () {
      i = !0
    }),
    (t.versionString = zH),
    (t.regex = {
      concat: vo,
      lookahead: cS,
      either: Bm,
      optional: rH,
      anyNumberOfTimes: nH
    })
    for (const A in Mu) typeof Mu[A] === 'object' && aS(Mu[A])
    return Object.assign(t, Mu), t
  }
  const ps = yS({})
  ps.newInstance = () => yS({})
  ES.exports = ps
  ps.HighlightJS = ps
  ps.default = ps
})
const xS = Qd((bq, $m) => {
  (function () {
    let t
    typeof $m < 'u'
      ? (t = $m.exports = r)
      : (t = (function () {
          return this || (0, eval)('this')
        })()),
    (t.format = r),
    (t.vsprintf = n),
    typeof console < 'u' &&
                typeof console.log === 'function' &&
                (t.printf = e)
    function e () {
      console.log(r.apply(null, arguments))
    }
    function n (i, o) {
      return r.apply(null, [i].concat(o))
    }
    function r (i) {
      for (
        var o = 1,
          s = [].slice.call(arguments),
          l = 0,
          u = i.length,
          d = '',
          f,
          h = !1,
          m,
          b,
          g = !1,
          E,
          w = function () {
            return s[o++]
          },
          S = function () {
            for (var O = ''; /\d/.test(i[l]);) {
              (O += i[l++]), (f = i[l])
            }
            return O.length > 0 ? parseInt(O) : null
          };
        l < u;
        ++l
      ) {
        if (((f = i[l]), h)) {
          switch (
            ((h = !1),
            f == '.'
              ? ((g = !1), (f = i[++l]))
              : f == '0' && i[l + 1] == '.'
                ? ((g = !0), (l += 2), (f = i[l]))
                : (g = !0),
            (E = S()),
            f)
          ) {
            case 'b':
              d += parseInt(w(), 10).toString(2)
              break
            case 'c':
              (m = w()),
              typeof m === 'string' || m instanceof String
                ? (d += m)
                : (d += String.fromCharCode(
                    parseInt(m, 10)
                  ))
              break
            case 'd':
              d += parseInt(w(), 10)
              break
            case 'f':
              (b = String(parseFloat(w()).toFixed(E || 6))),
              (d += g ? b : b.replace(/^0/, ''))
              break
            case 'j':
              d += JSON.stringify(w())
              break
            case 'o':
              d += '0' + parseInt(w(), 10).toString(8)
              break
            case 's':
              d += w()
              break
            case 'x':
              d += '0x' + parseInt(w(), 10).toString(16)
              break
            case 'X':
              d +=
                                '0x' +
                                parseInt(w(), 10).toString(16).toUpperCase()
              break
            default:
              d += f
              break
          }
        } else f === '%' ? (h = !0) : (d += f)
      }
      return d
    }
  })()
})
const FS = Qd((gs, Ia) => {
  (function () {
    let t
    const e = '4.17.21'
    const n = 200
    const r =
            'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.'
    const i = 'Expected a function'
    const o = 'Invalid `variable` option passed into `_.template`'
    const s = '__lodash_hash_undefined__'
    const l = 500
    const u = '__lodash_placeholder__'
    const d = 1
    const f = 2
    const h = 4
    const m = 1
    const b = 2
    const g = 1
    const E = 2
    const w = 4
    const S = 8
    const O = 16
    const k = 32
    const T = 64
    const P = 128
    const I = 256
    const Y = 512
    const ne = 30
    const q = '...'
    const Q = 800
    const fe = 16
    const we = 1
    const me = 2
    const Ce = 3
    const ge = 1 / 0
    const ye = 9007199254740991
    const A = 17976931348623157e292
    const D = NaN
    const z = 4294967295
    const j = z - 1
    const ie = z >>> 1
    const xe = [
      ['ary', P],
      ['bind', g],
      ['bindKey', E],
      ['curry', S],
      ['curryRight', O],
      ['flip', Y],
      ['partial', k],
      ['partialRight', T],
      ['rearg', I]
    ]
    const Ae = '[object Arguments]'
    const je = '[object Array]'
    const Ne = '[object AsyncFunction]'
    const Be = '[object Boolean]'
    const _t = '[object Date]'
    const kt = '[object DOMException]'
    const Re = '[object Error]'
    const St = '[object Function]'
    const Xt = '[object GeneratorFunction]'
    const pt = '[object Map]'
    const an = '[object Number]'
    const Zt = '[object Null]'
    const Tt = '[object Object]'
    const Je = '[object Promise]'
    const jn = '[object Proxy]'
    const Pt = '[object RegExp]'
    const V = '[object Set]'
    const yt = '[object String]'
    const _e = '[object Symbol]'
    const pe = '[object Undefined]'
    const ut = '[object WeakMap]'
    const dt = '[object WeakSet]'
    const Bt = '[object ArrayBuffer]'
    const Ot = '[object DataView]'
    const L = '[object Float32Array]'
    const H = '[object Float64Array]'
    const X = '[object Int8Array]'
    const se = '[object Int16Array]'
    const Fe = '[object Int32Array]'
    const rt = '[object Uint8Array]'
    const wr = '[object Uint8ClampedArray]'
    const F = '[object Uint16Array]'
    const ae = '[object Uint32Array]'
    const Se = /\b__p \+= '';/g
    const qe = /\b(__p \+=) '' \+/g
    const Ke = /(__e\(.*?\)|\b__t\)) \+\n'';/g
    const Ft = /&(?:amp|lt|gt|quot|#39);/g
    const ln = /[&<>"']/g
    const Zr = RegExp(Ft.source)
    const Da = RegExp(ln.source)
    const xr = /<%-([\s\S]+?)%>/g
    const bs = /<%([\s\S]+?)%>/g
    const Ni = /<%=([\s\S]+?)%>/g
    const jr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
    const zu = /^\w*$/
    const ys =
            /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
    const Qr = /[\\^$.*+?()[\]{}|]/g
    const zS = RegExp(Qr.source)
    const Uu = /^\s+/
    const US = /\s/
    const WS = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/
    const KS = /\{\n\/\* \[wrapped with (.+)\] \*/
    const VS = /,? & /
    const GS = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g
    const qS = /[()=,{}\[\]\/\s]/
    const YS = /\\(\\)?/g
    const JS = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g
    const Gm = /\w*$/
    const XS = /^[-+]0x[0-9a-f]+$/i
    const ZS = /^0b[01]+$/i
    const jS = /^\[object .+?Constructor\]$/
    const QS = /^0o[0-7]+$/i
    const eT = /^(?:0|[1-9]\d*)$/
    const tT = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g
    const La = /($^)/
    const nT = /['\n\r\u2028\u2029\\]/g
    const Pa = '\\ud800-\\udfff'
    const rT = '\\u0300-\\u036f'
    const iT = '\\ufe20-\\ufe2f'
    const oT = '\\u20d0-\\u20ff'
    const qm = rT + iT + oT
    const Ym = '\\u2700-\\u27bf'
    const Jm = 'a-z\\xdf-\\xf6\\xf8-\\xff'
    const sT = '\\xac\\xb1\\xd7\\xf7'
    const aT = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf'
    const lT = '\\u2000-\\u206f'
    const cT =
            ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'
    const Xm = 'A-Z\\xc0-\\xd6\\xd8-\\xde'
    const Zm = '\\ufe0e\\ufe0f'
    const jm = sT + aT + lT + cT
    const Wu = "['\u2019]"
    const uT = '[' + Pa + ']'
    const Qm = '[' + jm + ']'
    const Ba = '[' + qm + ']'
    const eg = '\\d+'
    const dT = '[' + Ym + ']'
    const tg = '[' + Jm + ']'
    const ng = '[^' + Pa + jm + eg + Ym + Jm + Xm + ']'
    const Ku = '\\ud83c[\\udffb-\\udfff]'
    const fT = '(?:' + Ba + '|' + Ku + ')'
    const rg = '[^' + Pa + ']'
    const Vu = '(?:\\ud83c[\\udde6-\\uddff]){2}'
    const Gu = '[\\ud800-\\udbff][\\udc00-\\udfff]'
    const xo = '[' + Xm + ']'
    const ig = '\\u200d'
    const og = '(?:' + tg + '|' + ng + ')'
    const pT = '(?:' + xo + '|' + ng + ')'
    const sg = '(?:' + Wu + '(?:d|ll|m|re|s|t|ve))?'
    const ag = '(?:' + Wu + '(?:D|LL|M|RE|S|T|VE))?'
    const lg = fT + '?'
    const cg = '[' + Zm + ']?'
    const hT =
            '(?:' + ig + '(?:' + [rg, Vu, Gu].join('|') + ')' + cg + lg + ')*'
    const mT = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])'
    const gT = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])'
    const ug = cg + lg + hT
    const bT = '(?:' + [dT, Vu, Gu].join('|') + ')' + ug
    const yT = '(?:' + [rg + Ba + '?', Ba, Vu, Gu, uT].join('|') + ')'
    const ET = RegExp(Wu, 'g')
    const vT = RegExp(Ba, 'g')
    const qu = RegExp(Ku + '(?=' + Ku + ')|' + yT + ug, 'g')
    const wT = RegExp(
      [
        xo +
                    '?' +
                    tg +
                    '+' +
                    sg +
                    '(?=' +
                    [Qm, xo, '$'].join('|') +
                    ')',
        pT + '+' + ag + '(?=' + [Qm, xo + og, '$'].join('|') + ')',
        xo + '?' + og + '+' + sg,
        xo + '+' + ag,
        gT,
        mT,
        eg,
        bT
      ].join('|'),
      'g'
    )
    const xT = RegExp('[' + ig + Pa + qm + Zm + ']')
    const _T =
            /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/
    const ST = [
      'Array',
      'Buffer',
      'DataView',
      'Date',
      'Error',
      'Float32Array',
      'Float64Array',
      'Function',
      'Int8Array',
      'Int16Array',
      'Int32Array',
      'Map',
      'Math',
      'Object',
      'Promise',
      'RegExp',
      'Set',
      'String',
      'Symbol',
      'TypeError',
      'Uint8Array',
      'Uint8ClampedArray',
      'Uint16Array',
      'Uint32Array',
      'WeakMap',
      '_',
      'clearTimeout',
      'isFinite',
      'parseInt',
      'setTimeout'
    ]
    let TT = -1
    const it = {};
    (it[L] =
            it[H] =
            it[X] =
            it[se] =
            it[Fe] =
            it[rt] =
            it[wr] =
            it[F] =
            it[ae] =
                !0),
    (it[Ae] =
                it[je] =
                it[Bt] =
                it[Be] =
                it[Ot] =
                it[_t] =
                it[Re] =
                it[St] =
                it[pt] =
                it[an] =
                it[Tt] =
                it[Pt] =
                it[V] =
                it[yt] =
                it[ut] =
                    !1)
    const tt = {};
    (tt[Ae] =
            tt[je] =
            tt[Bt] =
            tt[Ot] =
            tt[Be] =
            tt[_t] =
            tt[L] =
            tt[H] =
            tt[X] =
            tt[se] =
            tt[Fe] =
            tt[pt] =
            tt[an] =
            tt[Tt] =
            tt[Pt] =
            tt[V] =
            tt[yt] =
            tt[_e] =
            tt[rt] =
            tt[wr] =
            tt[F] =
            tt[ae] =
                !0),
    (tt[Re] = tt[St] = tt[ut] = !1)
    const CT = {
      À: 'A',
      Á: 'A',
      Â: 'A',
      Ã: 'A',
      Ä: 'A',
      Å: 'A',
      à: 'a',
      á: 'a',
      â: 'a',
      ã: 'a',
      ä: 'a',
      å: 'a',
      Ç: 'C',
      ç: 'c',
      Ð: 'D',
      ð: 'd',
      È: 'E',
      É: 'E',
      Ê: 'E',
      Ë: 'E',
      è: 'e',
      é: 'e',
      ê: 'e',
      ë: 'e',
      Ì: 'I',
      Í: 'I',
      Î: 'I',
      Ï: 'I',
      ì: 'i',
      í: 'i',
      î: 'i',
      ï: 'i',
      Ñ: 'N',
      ñ: 'n',
      Ò: 'O',
      Ó: 'O',
      Ô: 'O',
      Õ: 'O',
      Ö: 'O',
      Ø: 'O',
      ò: 'o',
      ó: 'o',
      ô: 'o',
      õ: 'o',
      ö: 'o',
      ø: 'o',
      Ù: 'U',
      Ú: 'U',
      Û: 'U',
      Ü: 'U',
      ù: 'u',
      ú: 'u',
      û: 'u',
      ü: 'u',
      Ý: 'Y',
      ý: 'y',
      ÿ: 'y',
      Æ: 'Ae',
      æ: 'ae',
      Þ: 'Th',
      þ: 'th',
      ß: 'ss',
      Ā: 'A',
      Ă: 'A',
      Ą: 'A',
      ā: 'a',
      ă: 'a',
      ą: 'a',
      Ć: 'C',
      Ĉ: 'C',
      Ċ: 'C',
      Č: 'C',
      ć: 'c',
      ĉ: 'c',
      ċ: 'c',
      č: 'c',
      Ď: 'D',
      Đ: 'D',
      ď: 'd',
      đ: 'd',
      Ē: 'E',
      Ĕ: 'E',
      Ė: 'E',
      Ę: 'E',
      Ě: 'E',
      ē: 'e',
      ĕ: 'e',
      ė: 'e',
      ę: 'e',
      ě: 'e',
      Ĝ: 'G',
      Ğ: 'G',
      Ġ: 'G',
      Ģ: 'G',
      ĝ: 'g',
      ğ: 'g',
      ġ: 'g',
      ģ: 'g',
      Ĥ: 'H',
      Ħ: 'H',
      ĥ: 'h',
      ħ: 'h',
      Ĩ: 'I',
      Ī: 'I',
      Ĭ: 'I',
      Į: 'I',
      İ: 'I',
      ĩ: 'i',
      ī: 'i',
      ĭ: 'i',
      į: 'i',
      ı: 'i',
      Ĵ: 'J',
      ĵ: 'j',
      Ķ: 'K',
      ķ: 'k',
      ĸ: 'k',
      Ĺ: 'L',
      Ļ: 'L',
      Ľ: 'L',
      Ŀ: 'L',
      Ł: 'L',
      ĺ: 'l',
      ļ: 'l',
      ľ: 'l',
      ŀ: 'l',
      ł: 'l',
      Ń: 'N',
      Ņ: 'N',
      Ň: 'N',
      Ŋ: 'N',
      ń: 'n',
      ņ: 'n',
      ň: 'n',
      ŋ: 'n',
      Ō: 'O',
      Ŏ: 'O',
      Ő: 'O',
      ō: 'o',
      ŏ: 'o',
      ő: 'o',
      Ŕ: 'R',
      Ŗ: 'R',
      Ř: 'R',
      ŕ: 'r',
      ŗ: 'r',
      ř: 'r',
      Ś: 'S',
      Ŝ: 'S',
      Ş: 'S',
      Š: 'S',
      ś: 's',
      ŝ: 's',
      ş: 's',
      š: 's',
      Ţ: 'T',
      Ť: 'T',
      Ŧ: 'T',
      ţ: 't',
      ť: 't',
      ŧ: 't',
      Ũ: 'U',
      Ū: 'U',
      Ŭ: 'U',
      Ů: 'U',
      Ű: 'U',
      Ų: 'U',
      ũ: 'u',
      ū: 'u',
      ŭ: 'u',
      ů: 'u',
      ű: 'u',
      ų: 'u',
      Ŵ: 'W',
      ŵ: 'w',
      Ŷ: 'Y',
      ŷ: 'y',
      Ÿ: 'Y',
      Ź: 'Z',
      Ż: 'Z',
      Ž: 'Z',
      ź: 'z',
      ż: 'z',
      ž: 'z',
      Ĳ: 'IJ',
      ĳ: 'ij',
      Œ: 'Oe',
      œ: 'oe',
      ŉ: "'n",
      ſ: 's'
    }
    const AT = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }
    const MT = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'"
    }
    const NT = {
      '\\': '\\',
      "'": "'",
      '\n': 'n',
      '\r': 'r',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    }
    const kT = parseFloat
    const OT = parseInt
    const dg =
            typeof global === 'object' &&
            global &&
            global.Object === Object &&
            global
    const RT =
            typeof self === 'object' && self && self.Object === Object && self
    const Ht = dg || RT || Function('return this')()
    const Yu = typeof gs === 'object' && gs && !gs.nodeType && gs
    const ki = Yu && typeof Ia === 'object' && Ia && !Ia.nodeType && Ia
    const fg = ki && ki.exports === Yu
    const Ju = fg && dg.process
    const Rn = (function () {
      try {
        const N = ki && ki.require && ki.require('util').types
        return N || (Ju && Ju.binding && Ju.binding('util'))
      } catch {}
    })()
    const pg = Rn && Rn.isArrayBuffer
    const hg = Rn && Rn.isDate
    const mg = Rn && Rn.isMap
    const gg = Rn && Rn.isRegExp
    const bg = Rn && Rn.isSet
    const yg = Rn && Rn.isTypedArray
    function Tn (N, $, B) {
      switch (B.length) {
        case 0:
          return N.call($)
        case 1:
          return N.call($, B[0])
        case 2:
          return N.call($, B[0], B[1])
        case 3:
          return N.call($, B[0], B[1], B[2])
      }
      return N.apply($, B)
    }
    function IT (N, $, B, oe) {
      for (let Me = -1, Ye = N == null ? 0 : N.length; ++Me < Ye;) {
        const Rt = N[Me]
        $(oe, Rt, B(Rt), N)
      }
      return oe
    }
    function In (N, $) {
      for (
        let B = -1, oe = N == null ? 0 : N.length;
        ++B < oe && $(N[B], B, N) !== !1;

      );
      return N
    }
    function DT (N, $) {
      for (
        let B = N == null ? 0 : N.length;
        B-- && $(N[B], B, N) !== !1;

      );
      return N
    }
    function Eg (N, $) {
      for (let B = -1, oe = N == null ? 0 : N.length; ++B < oe;) {
        if (!$(N[B], B, N)) return !1
      }
      return !0
    }
    function ei (N, $) {
      for (
        var B = -1, oe = N == null ? 0 : N.length, Me = 0, Ye = [];
        ++B < oe;

      ) {
        const Rt = N[B]
        $(Rt, B, N) && (Ye[Me++] = Rt)
      }
      return Ye
    }
    function Fa (N, $) {
      const B = N == null ? 0 : N.length
      return !!B && _o(N, $, 0) > -1
    }
    function Xu (N, $, B) {
      for (let oe = -1, Me = N == null ? 0 : N.length; ++oe < Me;) {
        if (B($, N[oe])) return !0
      }
      return !1
    }
    function lt (N, $) {
      for (
        var B = -1, oe = N == null ? 0 : N.length, Me = Array(oe);
        ++B < oe;

      ) {
        Me[B] = $(N[B], B, N)
      }
      return Me
    }
    function ti (N, $) {
      for (let B = -1, oe = $.length, Me = N.length; ++B < oe;) {
        N[Me + B] = $[B]
      }
      return N
    }
    function Zu (N, $, B, oe) {
      let Me = -1
      const Ye = N == null ? 0 : N.length
      for (oe && Ye && (B = N[++Me]); ++Me < Ye;) B = $(B, N[Me], Me, N)
      return B
    }
    function LT (N, $, B, oe) {
      let Me = N == null ? 0 : N.length
      for (oe && Me && (B = N[--Me]); Me--;) B = $(B, N[Me], Me, N)
      return B
    }
    function ju (N, $) {
      for (let B = -1, oe = N == null ? 0 : N.length; ++B < oe;) {
        if ($(N[B], B, N)) return !0
      }
      return !1
    }
    const PT = Qu('length')
    function BT (N) {
      return N.split('')
    }
    function FT (N) {
      return N.match(GS) || []
    }
    function vg (N, $, B) {
      let oe
      return (
        B(N, function (Me, Ye, Rt) {
          if ($(Me, Ye, Rt)) return (oe = Ye), !1
        }),
        oe
      )
    }
    function Ha (N, $, B, oe) {
      for (
        let Me = N.length, Ye = B + (oe ? 1 : -1);
        oe ? Ye-- : ++Ye < Me;

      ) {
        if ($(N[Ye], Ye, N)) return Ye
      }
      return -1
    }
    function _o (N, $, B) {
      return $ === $ ? XT(N, $, B) : Ha(N, wg, B)
    }
    function HT (N, $, B, oe) {
      for (let Me = B - 1, Ye = N.length; ++Me < Ye;) {
        if (oe(N[Me], $)) return Me
      }
      return -1
    }
    function wg (N) {
      return N !== N
    }
    function xg (N, $) {
      const B = N == null ? 0 : N.length
      return B ? td(N, $) / B : D
    }
    function Qu (N) {
      return function ($) {
        return $ == null ? t : $[N]
      }
    }
    function ed (N) {
      return function ($) {
        return N == null ? t : N[$]
      }
    }
    function _g (N, $, B, oe, Me) {
      return (
        Me(N, function (Ye, Rt, Qe) {
          B = oe ? ((oe = !1), Ye) : $(B, Ye, Rt, Qe)
        }),
        B
      )
    }
    function $T (N, $) {
      let B = N.length
      for (N.sort($); B--;) N[B] = N[B].value
      return N
    }
    function td (N, $) {
      for (var B, oe = -1, Me = N.length; ++oe < Me;) {
        const Ye = $(N[oe])
        Ye !== t && (B = B === t ? Ye : B + Ye)
      }
      return B
    }
    function nd (N, $) {
      for (var B = -1, oe = Array(N); ++B < N;) oe[B] = $(B)
      return oe
    }
    function zT (N, $) {
      return lt($, function (B) {
        return [B, N[B]]
      })
    }
    function Sg (N) {
      return N && N.slice(0, Mg(N) + 1).replace(Uu, '')
    }
    function Cn (N) {
      return function ($) {
        return N($)
      }
    }
    function rd (N, $) {
      return lt($, function (B) {
        return N[B]
      })
    }
    function Es (N, $) {
      return N.has($)
    }
    function Tg (N, $) {
      for (var B = -1, oe = N.length; ++B < oe && _o($, N[B], 0) > -1;);
      return B
    }
    function Cg (N, $) {
      for (var B = N.length; B-- && _o($, N[B], 0) > -1;);
      return B
    }
    function UT (N, $) {
      for (var B = N.length, oe = 0; B--;) N[B] === $ && ++oe
      return oe
    }
    const WT = ed(CT)
    const KT = ed(AT)
    function VT (N) {
      return '\\' + NT[N]
    }
    function GT (N, $) {
      return N == null ? t : N[$]
    }
    function So (N) {
      return xT.test(N)
    }
    function qT (N) {
      return _T.test(N)
    }
    function YT (N) {
      for (var $, B = []; !($ = N.next()).done;) B.push($.value)
      return B
    }
    function id (N) {
      let $ = -1
      const B = Array(N.size)
      return (
        N.forEach(function (oe, Me) {
          B[++$] = [Me, oe]
        }),
        B
      )
    }
    function Ag (N, $) {
      return function (B) {
        return N($(B))
      }
    }
    function ni (N, $) {
      for (var B = -1, oe = N.length, Me = 0, Ye = []; ++B < oe;) {
        const Rt = N[B];
        (Rt === $ || Rt === u) && ((N[B] = u), (Ye[Me++] = B))
      }
      return Ye
    }
    function $a (N) {
      let $ = -1
      const B = Array(N.size)
      return (
        N.forEach(function (oe) {
          B[++$] = oe
        }),
        B
      )
    }
    function JT (N) {
      let $ = -1
      const B = Array(N.size)
      return (
        N.forEach(function (oe) {
          B[++$] = [oe, oe]
        }),
        B
      )
    }
    function XT (N, $, B) {
      for (let oe = B - 1, Me = N.length; ++oe < Me;) {
        if (N[oe] === $) return oe
      }
      return -1
    }
    function ZT (N, $, B) {
      for (var oe = B + 1; oe--;) if (N[oe] === $) return oe
      return oe
    }
    function To (N) {
      return So(N) ? QT(N) : PT(N)
    }
    function Qn (N) {
      return So(N) ? e1(N) : BT(N)
    }
    function Mg (N) {
      for (var $ = N.length; $-- && US.test(N.charAt($)););
      return $
    }
    const jT = ed(MT)
    function QT (N) {
      for (var $ = (qu.lastIndex = 0); qu.test(N);) ++$
      return $
    }
    function e1 (N) {
      return N.match(qu) || []
    }
    function t1 (N) {
      return N.match(wT) || []
    }
    const n1 = function N ($) {
      $ = $ == null ? Ht : ri.defaults(Ht.Object(), $, ri.pick(Ht, ST))
      const B = $.Array
      const oe = $.Date
      const Me = $.Error
      const Ye = $.Function
      const Rt = $.Math
      const Qe = $.Object
      const od = $.RegExp
      const r1 = $.String
      const Dn = $.TypeError
      const za = B.prototype
      const i1 = Ye.prototype
      const Co = Qe.prototype
      const Ua = $['__core-js_shared__']
      const Wa = i1.toString
      const Ze = Co.hasOwnProperty
      let o1 = 0
      const Ng = (function () {
        const a = /[^.]+$/.exec(
          (Ua && Ua.keys && Ua.keys.IE_PROTO) || ''
        )
        return a ? 'Symbol(src)_1.' + a : ''
      })()
      const Ka = Co.toString
      const s1 = Wa.call(Qe)
      const a1 = Ht._
      const l1 = od(
        '^' +
                    Wa.call(Ze)
                      .replace(Qr, '\\$&')
                      .replace(
                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                        '$1.*?'
                      ) +
                    '$'
      )
      const Va = fg ? $.Buffer : t
      const ii = $.Symbol
      const Ga = $.Uint8Array
      const kg = Va ? Va.allocUnsafe : t
      const qa = Ag(Qe.getPrototypeOf, Qe)
      const Og = Qe.create
      const Rg = Co.propertyIsEnumerable
      const Ya = za.splice
      const Ig = ii ? ii.isConcatSpreadable : t
      const vs = ii ? ii.iterator : t
      const Oi = ii ? ii.toStringTag : t
      const Ja = (function () {
        try {
          const a = Pi(Qe, 'defineProperty')
          return a({}, '', {}), a
        } catch {}
      })()
      const c1 = $.clearTimeout !== Ht.clearTimeout && $.clearTimeout
      const u1 = oe && oe.now !== Ht.Date.now && oe.now
      const d1 = $.setTimeout !== Ht.setTimeout && $.setTimeout
      const Xa = Rt.ceil
      const Za = Rt.floor
      const sd = Qe.getOwnPropertySymbols
      const f1 = Va ? Va.isBuffer : t
      const Dg = $.isFinite
      const p1 = za.join
      const h1 = Ag(Qe.keys, Qe)
      const It = Rt.max
      const jt = Rt.min
      const m1 = oe.now
      const g1 = $.parseInt
      const Lg = Rt.random
      const b1 = za.reverse
      const ad = Pi($, 'DataView')
      const ws = Pi($, 'Map')
      const ld = Pi($, 'Promise')
      const Ao = Pi($, 'Set')
      const xs = Pi($, 'WeakMap')
      const _s = Pi(Qe, 'create')
      const ja = xs && new xs()
      const Mo = {}
      const y1 = Bi(ad)
      const E1 = Bi(ws)
      const v1 = Bi(ld)
      const w1 = Bi(Ao)
      const x1 = Bi(xs)
      const Qa = ii ? ii.prototype : t
      const Ss = Qa ? Qa.valueOf : t
      const Pg = Qa ? Qa.toString : t
      function x (a) {
        if (ht(a) && !ke(a) && !(a instanceof Ue)) {
          if (a instanceof Ln) return a
          if (Ze.call(a, '__wrapped__')) return Bb(a)
        }
        return new Ln(a)
      }
      const No = (function () {
        function a () {}
        return function (c) {
          if (!ft(c)) return {}
          if (Og) return Og(c)
          a.prototype = c
          const p = new a()
          return (a.prototype = t), p
        }
      })()
      function el () {}
      function Ln (a, c) {
        (this.__wrapped__ = a),
        (this.__actions__ = []),
        (this.__chain__ = !!c),
        (this.__index__ = 0),
        (this.__values__ = t)
      }
      (x.templateSettings = {
        escape: xr,
        evaluate: bs,
        interpolate: Ni,
        variable: '',
        imports: { _: x }
      }),
      (x.prototype = el.prototype),
      (x.prototype.constructor = x),
      (Ln.prototype = No(el.prototype)),
      (Ln.prototype.constructor = Ln)
      function Ue (a) {
        (this.__wrapped__ = a),
        (this.__actions__ = []),
        (this.__dir__ = 1),
        (this.__filtered__ = !1),
        (this.__iteratees__ = []),
        (this.__takeCount__ = z),
        (this.__views__ = [])
      }
      function _1 () {
        const a = new Ue(this.__wrapped__)
        return (
          (a.__actions__ = bn(this.__actions__)),
          (a.__dir__ = this.__dir__),
          (a.__filtered__ = this.__filtered__),
          (a.__iteratees__ = bn(this.__iteratees__)),
          (a.__takeCount__ = this.__takeCount__),
          (a.__views__ = bn(this.__views__)),
          a
        )
      }
      function S1 () {
        if (this.__filtered__) {
          var a = new Ue(this);
          (a.__dir__ = -1), (a.__filtered__ = !0)
        } else (a = this.clone()), (a.__dir__ *= -1)
        return a
      }
      function T1 () {
        const a = this.__wrapped__.value()
        const c = this.__dir__
        const p = ke(a)
        const y = c < 0
        const v = p ? a.length : 0
        const _ = BC(0, v, this.__views__)
        const C = _.start
        const M = _.end
        let R = M - C
        let U = y ? M : C - 1
        const W = this.__iteratees__
        const G = W.length
        let te = 0
        const de = jt(R, this.__takeCount__)
        if (!p || (!y && v == R && de == R)) {
          return sb(a, this.__actions__)
        }
        const Ee = []
        e: for (; R-- && te < de;) {
          U += c
          for (var Le = -1, ve = a[U]; ++Le < G;) {
            const $e = W[Le]
            const Ve = $e.iteratee
            const Nn = $e.type
            const dn = Ve(ve)
            if (Nn == me) ve = dn
            else if (!dn) {
              if (Nn == we) continue e
              break e
            }
          }
          Ee[te++] = ve
        }
        return Ee
      }
      (Ue.prototype = No(el.prototype)), (Ue.prototype.constructor = Ue)
      function Ri (a) {
        let c = -1
        const p = a == null ? 0 : a.length
        for (this.clear(); ++c < p;) {
          const y = a[c]
          this.set(y[0], y[1])
        }
      }
      function C1 () {
        (this.__data__ = _s ? _s(null) : {}), (this.size = 0)
      }
      function A1 (a) {
        const c = this.has(a) && delete this.__data__[a]
        return (this.size -= c ? 1 : 0), c
      }
      function M1 (a) {
        const c = this.__data__
        if (_s) {
          const p = c[a]
          return p === s ? t : p
        }
        return Ze.call(c, a) ? c[a] : t
      }
      function N1 (a) {
        const c = this.__data__
        return _s ? c[a] !== t : Ze.call(c, a)
      }
      function k1 (a, c) {
        const p = this.__data__
        return (
          (this.size += this.has(a) ? 0 : 1),
          (p[a] = _s && c === t ? s : c),
          this
        )
      }
      (Ri.prototype.clear = C1),
      (Ri.prototype.delete = A1),
      (Ri.prototype.get = M1),
      (Ri.prototype.has = N1),
      (Ri.prototype.set = k1)
      function _r (a) {
        let c = -1
        const p = a == null ? 0 : a.length
        for (this.clear(); ++c < p;) {
          const y = a[c]
          this.set(y[0], y[1])
        }
      }
      function O1 () {
        (this.__data__ = []), (this.size = 0)
      }
      function R1 (a) {
        const c = this.__data__
        const p = tl(c, a)
        if (p < 0) return !1
        const y = c.length - 1
        return p == y ? c.pop() : Ya.call(c, p, 1), --this.size, !0
      }
      function I1 (a) {
        const c = this.__data__
        const p = tl(c, a)
        return p < 0 ? t : c[p][1]
      }
      function D1 (a) {
        return tl(this.__data__, a) > -1
      }
      function L1 (a, c) {
        const p = this.__data__
        const y = tl(p, a)
        return (
          y < 0 ? (++this.size, p.push([a, c])) : (p[y][1] = c), this
        )
      }
      (_r.prototype.clear = O1),
      (_r.prototype.delete = R1),
      (_r.prototype.get = I1),
      (_r.prototype.has = D1),
      (_r.prototype.set = L1)
      function Sr (a) {
        let c = -1
        const p = a == null ? 0 : a.length
        for (this.clear(); ++c < p;) {
          const y = a[c]
          this.set(y[0], y[1])
        }
      }
      function P1 () {
        (this.size = 0),
        (this.__data__ = {
          hash: new Ri(),
          map: new (ws || _r)(),
          string: new Ri()
        })
      }
      function B1 (a) {
        const c = pl(this, a).delete(a)
        return (this.size -= c ? 1 : 0), c
      }
      function F1 (a) {
        return pl(this, a).get(a)
      }
      function H1 (a) {
        return pl(this, a).has(a)
      }
      function $1 (a, c) {
        const p = pl(this, a)
        const y = p.size
        return p.set(a, c), (this.size += p.size == y ? 0 : 1), this
      }
      (Sr.prototype.clear = P1),
      (Sr.prototype.delete = B1),
      (Sr.prototype.get = F1),
      (Sr.prototype.has = H1),
      (Sr.prototype.set = $1)
      function Ii (a) {
        let c = -1
        const p = a == null ? 0 : a.length
        for (this.__data__ = new Sr(); ++c < p;) this.add(a[c])
      }
      function z1 (a) {
        return this.__data__.set(a, s), this
      }
      function U1 (a) {
        return this.__data__.has(a)
      }
      (Ii.prototype.add = Ii.prototype.push = z1),
      (Ii.prototype.has = U1)
      function er (a) {
        const c = (this.__data__ = new _r(a))
        this.size = c.size
      }
      function W1 () {
        (this.__data__ = new _r()), (this.size = 0)
      }
      function K1 (a) {
        const c = this.__data__
        const p = c.delete(a)
        return (this.size = c.size), p
      }
      function V1 (a) {
        return this.__data__.get(a)
      }
      function G1 (a) {
        return this.__data__.has(a)
      }
      function q1 (a, c) {
        let p = this.__data__
        if (p instanceof _r) {
          const y = p.__data__
          if (!ws || y.length < n - 1) {
            return y.push([a, c]), (this.size = ++p.size), this
          }
          p = this.__data__ = new Sr(y)
        }
        return p.set(a, c), (this.size = p.size), this
      }
      (er.prototype.clear = W1),
      (er.prototype.delete = K1),
      (er.prototype.get = V1),
      (er.prototype.has = G1),
      (er.prototype.set = q1)
      function Bg (a, c) {
        const p = ke(a)
        const y = !p && Fi(a)
        const v = !p && !y && ci(a)
        const _ = !p && !y && !v && Io(a)
        const C = p || y || v || _
        const M = C ? nd(a.length, r1) : []
        const R = M.length
        for (const U in a) {
          (c || Ze.call(a, U)) &&
                        !(
                          C &&
                            (U == 'length' ||
                                (v && (U == 'offset' || U == 'parent')) ||
                                (_ &&
                                    (U == 'buffer' ||
                                        U == 'byteLength' ||
                                        U == 'byteOffset')) ||
                                Mr(U, R))
                        ) &&
                        M.push(U)
        }
        return M
      }
      function Fg (a) {
        const c = a.length
        return c ? a[Ed(0, c - 1)] : t
      }
      function Y1 (a, c) {
        return hl(bn(a), Di(c, 0, a.length))
      }
      function J1 (a) {
        return hl(bn(a))
      }
      function cd (a, c, p) {
        ((p !== t && !tr(a[c], p)) || (p === t && !(c in a))) &&
                    Tr(a, c, p)
      }
      function Ts (a, c, p) {
        const y = a[c];
        (!(Ze.call(a, c) && tr(y, p)) || (p === t && !(c in a))) &&
                    Tr(a, c, p)
      }
      function tl (a, c) {
        for (let p = a.length; p--;) if (tr(a[p][0], c)) return p
        return -1
      }
      function X1 (a, c, p, y) {
        return (
          oi(a, function (v, _, C) {
            c(y, v, p(v), C)
          }),
          y
        )
      }
      function Hg (a, c) {
        return a && dr(c, $t(c), a)
      }
      function Z1 (a, c) {
        return a && dr(c, En(c), a)
      }
      function Tr (a, c, p) {
        c == '__proto__' && Ja
          ? Ja(a, c, {
            configurable: !0,
            enumerable: !0,
            value: p,
            writable: !0
          })
          : (a[c] = p)
      }
      function ud (a, c) {
        for (
          var p = -1, y = c.length, v = B(y), _ = a == null;
          ++p < y;

        ) {
          v[p] = _ ? t : Kd(a, c[p])
        }
        return v
      }
      function Di (a, c, p) {
        return (
          a === a &&
                        (p !== t && (a = a <= p ? a : p),
                        c !== t && (a = a >= c ? a : c)),
          a
        )
      }
      function Pn (a, c, p, y, v, _) {
        let C
        const M = c & d
        const R = c & f
        const U = c & h
        if ((p && (C = v ? p(a, y, v, _) : p(a)), C !== t)) {
          return C
        }
        if (!ft(a)) return a
        const W = ke(a)
        if (W) {
          if (((C = HC(a)), !M)) return bn(a, C)
        } else {
          const G = Qt(a)
          const te = G == St || G == Xt
          if (ci(a)) return cb(a, M)
          if (G == Tt || G == Ae || (te && !v)) {
            if (((C = R || te ? {} : Mb(a)), !M)) {
              return R ? MC(a, Z1(C, a)) : AC(a, Hg(C, a))
            }
          } else {
            if (!tt[G]) return v ? a : {}
            C = $C(a, G, M)
          }
        }
        _ || (_ = new er())
        const de = _.get(a)
        if (de) return de
        _.set(a, C),
        ry(a)
          ? a.forEach(function (ve) {
            C.add(Pn(ve, c, p, ve, a, _))
          })
          : ty(a) &&
                          a.forEach(function (ve, $e) {
                            C.set($e, Pn(ve, c, p, $e, a, _))
                          })
        const Ee = U ? (R ? kd : Nd) : R ? En : $t
        const Le = W ? t : Ee(a)
        return (
          In(Le || a, function (ve, $e) {
            Le && (($e = ve), (ve = a[$e])),
            Ts(C, $e, Pn(ve, c, p, $e, a, _))
          }),
          C
        )
      }
      function j1 (a) {
        const c = $t(a)
        return function (p) {
          return $g(p, a, c)
        }
      }
      function $g (a, c, p) {
        let y = p.length
        if (a == null) return !y
        for (a = Qe(a); y--;) {
          const v = p[y]
          const _ = c[v]
          const C = a[v]
          if ((C === t && !(v in a)) || !_(C)) return !1
        }
        return !0
      }
      function zg (a, c, p) {
        if (typeof a !== 'function') throw new Dn(i)
        return Rs(function () {
          a.apply(t, p)
        }, c)
      }
      function Cs (a, c, p, y) {
        let v = -1
        let _ = Fa
        let C = !0
        const M = a.length
        const R = []
        const U = c.length
        if (!M) return R
        p && (c = lt(c, Cn(p))),
        y
          ? ((_ = Xu), (C = !1))
          : c.length >= n &&
                          ((_ = Es), (C = !1), (c = new Ii(c)))
        e: for (; ++v < M;) {
          let W = a[v]
          const G = p == null ? W : p(W)
          if (((W = y || W !== 0 ? W : 0), C && G === G)) {
            for (let te = U; te--;) {
              if (c[te] === G) continue e
            }
            R.push(W)
          } else _(c, G, y) || R.push(W)
        }
        return R
      }
      var oi = hb(ur)
      const Ug = hb(fd, !0)
      function Q1 (a, c) {
        let p = !0
        return (
          oi(a, function (y, v, _) {
            return (p = !!c(y, v, _)), p
          }),
          p
        )
      }
      function nl (a, c, p) {
        for (let y = -1, v = a.length; ++y < v;) {
          const _ = a[y]
          const C = c(_)
          if (C != null && (M === t ? C === C && !Mn(C) : p(C, M))) {
            var M = C
            var R = _
          }
        }
        return R
      }
      function eC (a, c, p, y) {
        const v = a.length
        for (
          p = Ie(p),
          p < 0 && (p = -p > v ? 0 : v + p),
          y = y === t || y > v ? v : Ie(y),
          y < 0 && (y += v),
          y = p > y ? 0 : oy(y);
          p < y;

        ) {
          a[p++] = c
        }
        return a
      }
      function Wg (a, c) {
        const p = []
        return (
          oi(a, function (y, v, _) {
            c(y, v, _) && p.push(y)
          }),
          p
        )
      }
      function Vt (a, c, p, y, v) {
        let _ = -1
        const C = a.length
        for (p || (p = UC), v || (v = []); ++_ < C;) {
          const M = a[_]
          c > 0 && p(M)
            ? c > 1
              ? Vt(M, c - 1, p, y, v)
              : ti(v, M)
            : y || (v[v.length] = M)
        }
        return v
      }
      const dd = mb()
      const Kg = mb(!0)
      function ur (a, c) {
        return a && dd(a, c, $t)
      }
      function fd (a, c) {
        return a && Kg(a, c, $t)
      }
      function rl (a, c) {
        return ei(c, function (p) {
          return Nr(a[p])
        })
      }
      function Li (a, c) {
        c = ai(c, a)
        for (var p = 0, y = c.length; a != null && p < y;) {
          a = a[fr(c[p++])]
        }
        return p && p == y ? a : t
      }
      function Vg (a, c, p) {
        const y = c(a)
        return ke(a) ? y : ti(y, p(a))
      }
      function cn (a) {
        return a == null
          ? a === t
            ? pe
            : Zt
          : Oi && Oi in Qe(a)
            ? PC(a)
            : JC(a)
      }
      function pd (a, c) {
        return a > c
      }
      function tC (a, c) {
        return a != null && Ze.call(a, c)
      }
      function nC (a, c) {
        return a != null && c in Qe(a)
      }
      function rC (a, c, p) {
        return a >= jt(c, p) && a < It(c, p)
      }
      function hd (a, c, p) {
        for (
          var y = p ? Xu : Fa,
            v = a[0].length,
            _ = a.length,
            C = _,
            M = B(_),
            R = 1 / 0,
            U = [];
          C--;

        ) {
          var W = a[C]
          C && c && (W = lt(W, Cn(c))),
          (R = jt(W.length, R)),
          (M[C] =
                            !p && (c || (v >= 120 && W.length >= 120))
                              ? new Ii(C && W)
                              : t)
        }
        W = a[0]
        let G = -1
        const te = M[0]
        e: for (; ++G < v && U.length < R;) {
          let de = W[G]
          const Ee = c ? c(de) : de
          if (
            ((de = p || de !== 0 ? de : 0),
            !(te ? Es(te, Ee) : y(U, Ee, p)))
          ) {
            for (C = _; --C;) {
              const Le = M[C]
              if (!(Le ? Es(Le, Ee) : y(a[C], Ee, p))) {
                continue e
              }
            }
            te && te.push(Ee), U.push(de)
          }
        }
        return U
      }
      function iC (a, c, p, y) {
        return (
          ur(a, function (v, _, C) {
            c(y, p(v), _, C)
          }),
          y
        )
      }
      function As (a, c, p) {
        (c = ai(c, a)), (a = Rb(a, c))
        const y = a == null ? a : a[fr(Fn(c))]
        return y == null ? t : Tn(y, a, p)
      }
      function Gg (a) {
        return ht(a) && cn(a) == Ae
      }
      function oC (a) {
        return ht(a) && cn(a) == Bt
      }
      function sC (a) {
        return ht(a) && cn(a) == _t
      }
      function Ms (a, c, p, y, v) {
        return a === c
          ? !0
          : a == null || c == null || (!ht(a) && !ht(c))
            ? a !== a && c !== c
            : aC(a, c, p, y, Ms, v)
      }
      function aC (a, c, p, y, v, _) {
        let C = ke(a)
        const M = ke(c)
        let R = C ? je : Qt(a)
        let U = M ? je : Qt(c);
        (R = R == Ae ? Tt : R), (U = U == Ae ? Tt : U)
        let W = R == Tt
        const G = U == Tt
        const te = R == U
        if (te && ci(a)) {
          if (!ci(c)) return !1;
          (C = !0), (W = !1)
        }
        if (te && !W) {
          return (
            _ || (_ = new er()),
            C || Io(a)
              ? Tb(a, c, p, y, v, _)
              : DC(a, c, R, p, y, v, _)
          )
        }
        if (!(p & m)) {
          const de = W && Ze.call(a, '__wrapped__')
          const Ee = G && Ze.call(c, '__wrapped__')
          if (de || Ee) {
            const Le = de ? a.value() : a
            const ve = Ee ? c.value() : c
            return _ || (_ = new er()), v(Le, ve, p, y, _)
          }
        }
        return te ? (_ || (_ = new er()), LC(a, c, p, y, v, _)) : !1
      }
      function lC (a) {
        return ht(a) && Qt(a) == pt
      }
      function md (a, c, p, y) {
        let v = p.length
        const _ = v
        const C = !y
        if (a == null) return !_
        for (a = Qe(a); v--;) {
          var M = p[v]
          if (C && M[2] ? M[1] !== a[M[0]] : !(M[0] in a)) {
            return !1
          }
        }
        for (; ++v < _;) {
          M = p[v]
          const R = M[0]
          const U = a[R]
          const W = M[1]
          if (C && M[2]) {
            if (U === t && !(R in a)) return !1
          } else {
            const G = new er()
            if (y) var te = y(U, W, R, a, c, G)
            if (!(te === t ? Ms(W, U, m | b, y, G) : te)) {
              return !1
            }
          }
        }
        return !0
      }
      function qg (a) {
        if (!ft(a) || KC(a)) return !1
        const c = Nr(a) ? l1 : jS
        return c.test(Bi(a))
      }
      function cC (a) {
        return ht(a) && cn(a) == Pt
      }
      function uC (a) {
        return ht(a) && Qt(a) == V
      }
      function dC (a) {
        return ht(a) && vl(a.length) && !!it[cn(a)]
      }
      function Yg (a) {
        return typeof a === 'function'
          ? a
          : a == null
            ? vn
            : typeof a === 'object'
              ? ke(a)
                ? Zg(a[0], a[1])
                : Xg(a)
              : gy(a)
      }
      function gd (a) {
        if (!Os(a)) return h1(a)
        const c = []
        for (const p in Qe(a)) {
          Ze.call(a, p) && p != 'constructor' && c.push(p)
        }
        return c
      }
      function fC (a) {
        if (!ft(a)) return YC(a)
        const c = Os(a)
        const p = []
        for (const y in a) {
          (y == 'constructor' && (c || !Ze.call(a, y))) || p.push(y)
        }
        return p
      }
      function bd (a, c) {
        return a < c
      }
      function Jg (a, c) {
        let p = -1
        const y = yn(a) ? B(a.length) : []
        return (
          oi(a, function (v, _, C) {
            y[++p] = c(v, _, C)
          }),
          y
        )
      }
      function Xg (a) {
        const c = Rd(a)
        return c.length == 1 && c[0][2]
          ? kb(c[0][0], c[0][1])
          : function (p) {
            return p === a || md(p, a, c)
          }
      }
      function Zg (a, c) {
        return Dd(a) && Nb(c)
          ? kb(fr(a), c)
          : function (p) {
            const y = Kd(p, a)
            return y === t && y === c
              ? Vd(p, a)
              : Ms(c, y, m | b)
          }
      }
      function il (a, c, p, y, v) {
        a !== c &&
                    dd(
                      c,
                      function (_, C) {
                        if ((v || (v = new er()), ft(_))) {
                          pC(a, c, C, p, il, y, v)
                        } else {
                          let M = y ? y(Pd(a, C), _, C + '', a, c, v) : t
                          M === t && (M = _), cd(a, C, M)
                        }
                      },
                      En
                    )
      }
      function pC (a, c, p, y, v, _, C) {
        const M = Pd(a, p)
        const R = Pd(c, p)
        const U = C.get(R)
        if (U) {
          cd(a, p, U)
          return
        }
        let W = _ ? _(M, R, p + '', a, c, C) : t
        let G = W === t
        if (G) {
          const te = ke(R)
          const de = !te && ci(R)
          const Ee = !te && !de && Io(R);
          (W = R),
          te || de || Ee
            ? ke(M)
              ? (W = M)
              : Et(M)
                ? (W = bn(M))
                : de
                  ? ((G = !1), (W = cb(R, !0)))
                  : Ee
                    ? ((G = !1), (W = ub(R, !0)))
                    : (W = [])
            : Is(R) || Fi(R)
              ? ((W = M),
                Fi(M)
                  ? (W = sy(M))
                  : (!ft(M) || Nr(M)) && (W = Mb(R)))
              : (G = !1)
        }
        G && (C.set(R, W), v(W, R, y, _, C), C.delete(R)), cd(a, p, W)
      }
      function jg (a, c) {
        const p = a.length
        if (p) return (c += c < 0 ? p : 0), Mr(c, p) ? a[c] : t
      }
      function Qg (a, c, p) {
        c.length
          ? (c = lt(c, function (_) {
              return ke(_)
                ? function (C) {
                  return Li(C, _.length === 1 ? _[0] : _)
                }
                : _
            }))
          : (c = [vn])
        let y = -1
        c = lt(c, Cn(be()))
        const v = Jg(a, function (_, C, M) {
          const R = lt(c, function (U) {
            return U(_)
          })
          return { criteria: R, index: ++y, value: _ }
        })
        return $T(v, function (_, C) {
          return CC(_, C, p)
        })
      }
      function hC (a, c) {
        return eb(a, c, function (p, y) {
          return Vd(a, y)
        })
      }
      function eb (a, c, p) {
        for (var y = -1, v = c.length, _ = {}; ++y < v;) {
          const C = c[y]
          const M = Li(a, C)
          p(M, C) && Ns(_, ai(C, a), M)
        }
        return _
      }
      function mC (a) {
        return function (c) {
          return Li(c, a)
        }
      }
      function yd (a, c, p, y) {
        const v = y ? HT : _o
        let _ = -1
        const C = c.length
        let M = a
        for (
          a === c && (c = bn(c)), p && (M = lt(a, Cn(p)));
          ++_ < C;

        ) {
          for (
            let R = 0, U = c[_], W = p ? p(U) : U;
            (R = v(M, W, R, y)) > -1;

          ) {
            M !== a && Ya.call(M, R, 1), Ya.call(a, R, 1)
          }
        }
        return a
      }
      function tb (a, c) {
        for (let p = a ? c.length : 0, y = p - 1; p--;) {
          const v = c[p]
          if (p == y || v !== _) {
            var _ = v
            Mr(v) ? Ya.call(a, v, 1) : xd(a, v)
          }
        }
        return a
      }
      function Ed (a, c) {
        return a + Za(Lg() * (c - a + 1))
      }
      function gC (a, c, p, y) {
        for (
          var v = -1, _ = It(Xa((c - a) / (p || 1)), 0), C = B(_);
          _--;

        ) {
          (C[y ? _ : ++v] = a), (a += p)
        }
        return C
      }
      function vd (a, c) {
        let p = ''
        if (!a || c < 1 || c > ye) return p
        do c % 2 && (p += a), (c = Za(c / 2)), c && (a += a)
        while (c)
        return p
      }
      function He (a, c) {
        return Bd(Ob(a, c, vn), a + '')
      }
      function bC (a) {
        return Fg(Do(a))
      }
      function yC (a, c) {
        const p = Do(a)
        return hl(p, Di(c, 0, p.length))
      }
      function Ns (a, c, p, y) {
        if (!ft(a)) return a
        c = ai(c, a)
        for (
          let v = -1, _ = c.length, C = _ - 1, M = a;
          M != null && ++v < _;

        ) {
          const R = fr(c[v])
          let U = p
          if (
            R === '__proto__' ||
                        R === 'constructor' ||
                        R === 'prototype'
          ) {
            return a
          }
          if (v != C) {
            const W = M[R];
            (U = y ? y(W, R, M) : t),
            U === t && (U = ft(W) ? W : Mr(c[v + 1]) ? [] : {})
          }
          Ts(M, R, U), (M = M[R])
        }
        return a
      }
      const nb = ja
        ? function (a, c) {
          return ja.set(a, c), a
        }
        : vn
      const EC = Ja
        ? function (a, c) {
          return Ja(a, 'toString', {
            configurable: !0,
            enumerable: !1,
            value: qd(c),
            writable: !0
          })
        }
        : vn
      function vC (a) {
        return hl(Do(a))
      }
      function Bn (a, c, p) {
        let y = -1
        let v = a.length
        c < 0 && (c = -c > v ? 0 : v + c),
        (p = p > v ? v : p),
        p < 0 && (p += v),
        (v = c > p ? 0 : (p - c) >>> 0),
        (c >>>= 0)
        for (var _ = B(v); ++y < v;) _[y] = a[y + c]
        return _
      }
      function wC (a, c) {
        let p
        return (
          oi(a, function (y, v, _) {
            return (p = c(y, v, _)), !p
          }),
          !!p
        )
      }
      function ol (a, c, p) {
        let y = 0
        let v = a == null ? y : a.length
        if (typeof c === 'number' && c === c && v <= ie) {
          for (; y < v;) {
            const _ = (y + v) >>> 1
            const C = a[_]
            C !== null && !Mn(C) && (p ? C <= c : C < c)
              ? (y = _ + 1)
              : (v = _)
          }
          return v
        }
        return wd(a, c, vn, p)
      }
      function wd (a, c, p, y) {
        let v = 0
        let _ = a == null ? 0 : a.length
        if (_ === 0) return 0
        c = p(c)
        for (
          let C = c !== c, M = c === null, R = Mn(c), U = c === t;
          v < _;

        ) {
          const W = Za((v + _) / 2)
          const G = p(a[W])
          const te = G !== t
          const de = G === null
          const Ee = G === G
          const Le = Mn(G)
          if (C) var ve = y || Ee
          else {
            U
              ? (ve = Ee && (y || te))
              : M
                ? (ve = Ee && te && (y || !de))
                : R
                  ? (ve = Ee && te && !de && (y || !Le))
                  : de || Le
                    ? (ve = !1)
                    : (ve = y ? G <= c : G < c)
          }
          ve ? (v = W + 1) : (_ = W)
        }
        return jt(_, j)
      }
      function rb (a, c) {
        for (var p = -1, y = a.length, v = 0, _ = []; ++p < y;) {
          const C = a[p]
          const M = c ? c(C) : C
          if (!p || !tr(M, R)) {
            var R = M
            _[v++] = C === 0 ? 0 : C
          }
        }
        return _
      }
      function ib (a) {
        return typeof a === 'number' ? a : Mn(a) ? D : +a
      }
      function An (a) {
        if (typeof a === 'string') return a
        if (ke(a)) return lt(a, An) + ''
        if (Mn(a)) return Pg ? Pg.call(a) : ''
        const c = a + ''
        return c == '0' && 1 / a == -ge ? '-0' : c
      }
      function si (a, c, p) {
        let y = -1
        let v = Fa
        const _ = a.length
        let C = !0
        const M = []
        let R = M
        if (p) (C = !1), (v = Xu)
        else if (_ >= n) {
          const U = c ? null : RC(a)
          if (U) return $a(U);
          (C = !1), (v = Es), (R = new Ii())
        } else R = c ? [] : M
        e: for (; ++y < _;) {
          let W = a[y]
          const G = c ? c(W) : W
          if (((W = p || W !== 0 ? W : 0), C && G === G)) {
            for (let te = R.length; te--;) {
              if (R[te] === G) continue e
            }
            c && R.push(G), M.push(W)
          } else v(R, G, p) || (R !== M && R.push(G), M.push(W))
        }
        return M
      }
      function xd (a, c) {
        return (
          (c = ai(c, a)),
          (a = Rb(a, c)),
          a == null || delete a[fr(Fn(c))]
        )
      }
      function ob (a, c, p, y) {
        return Ns(a, c, p(Li(a, c)), y)
      }
      function sl (a, c, p, y) {
        for (
          var v = a.length, _ = y ? v : -1;
          (y ? _-- : ++_ < v) && c(a[_], _, a);

        );
        return p
          ? Bn(a, y ? 0 : _, y ? _ + 1 : v)
          : Bn(a, y ? _ + 1 : 0, y ? v : _)
      }
      function sb (a, c) {
        let p = a
        return (
          p instanceof Ue && (p = p.value()),
          Zu(
            c,
            function (y, v) {
              return v.func.apply(v.thisArg, ti([y], v.args))
            },
            p
          )
        )
      }
      function _d (a, c, p) {
        const y = a.length
        if (y < 2) return y ? si(a[0]) : []
        for (var v = -1, _ = B(y); ++v < y;) {
          for (let C = a[v], M = -1; ++M < y;) {
            M != v && (_[v] = Cs(_[v] || C, a[M], c, p))
          }
        }
        return si(Vt(_, 1), c, p)
      }
      function ab (a, c, p) {
        for (
          var y = -1, v = a.length, _ = c.length, C = {};
          ++y < v;

        ) {
          const M = y < _ ? c[y] : t
          p(C, a[y], M)
        }
        return C
      }
      function Sd (a) {
        return Et(a) ? a : []
      }
      function Td (a) {
        return typeof a === 'function' ? a : vn
      }
      function ai (a, c) {
        return ke(a) ? a : Dd(a, c) ? [a] : Pb(Xe(a))
      }
      const xC = He
      function li (a, c, p) {
        const y = a.length
        return (p = p === t ? y : p), !c && p >= y ? a : Bn(a, c, p)
      }
      const lb =
                c1 ||
                function (a) {
                  return Ht.clearTimeout(a)
                }
      function cb (a, c) {
        if (c) return a.slice()
        const p = a.length
        const y = kg ? kg(p) : new a.constructor(p)
        return a.copy(y), y
      }
      function Cd (a) {
        const c = new a.constructor(a.byteLength)
        return new Ga(c).set(new Ga(a)), c
      }
      function _C (a, c) {
        const p = c ? Cd(a.buffer) : a.buffer
        return new a.constructor(p, a.byteOffset, a.byteLength)
      }
      function SC (a) {
        const c = new a.constructor(a.source, Gm.exec(a))
        return (c.lastIndex = a.lastIndex), c
      }
      function TC (a) {
        return Ss ? Qe(Ss.call(a)) : {}
      }
      function ub (a, c) {
        const p = c ? Cd(a.buffer) : a.buffer
        return new a.constructor(p, a.byteOffset, a.length)
      }
      function db (a, c) {
        if (a !== c) {
          const p = a !== t
          const y = a === null
          const v = a === a
          const _ = Mn(a)
          const C = c !== t
          const M = c === null
          const R = c === c
          const U = Mn(c)
          if (
            (!M && !U && !_ && a > c) ||
                        (_ && C && R && !M && !U) ||
                        (y && C && R) ||
                        (!p && R) ||
                        !v
          ) {
            return 1
          }
          if (
            (!y && !_ && !U && a < c) ||
                        (U && p && v && !y && !_) ||
                        (M && p && v) ||
                        (!C && v) ||
                        !R
          ) {
            return -1
          }
        }
        return 0
      }
      function CC (a, c, p) {
        for (
          let y = -1,
            v = a.criteria,
            _ = c.criteria,
            C = v.length,
            M = p.length;
          ++y < C;

        ) {
          const R = db(v[y], _[y])
          if (R) {
            if (y >= M) return R
            const U = p[y]
            return R * (U == 'desc' ? -1 : 1)
          }
        }
        return a.index - c.index
      }
      function fb (a, c, p, y) {
        for (
          var v = -1,
            _ = a.length,
            C = p.length,
            M = -1,
            R = c.length,
            U = It(_ - C, 0),
            W = B(R + U),
            G = !y;
          ++M < R;

        ) {
          W[M] = c[M]
        }
        for (; ++v < C;) (G || v < _) && (W[p[v]] = a[v])
        for (; U--;) W[M++] = a[v++]
        return W
      }
      function pb (a, c, p, y) {
        for (
          var v = -1,
            _ = a.length,
            C = -1,
            M = p.length,
            R = -1,
            U = c.length,
            W = It(_ - M, 0),
            G = B(W + U),
            te = !y;
          ++v < W;

        ) {
          G[v] = a[v]
        }
        for (var de = v; ++R < U;) G[de + R] = c[R]
        for (; ++C < M;) (te || v < _) && (G[de + p[C]] = a[v++])
        return G
      }
      function bn (a, c) {
        let p = -1
        const y = a.length
        for (c || (c = B(y)); ++p < y;) c[p] = a[p]
        return c
      }
      function dr (a, c, p, y) {
        const v = !p
        p || (p = {})
        for (let _ = -1, C = c.length; ++_ < C;) {
          const M = c[_]
          let R = y ? y(p[M], a[M], M, p, a) : t
          R === t && (R = a[M]), v ? Tr(p, M, R) : Ts(p, M, R)
        }
        return p
      }
      function AC (a, c) {
        return dr(a, Id(a), c)
      }
      function MC (a, c) {
        return dr(a, Cb(a), c)
      }
      function al (a, c) {
        return function (p, y) {
          const v = ke(p) ? IT : X1
          const _ = c ? c() : {}
          return v(p, a, be(y, 2), _)
        }
      }
      function ko (a) {
        return He(function (c, p) {
          let y = -1
          let v = p.length
          let _ = v > 1 ? p[v - 1] : t
          const C = v > 2 ? p[2] : t
          for (
            _ =
                            a.length > 3 && typeof _ === 'function'
                              ? (v--, _)
                              : t,
            C &&
                                un(p[0], p[1], C) &&
                                ((_ = v < 3 ? t : _), (v = 1)),
            c = Qe(c);
            ++y < v;

          ) {
            const M = p[y]
            M && a(c, M, y, _)
          }
          return c
        })
      }
      function hb (a, c) {
        return function (p, y) {
          if (p == null) return p
          if (!yn(p)) return a(p, y)
          for (
            let v = p.length, _ = c ? v : -1, C = Qe(p);
            (c ? _-- : ++_ < v) && y(C[_], _, C) !== !1;

          );
          return p
        }
      }
      function mb (a) {
        return function (c, p, y) {
          for (let v = -1, _ = Qe(c), C = y(c), M = C.length; M--;) {
            const R = C[a ? M : ++v]
            if (p(_[R], R, _) === !1) break
          }
          return c
        }
      }
      function NC (a, c, p) {
        const y = c & g
        const v = ks(a)
        function _ () {
          const C = this && this !== Ht && this instanceof _ ? v : a
          return C.apply(y ? p : this, arguments)
        }
        return _
      }
      function gb (a) {
        return function (c) {
          c = Xe(c)
          const p = So(c) ? Qn(c) : t
          const y = p ? p[0] : c.charAt(0)
          const v = p ? li(p, 1).join('') : c.slice(1)
          return y[a]() + v
        }
      }
      function Oo (a) {
        return function (c) {
          return Zu(hy(py(c).replace(ET, '')), a, '')
        }
      }
      function ks (a) {
        return function () {
          const c = arguments
          switch (c.length) {
            case 0:
              return new a()
            case 1:
              return new a(c[0])
            case 2:
              return new a(c[0], c[1])
            case 3:
              return new a(c[0], c[1], c[2])
            case 4:
              return new a(c[0], c[1], c[2], c[3])
            case 5:
              return new a(c[0], c[1], c[2], c[3], c[4])
            case 6:
              return new a(c[0], c[1], c[2], c[3], c[4], c[5])
            case 7:
              return new a(
                c[0],
                c[1],
                c[2],
                c[3],
                c[4],
                c[5],
                c[6]
              )
          }
          const p = No(a.prototype)
          const y = a.apply(p, c)
          return ft(y) ? y : p
        }
      }
      function kC (a, c, p) {
        const y = ks(a)
        function v () {
          for (
            var _ = arguments.length, C = B(_), M = _, R = Ro(v);
            M--;

          ) {
            C[M] = arguments[M]
          }
          const U =
                        _ < 3 && C[0] !== R && C[_ - 1] !== R ? [] : ni(C, R)
          if (((_ -= U.length), _ < p)) {
            return wb(
              a,
              c,
              ll,
              v.placeholder,
              t,
              C,
              U,
              t,
              t,
              p - _
            )
          }
          const W = this && this !== Ht && this instanceof v ? y : a
          return Tn(W, this, C)
        }
        return v
      }
      function bb (a) {
        return function (c, p, y) {
          const v = Qe(c)
          if (!yn(c)) {
            var _ = be(p, 3);
            (c = $t(c)),
            (p = function (M) {
              return _(v[M], M, v)
            })
          }
          const C = a(c, p, y)
          return C > -1 ? v[_ ? c[C] : C] : t
        }
      }
      function yb (a) {
        return Ar(function (c) {
          const p = c.length
          let y = p
          const v = Ln.prototype.thru
          for (a && c.reverse(); y--;) {
            var _ = c[y]
            if (typeof _ !== 'function') throw new Dn(i)
            if (v && !C && fl(_) == 'wrapper') {
              var C = new Ln([], !0)
            }
          }
          for (y = C ? y : p; ++y < p;) {
            _ = c[y]
            const M = fl(_)
            const R = M == 'wrapper' ? Od(_) : t
            R &&
                        Ld(R[0]) &&
                        R[1] == (P | S | k | I) &&
                        !R[4].length &&
                        R[9] == 1
              ? (C = C[fl(R[0])].apply(C, R[3]))
              : (C = _.length == 1 && Ld(_) ? C[M]() : C.thru(_))
          }
          return function () {
            const U = arguments
            const W = U[0]
            if (C && U.length == 1 && ke(W)) {
              return C.plant(W).value()
            }
            for (
              var G = 0, te = p ? c[G].apply(this, U) : W;
              ++G < p;

            ) {
              te = c[G].call(this, te)
            }
            return te
          }
        })
      }
      function ll (a, c, p, y, v, _, C, M, R, U) {
        const W = c & P
        const G = c & g
        const te = c & E
        const de = c & (S | O)
        const Ee = c & Y
        const Le = te ? t : ks(a)
        function ve () {
          for (
            var $e = arguments.length, Ve = B($e), Nn = $e;
            Nn--;

          ) {
            Ve[Nn] = arguments[Nn]
          }
          if (de) {
            var dn = Ro(ve)
            var kn = UT(Ve, dn)
          }
          if (
            (y && (Ve = fb(Ve, y, v, de)),
            _ && (Ve = pb(Ve, _, C, de)),
            ($e -= kn),
            de && $e < U)
          ) {
            const vt = ni(Ve, dn)
            return wb(
              a,
              c,
              ll,
              ve.placeholder,
              p,
              Ve,
              vt,
              M,
              R,
              U - $e
            )
          }
          const nr = G ? p : this
          let Or = te ? nr[a] : a
          return (
            ($e = Ve.length),
            M ? (Ve = XC(Ve, M)) : Ee && $e > 1 && Ve.reverse(),
            W && R < $e && (Ve.length = R),
            this &&
                            this !== Ht &&
                            this instanceof ve &&
                            (Or = Le || ks(Or)),
            Or.apply(nr, Ve)
          )
        }
        return ve
      }
      function Eb (a, c) {
        return function (p, y) {
          return iC(p, a, c(y), {})
        }
      }
      function cl (a, c) {
        return function (p, y) {
          let v
          if (p === t && y === t) return c
          if ((p !== t && (v = p), y !== t)) {
            if (v === t) return y
            typeof p === 'string' || typeof y === 'string'
              ? ((p = An(p)), (y = An(y)))
              : ((p = ib(p)), (y = ib(y))),
            (v = a(p, y))
          }
          return v
        }
      }
      function Ad (a) {
        return Ar(function (c) {
          return (
            (c = lt(c, Cn(be()))),
            He(function (p) {
              const y = this
              return a(c, function (v) {
                return Tn(v, y, p)
              })
            })
          )
        })
      }
      function ul (a, c) {
        c = c === t ? ' ' : An(c)
        const p = c.length
        if (p < 2) return p ? vd(c, a) : c
        const y = vd(c, Xa(a / To(c)))
        return So(c) ? li(Qn(y), 0, a).join('') : y.slice(0, a)
      }
      function OC (a, c, p, y) {
        const v = c & g
        const _ = ks(a)
        function C () {
          for (
            var M = -1,
              R = arguments.length,
              U = -1,
              W = y.length,
              G = B(W + R),
              te =
                                this && this !== Ht && this instanceof C
                                  ? _
                                  : a;
            ++U < W;

          ) {
            G[U] = y[U]
          }
          for (; R--;) G[U++] = arguments[++M]
          return Tn(te, v ? p : this, G)
        }
        return C
      }
      function vb (a) {
        return function (c, p, y) {
          return (
            y &&
                            typeof y !== 'number' &&
                            un(c, p, y) &&
                            (p = y = t),
            (c = kr(c)),
            p === t ? ((p = c), (c = 0)) : (p = kr(p)),
            (y = y === t ? (c < p ? 1 : -1) : kr(y)),
            gC(c, p, y, a)
          )
        }
      }
      function dl (a) {
        return function (c, p) {
          return (
            (typeof c === 'string' && typeof p === 'string') ||
                            ((c = Hn(c)), (p = Hn(p))),
            a(c, p)
          )
        }
      }
      function wb (a, c, p, y, v, _, C, M, R, U) {
        const W = c & S
        const G = W ? C : t
        const te = W ? t : C
        const de = W ? _ : t
        const Ee = W ? t : _;
        (c |= W ? k : T), (c &= ~(W ? T : k)), c & w || (c &= ~(g | E))
        const Le = [a, c, v, de, G, Ee, te, M, R, U]
        const ve = p.apply(t, Le)
        return Ld(a) && Ib(ve, Le), (ve.placeholder = y), Db(ve, a, c)
      }
      function Md (a) {
        const c = Rt[a]
        return function (p, y) {
          if (
            ((p = Hn(p)),
            (y = y == null ? 0 : jt(Ie(y), 292)),
            y && Dg(p))
          ) {
            let v = (Xe(p) + 'e').split('e')
            const _ = c(v[0] + 'e' + (+v[1] + y))
            return (
              (v = (Xe(_) + 'e').split('e')),
              +(v[0] + 'e' + (+v[1] - y))
            )
          }
          return c(p)
        }
      }
      var RC =
                Ao && 1 / $a(new Ao([, -0]))[1] == ge
                  ? function (a) {
                    return new Ao(a)
                  }
                  : Xd
      function xb (a) {
        return function (c) {
          const p = Qt(c)
          return p == pt ? id(c) : p == V ? JT(c) : zT(c, a(c))
        }
      }
      function Cr (a, c, p, y, v, _, C, M) {
        const R = c & E
        if (!R && typeof a !== 'function') throw new Dn(i)
        let U = y ? y.length : 0
        if (
          (U || ((c &= ~(k | T)), (y = v = t)),
          (C = C === t ? C : It(Ie(C), 0)),
          (M = M === t ? M : Ie(M)),
          (U -= v ? v.length : 0),
          c & T)
        ) {
          var W = y
          var G = v
          y = v = t
        }
        const te = R ? t : Od(a)
        const de = [a, c, p, y, v, W, G, _, C, M]
        if (
          (te && qC(de, te),
          (a = de[0]),
          (c = de[1]),
          (p = de[2]),
          (y = de[3]),
          (v = de[4]),
          (M = de[9] =
                        de[9] === t ? (R ? 0 : a.length) : It(de[9] - U, 0)),
          !M && c & (S | O) && (c &= ~(S | O)),
          !c || c == g)
        ) {
          var Ee = NC(a, c, p)
        } else {
          c == S || c == O
            ? (Ee = kC(a, c, M))
            : (c == k || c == (g | k)) && !v.length
                ? (Ee = OC(a, c, p, y))
                : (Ee = ll.apply(t, de))
        }
        const Le = te ? nb : Ib
        return Db(Le(Ee, de), a, c)
      }
      function _b (a, c, p, y) {
        return a === t || (tr(a, Co[p]) && !Ze.call(y, p)) ? c : a
      }
      function Sb (a, c, p, y, v, _) {
        return (
          ft(a) &&
                        ft(c) &&
                        (_.set(c, a), il(a, c, t, Sb, _), _.delete(c)),
          a
        )
      }
      function IC (a) {
        return Is(a) ? t : a
      }
      function Tb (a, c, p, y, v, _) {
        const C = p & m
        const M = a.length
        const R = c.length
        if (M != R && !(C && R > M)) return !1
        const U = _.get(a)
        const W = _.get(c)
        if (U && W) return U == c && W == a
        let G = -1
        let te = !0
        const de = p & b ? new Ii() : t
        for (_.set(a, c), _.set(c, a); ++G < M;) {
          var Ee = a[G]
          const Le = c[G]
          if (y) {
            var ve = C
              ? y(Le, Ee, G, c, a, _)
              : y(Ee, Le, G, a, c, _)
          }
          if (ve !== t) {
            if (ve) continue
            te = !1
            break
          }
          if (de) {
            if (
              !ju(c, function ($e, Ve) {
                if (
                  !Es(de, Ve) &&
                                    (Ee === $e || v(Ee, $e, p, y, _))
                ) {
                  return de.push(Ve)
                }
              })
            ) {
              te = !1
              break
            }
          } else if (!(Ee === Le || v(Ee, Le, p, y, _))) {
            te = !1
            break
          }
        }
        return _.delete(a), _.delete(c), te
      }
      function DC (a, c, p, y, v, _, C) {
        switch (p) {
          case Ot:
            if (
              a.byteLength != c.byteLength ||
                            a.byteOffset != c.byteOffset
            ) {
              return !1
            }
            (a = a.buffer), (c = c.buffer)
          case Bt:
            return !(
              a.byteLength != c.byteLength ||
                            !_(new Ga(a), new Ga(c))
            )
          case Be:
          case _t:
          case an:
            return tr(+a, +c)
          case Re:
            return a.name == c.name && a.message == c.message
          case Pt:
          case yt:
            return a == c + ''
          case pt:
            var M = id
          case V:
            var R = y & m
            if ((M || (M = $a), a.size != c.size && !R)) {
              return !1
            }
            var U = C.get(a)
            if (U) return U == c;
            (y |= b), C.set(a, c)
            var W = Tb(M(a), M(c), y, v, _, C)
            return C.delete(a), W
          case _e:
            if (Ss) return Ss.call(a) == Ss.call(c)
        }
        return !1
      }
      function LC (a, c, p, y, v, _) {
        const C = p & m
        const M = Nd(a)
        const R = M.length
        const U = Nd(c)
        const W = U.length
        if (R != W && !C) return !1
        for (var G = R; G--;) {
          var te = M[G]
          if (!(C ? te in c : Ze.call(c, te))) return !1
        }
        const de = _.get(a)
        const Ee = _.get(c)
        if (de && Ee) return de == c && Ee == a
        let Le = !0
        _.set(a, c), _.set(c, a)
        for (var ve = C; ++G < R;) {
          te = M[G]
          const $e = a[te]
          const Ve = c[te]
          if (y) {
            var Nn = C
              ? y(Ve, $e, te, c, a, _)
              : y($e, Ve, te, a, c, _)
          }
          if (!(Nn === t ? $e === Ve || v($e, Ve, p, y, _) : Nn)) {
            Le = !1
            break
          }
          ve || (ve = te == 'constructor')
        }
        if (Le && !ve) {
          const dn = a.constructor
          const kn = c.constructor
          dn != kn &&
                        'constructor' in a &&
                        'constructor' in c &&
                        !(
                          typeof dn === 'function' &&
                            dn instanceof dn &&
                            typeof kn === 'function' &&
                            kn instanceof kn
                        ) &&
                        (Le = !1)
        }
        return _.delete(a), _.delete(c), Le
      }
      function Ar (a) {
        return Bd(Ob(a, t, $b), a + '')
      }
      function Nd (a) {
        return Vg(a, $t, Id)
      }
      function kd (a) {
        return Vg(a, En, Cb)
      }
      var Od = ja
        ? function (a) {
          return ja.get(a)
        }
        : Xd
      function fl (a) {
        for (
          var c = a.name + '',
            p = Mo[c],
            y = Ze.call(Mo, c) ? p.length : 0;
          y--;

        ) {
          const v = p[y]
          const _ = v.func
          if (_ == null || _ == a) return v.name
        }
        return c
      }
      function Ro (a) {
        const c = Ze.call(x, 'placeholder') ? x : a
        return c.placeholder
      }
      function be () {
        let a = x.iteratee || Yd
        return (
          (a = a === Yd ? Yg : a),
          arguments.length ? a(arguments[0], arguments[1]) : a
        )
      }
      function pl (a, c) {
        const p = a.__data__
        return WC(c)
          ? p[typeof c === 'string' ? 'string' : 'hash']
          : p.map
      }
      function Rd (a) {
        for (var c = $t(a), p = c.length; p--;) {
          const y = c[p]
          const v = a[y]
          c[p] = [y, v, Nb(v)]
        }
        return c
      }
      function Pi (a, c) {
        const p = GT(a, c)
        return qg(p) ? p : t
      }
      function PC (a) {
        const c = Ze.call(a, Oi)
        const p = a[Oi]
        try {
          a[Oi] = t
          var y = !0
        } catch {}
        const v = Ka.call(a)
        return y && (c ? (a[Oi] = p) : delete a[Oi]), v
      }
      var Id = sd
        ? function (a) {
          return a == null
            ? []
            : ((a = Qe(a)),
              ei(sd(a), function (c) {
                return Rg.call(a, c)
              }))
        }
        : Zd
      var Cb = sd
        ? function (a) {
          for (var c = []; a;) ti(c, Id(a)), (a = qa(a))
          return c
        }
        : Zd
      var Qt = cn;
      ((ad && Qt(new ad(new ArrayBuffer(1))) != Ot) ||
                (ws && Qt(new ws()) != pt) ||
                (ld && Qt(ld.resolve()) != Je) ||
                (Ao && Qt(new Ao()) != V) ||
                (xs && Qt(new xs()) != ut)) &&
                (Qt = function (a) {
                  const c = cn(a)
                  const p = c == Tt ? a.constructor : t
                  const y = p ? Bi(p) : ''
                  if (y) {
                    switch (y) {
                      case y1:
                        return Ot
                      case E1:
                        return pt
                      case v1:
                        return Je
                      case w1:
                        return V
                      case x1:
                        return ut
                    }
                  }
                  return c
                })
      function BC (a, c, p) {
        for (let y = -1, v = p.length; ++y < v;) {
          const _ = p[y]
          const C = _.size
          switch (_.type) {
            case 'drop':
              a += C
              break
            case 'dropRight':
              c -= C
              break
            case 'take':
              c = jt(c, a + C)
              break
            case 'takeRight':
              a = It(a, c - C)
              break
          }
        }
        return { start: a, end: c }
      }
      function FC (a) {
        const c = a.match(KS)
        return c ? c[1].split(VS) : []
      }
      function Ab (a, c, p) {
        c = ai(c, a)
        for (var y = -1, v = c.length, _ = !1; ++y < v;) {
          var C = fr(c[y])
          if (!(_ = a != null && p(a, C))) break
          a = a[C]
        }
        return _ || ++y != v
          ? _
          : ((v = a == null ? 0 : a.length),
            !!v && vl(v) && Mr(C, v) && (ke(a) || Fi(a)))
      }
      function HC (a) {
        const c = a.length
        const p = new a.constructor(c)
        return (
          c &&
                        typeof a[0] === 'string' &&
                        Ze.call(a, 'index') &&
                        ((p.index = a.index), (p.input = a.input)),
          p
        )
      }
      function Mb (a) {
        return typeof a.constructor === 'function' && !Os(a)
          ? No(qa(a))
          : {}
      }
      function $C (a, c, p) {
        const y = a.constructor
        switch (c) {
          case Bt:
            return Cd(a)
          case Be:
          case _t:
            return new y(+a)
          case Ot:
            return _C(a, p)
          case L:
          case H:
          case X:
          case se:
          case Fe:
          case rt:
          case wr:
          case F:
          case ae:
            return ub(a, p)
          case pt:
            return new y()
          case an:
          case yt:
            return new y(a)
          case Pt:
            return SC(a)
          case V:
            return new y()
          case _e:
            return TC(a)
        }
      }
      function zC (a, c) {
        const p = c.length
        if (!p) return a
        const y = p - 1
        return (
          (c[y] = (p > 1 ? '& ' : '') + c[y]),
          (c = c.join(p > 2 ? ', ' : ' ')),
          a.replace(
            WS,
                        `{
/* [wrapped with ` +
                            c +
                            `] */
`
          )
        )
      }
      function UC (a) {
        return ke(a) || Fi(a) || !!(Ig && a && a[Ig])
      }
      function Mr (a, c) {
        const p = typeof a
        return (
          (c = c ?? ye),
          !!c &&
                        (p == 'number' || (p != 'symbol' && eT.test(a))) &&
                        a > -1 &&
                        a % 1 == 0 &&
                        a < c
        )
      }
      function un (a, c, p) {
        if (!ft(p)) return !1
        const y = typeof c
        return (
          y == 'number'
            ? yn(p) && Mr(c, p.length)
            : y == 'string' && c in p
        )
          ? tr(p[c], a)
          : !1
      }
      function Dd (a, c) {
        if (ke(a)) return !1
        const p = typeof a
        return p == 'number' ||
                    p == 'symbol' ||
                    p == 'boolean' ||
                    a == null ||
                    Mn(a)
          ? !0
          : zu.test(a) || !jr.test(a) || (c != null && a in Qe(c))
      }
      function WC (a) {
        const c = typeof a
        return c == 'string' ||
                    c == 'number' ||
                    c == 'symbol' ||
                    c == 'boolean'
          ? a !== '__proto__'
          : a === null
      }
      function Ld (a) {
        const c = fl(a)
        const p = x[c]
        if (typeof p !== 'function' || !(c in Ue.prototype)) {
          return !1
        }
        if (a === p) return !0
        const y = Od(p)
        return !!y && a === y[0]
      }
      function KC (a) {
        return !!Ng && Ng in a
      }
      const VC = Ua ? Nr : jd
      function Os (a) {
        const c = a && a.constructor
        const p = (typeof c === 'function' && c.prototype) || Co
        return a === p
      }
      function Nb (a) {
        return a === a && !ft(a)
      }
      function kb (a, c) {
        return function (p) {
          return p == null
            ? !1
            : p[a] === c && (c !== t || a in Qe(p))
        }
      }
      function GC (a) {
        const c = yl(a, function (y) {
          return p.size === l && p.clear(), y
        })
        var p = c.cache
        return c
      }
      function qC (a, c) {
        const p = a[1]
        const y = c[1]
        let v = p | y
        const _ = v < (g | E | P)
        const C =
                    (y == P && p == S) ||
                    (y == P && p == I && a[7].length <= c[8]) ||
                    (y == (P | I) && c[7].length <= c[8] && p == S)
        if (!(_ || C)) return a
        y & g && ((a[2] = c[2]), (v |= p & g ? 0 : w))
        let M = c[3]
        if (M) {
          var R = a[3];
          (a[3] = R ? fb(R, M, c[4]) : M),
          (a[4] = R ? ni(a[3], u) : c[4])
        }
        return (
          (M = c[5]),
          M &&
                        ((R = a[5]),
                        (a[5] = R ? pb(R, M, c[6]) : M),
                        (a[6] = R ? ni(a[5], u) : c[6])),
          (M = c[7]),
          M && (a[7] = M),
          y & P && (a[8] = a[8] == null ? c[8] : jt(a[8], c[8])),
          a[9] == null && (a[9] = c[9]),
          (a[0] = c[0]),
          (a[1] = v),
          a
        )
      }
      function YC (a) {
        const c = []
        if (a != null) for (const p in Qe(a)) c.push(p)
        return c
      }
      function JC (a) {
        return Ka.call(a)
      }
      function Ob (a, c, p) {
        return (
          (c = It(c === t ? a.length - 1 : c, 0)),
          function () {
            for (
              var y = arguments,
                v = -1,
                _ = It(y.length - c, 0),
                C = B(_);
              ++v < _;

            ) {
              C[v] = y[c + v]
            }
            v = -1
            for (var M = B(c + 1); ++v < c;) M[v] = y[v]
            return (M[c] = p(C)), Tn(a, this, M)
          }
        )
      }
      function Rb (a, c) {
        return c.length < 2 ? a : Li(a, Bn(c, 0, -1))
      }
      function XC (a, c) {
        for (let p = a.length, y = jt(c.length, p), v = bn(a); y--;) {
          const _ = c[y]
          a[y] = Mr(_, p) ? v[_] : t
        }
        return a
      }
      function Pd (a, c) {
        if (
          !(c === 'constructor' && typeof a[c] === 'function') &&
                    c != '__proto__'
        ) {
          return a[c]
        }
      }
      var Ib = Lb(nb)
      var Rs =
                d1 ||
                function (a, c) {
                  return Ht.setTimeout(a, c)
                }
      var Bd = Lb(EC)
      function Db (a, c, p) {
        const y = c + ''
        return Bd(a, zC(y, ZC(FC(y), p)))
      }
      function Lb (a) {
        let c = 0
        let p = 0
        return function () {
          const y = m1()
          const v = fe - (y - p)
          if (((p = y), v > 0)) {
            if (++c >= Q) return arguments[0]
          } else c = 0
          return a.apply(t, arguments)
        }
      }
      function hl (a, c) {
        let p = -1
        const y = a.length
        const v = y - 1
        for (c = c === t ? y : c; ++p < c;) {
          const _ = Ed(p, v)
          const C = a[_];
          (a[_] = a[p]), (a[p] = C)
        }
        return (a.length = c), a
      }
      var Pb = GC(function (a) {
        const c = []
        return (
          a.charCodeAt(0) === 46 && c.push(''),
          a.replace(ys, function (p, y, v, _) {
            c.push(v ? _.replace(YS, '$1') : y || p)
          }),
          c
        )
      })
      function fr (a) {
        if (typeof a === 'string' || Mn(a)) return a
        const c = a + ''
        return c == '0' && 1 / a == -ge ? '-0' : c
      }
      function Bi (a) {
        if (a != null) {
          try {
            return Wa.call(a)
          } catch {}
          try {
            return a + ''
          } catch {}
        }
        return ''
      }
      function ZC (a, c) {
        return (
          In(xe, function (p) {
            const y = '_.' + p[0]
            c & p[1] && !Fa(a, y) && a.push(y)
          }),
          a.sort()
        )
      }
      function Bb (a) {
        if (a instanceof Ue) return a.clone()
        const c = new Ln(a.__wrapped__, a.__chain__)
        return (
          (c.__actions__ = bn(a.__actions__)),
          (c.__index__ = a.__index__),
          (c.__values__ = a.__values__),
          c
        )
      }
      function jC (a, c, p) {
        (p ? un(a, c, p) : c === t) ? (c = 1) : (c = It(Ie(c), 0))
        const y = a == null ? 0 : a.length
        if (!y || c < 1) return []
        for (var v = 0, _ = 0, C = B(Xa(y / c)); v < y;) {
          C[_++] = Bn(a, v, (v += c))
        }
        return C
      }
      function QC (a) {
        for (
          var c = -1, p = a == null ? 0 : a.length, y = 0, v = [];
          ++c < p;

        ) {
          const _ = a[c]
          _ && (v[y++] = _)
        }
        return v
      }
      function eA () {
        const a = arguments.length
        if (!a) return []
        for (var c = B(a - 1), p = arguments[0], y = a; y--;) {
          c[y - 1] = arguments[y]
        }
        return ti(ke(p) ? bn(p) : [p], Vt(c, 1))
      }
      const tA = He(function (a, c) {
        return Et(a) ? Cs(a, Vt(c, 1, Et, !0)) : []
      })
      const nA = He(function (a, c) {
        let p = Fn(c)
        return (
          Et(p) && (p = t),
          Et(a) ? Cs(a, Vt(c, 1, Et, !0), be(p, 2)) : []
        )
      })
      const rA = He(function (a, c) {
        let p = Fn(c)
        return (
          Et(p) && (p = t), Et(a) ? Cs(a, Vt(c, 1, Et, !0), t, p) : []
        )
      })
      function iA (a, c, p) {
        const y = a == null ? 0 : a.length
        return y
          ? ((c = p || c === t ? 1 : Ie(c)), Bn(a, c < 0 ? 0 : c, y))
          : []
      }
      function oA (a, c, p) {
        const y = a == null ? 0 : a.length
        return y
          ? ((c = p || c === t ? 1 : Ie(c)),
            (c = y - c),
            Bn(a, 0, c < 0 ? 0 : c))
          : []
      }
      function sA (a, c) {
        return a && a.length ? sl(a, be(c, 3), !0, !0) : []
      }
      function aA (a, c) {
        return a && a.length ? sl(a, be(c, 3), !0) : []
      }
      function lA (a, c, p, y) {
        const v = a == null ? 0 : a.length
        return v
          ? (p &&
                          typeof p !== 'number' &&
                          un(a, c, p) &&
                          ((p = 0), (y = v)),
            eC(a, c, p, y))
          : []
      }
      function Fb (a, c, p) {
        const y = a == null ? 0 : a.length
        if (!y) return -1
        let v = p == null ? 0 : Ie(p)
        return v < 0 && (v = It(y + v, 0)), Ha(a, be(c, 3), v)
      }
      function Hb (a, c, p) {
        const y = a == null ? 0 : a.length
        if (!y) return -1
        let v = y - 1
        return (
          p !== t &&
                        ((v = Ie(p)),
                        (v = p < 0 ? It(y + v, 0) : jt(v, y - 1))),
          Ha(a, be(c, 3), v, !0)
        )
      }
      function $b (a) {
        const c = a == null ? 0 : a.length
        return c ? Vt(a, 1) : []
      }
      function cA (a) {
        const c = a == null ? 0 : a.length
        return c ? Vt(a, ge) : []
      }
      function uA (a, c) {
        const p = a == null ? 0 : a.length
        return p ? ((c = c === t ? 1 : Ie(c)), Vt(a, c)) : []
      }
      function dA (a) {
        for (
          var c = -1, p = a == null ? 0 : a.length, y = {};
          ++c < p;

        ) {
          const v = a[c]
          y[v[0]] = v[1]
        }
        return y
      }
      function zb (a) {
        return a && a.length ? a[0] : t
      }
      function fA (a, c, p) {
        const y = a == null ? 0 : a.length
        if (!y) return -1
        let v = p == null ? 0 : Ie(p)
        return v < 0 && (v = It(y + v, 0)), _o(a, c, v)
      }
      function pA (a) {
        const c = a == null ? 0 : a.length
        return c ? Bn(a, 0, -1) : []
      }
      const hA = He(function (a) {
        const c = lt(a, Sd)
        return c.length && c[0] === a[0] ? hd(c) : []
      })
      const mA = He(function (a) {
        let c = Fn(a)
        const p = lt(a, Sd)
        return (
          c === Fn(p) ? (c = t) : p.pop(),
          p.length && p[0] === a[0] ? hd(p, be(c, 2)) : []
        )
      })
      const gA = He(function (a) {
        let c = Fn(a)
        const p = lt(a, Sd)
        return (
          (c = typeof c === 'function' ? c : t),
          c && p.pop(),
          p.length && p[0] === a[0] ? hd(p, t, c) : []
        )
      })
      function bA (a, c) {
        return a == null ? '' : p1.call(a, c)
      }
      function Fn (a) {
        const c = a == null ? 0 : a.length
        return c ? a[c - 1] : t
      }
      function yA (a, c, p) {
        const y = a == null ? 0 : a.length
        if (!y) return -1
        let v = y
        return (
          p !== t &&
                        ((v = Ie(p)),
                        (v = v < 0 ? It(y + v, 0) : jt(v, y - 1))),
          c === c ? ZT(a, c, v) : Ha(a, wg, v, !0)
        )
      }
      function EA (a, c) {
        return a && a.length ? jg(a, Ie(c)) : t
      }
      const vA = He(Ub)
      function Ub (a, c) {
        return a && a.length && c && c.length ? yd(a, c) : a
      }
      function wA (a, c, p) {
        return a && a.length && c && c.length ? yd(a, c, be(p, 2)) : a
      }
      function xA (a, c, p) {
        return a && a.length && c && c.length ? yd(a, c, t, p) : a
      }
      const _A = Ar(function (a, c) {
        const p = a == null ? 0 : a.length
        const y = ud(a, c)
        return (
          tb(
            a,
            lt(c, function (v) {
              return Mr(v, p) ? +v : v
            }).sort(db)
          ),
          y
        )
      })
      function SA (a, c) {
        const p = []
        if (!(a && a.length)) return p
        let y = -1
        const v = []
        const _ = a.length
        for (c = be(c, 3); ++y < _;) {
          const C = a[y]
          c(C, y, a) && (p.push(C), v.push(y))
        }
        return tb(a, v), p
      }
      function Fd (a) {
        return a == null ? a : b1.call(a)
      }
      function TA (a, c, p) {
        const y = a == null ? 0 : a.length
        return y
          ? (p && typeof p !== 'number' && un(a, c, p)
              ? ((c = 0), (p = y))
              : ((c = c == null ? 0 : Ie(c)),
                (p = p === t ? y : Ie(p))),
            Bn(a, c, p))
          : []
      }
      function CA (a, c) {
        return ol(a, c)
      }
      function AA (a, c, p) {
        return wd(a, c, be(p, 2))
      }
      function MA (a, c) {
        const p = a == null ? 0 : a.length
        if (p) {
          const y = ol(a, c)
          if (y < p && tr(a[y], c)) return y
        }
        return -1
      }
      function NA (a, c) {
        return ol(a, c, !0)
      }
      function kA (a, c, p) {
        return wd(a, c, be(p, 2), !0)
      }
      function OA (a, c) {
        const p = a == null ? 0 : a.length
        if (p) {
          const y = ol(a, c, !0) - 1
          if (tr(a[y], c)) return y
        }
        return -1
      }
      function RA (a) {
        return a && a.length ? rb(a) : []
      }
      function IA (a, c) {
        return a && a.length ? rb(a, be(c, 2)) : []
      }
      function DA (a) {
        const c = a == null ? 0 : a.length
        return c ? Bn(a, 1, c) : []
      }
      function LA (a, c, p) {
        return a && a.length
          ? ((c = p || c === t ? 1 : Ie(c)), Bn(a, 0, c < 0 ? 0 : c))
          : []
      }
      function PA (a, c, p) {
        const y = a == null ? 0 : a.length
        return y
          ? ((c = p || c === t ? 1 : Ie(c)),
            (c = y - c),
            Bn(a, c < 0 ? 0 : c, y))
          : []
      }
      function BA (a, c) {
        return a && a.length ? sl(a, be(c, 3), !1, !0) : []
      }
      function FA (a, c) {
        return a && a.length ? sl(a, be(c, 3)) : []
      }
      const HA = He(function (a) {
        return si(Vt(a, 1, Et, !0))
      })
      const $A = He(function (a) {
        let c = Fn(a)
        return Et(c) && (c = t), si(Vt(a, 1, Et, !0), be(c, 2))
      })
      const zA = He(function (a) {
        let c = Fn(a)
        return (
          (c = typeof c === 'function' ? c : t),
          si(Vt(a, 1, Et, !0), t, c)
        )
      })
      function UA (a) {
        return a && a.length ? si(a) : []
      }
      function WA (a, c) {
        return a && a.length ? si(a, be(c, 2)) : []
      }
      function KA (a, c) {
        return (
          (c = typeof c === 'function' ? c : t),
          a && a.length ? si(a, t, c) : []
        )
      }
      function Hd (a) {
        if (!(a && a.length)) return []
        let c = 0
        return (
          (a = ei(a, function (p) {
            if (Et(p)) return (c = It(p.length, c)), !0
          })),
          nd(c, function (p) {
            return lt(a, Qu(p))
          })
        )
      }
      function Wb (a, c) {
        if (!(a && a.length)) return []
        const p = Hd(a)
        return c == null
          ? p
          : lt(p, function (y) {
            return Tn(c, t, y)
          })
      }
      const VA = He(function (a, c) {
        return Et(a) ? Cs(a, c) : []
      })
      const GA = He(function (a) {
        return _d(ei(a, Et))
      })
      const qA = He(function (a) {
        let c = Fn(a)
        return Et(c) && (c = t), _d(ei(a, Et), be(c, 2))
      })
      const YA = He(function (a) {
        let c = Fn(a)
        return (
          (c = typeof c === 'function' ? c : t), _d(ei(a, Et), t, c)
        )
      })
      const JA = He(Hd)
      function XA (a, c) {
        return ab(a || [], c || [], Ts)
      }
      function ZA (a, c) {
        return ab(a || [], c || [], Ns)
      }
      const jA = He(function (a) {
        const c = a.length
        let p = c > 1 ? a[c - 1] : t
        return (
          (p = typeof p === 'function' ? (a.pop(), p) : t), Wb(a, p)
        )
      })
      function Kb (a) {
        const c = x(a)
        return (c.__chain__ = !0), c
      }
      function QA (a, c) {
        return c(a), a
      }
      function ml (a, c) {
        return c(a)
      }
      const eM = Ar(function (a) {
        const c = a.length
        const p = c ? a[0] : 0
        let y = this.__wrapped__
        const v = function (_) {
          return ud(_, a)
        }
        return c > 1 ||
                    this.__actions__.length ||
                    !(y instanceof Ue) ||
                    !Mr(p)
          ? this.thru(v)
          : ((y = y.slice(p, +p + (c ? 1 : 0))),
            y.__actions__.push({
              func: ml,
              args: [v],
              thisArg: t
            }),
            new Ln(y, this.__chain__).thru(function (_) {
              return c && !_.length && _.push(t), _
            }))
      })
      function tM () {
        return Kb(this)
      }
      function nM () {
        return new Ln(this.value(), this.__chain__)
      }
      function rM () {
        this.__values__ === t && (this.__values__ = iy(this.value()))
        const a = this.__index__ >= this.__values__.length
        const c = a ? t : this.__values__[this.__index__++]
        return { done: a, value: c }
      }
      function iM () {
        return this
      }
      function oM (a) {
        for (var c, p = this; p instanceof el;) {
          const y = Bb(p);
          (y.__index__ = 0),
          (y.__values__ = t),
          c ? (v.__wrapped__ = y) : (c = y)
          var v = y
          p = p.__wrapped__
        }
        return (v.__wrapped__ = a), c
      }
      function sM () {
        const a = this.__wrapped__
        if (a instanceof Ue) {
          let c = a
          return (
            this.__actions__.length && (c = new Ue(this)),
            (c = c.reverse()),
            c.__actions__.push({
              func: ml,
              args: [Fd],
              thisArg: t
            }),
            new Ln(c, this.__chain__)
          )
        }
        return this.thru(Fd)
      }
      function aM () {
        return sb(this.__wrapped__, this.__actions__)
      }
      const lM = al(function (a, c, p) {
        Ze.call(a, p) ? ++a[p] : Tr(a, p, 1)
      })
      function cM (a, c, p) {
        const y = ke(a) ? Eg : Q1
        return p && un(a, c, p) && (c = t), y(a, be(c, 3))
      }
      function uM (a, c) {
        const p = ke(a) ? ei : Wg
        return p(a, be(c, 3))
      }
      const dM = bb(Fb)
      const fM = bb(Hb)
      function pM (a, c) {
        return Vt(gl(a, c), 1)
      }
      function hM (a, c) {
        return Vt(gl(a, c), ge)
      }
      function mM (a, c, p) {
        return (p = p === t ? 1 : Ie(p)), Vt(gl(a, c), p)
      }
      function Vb (a, c) {
        const p = ke(a) ? In : oi
        return p(a, be(c, 3))
      }
      function Gb (a, c) {
        const p = ke(a) ? DT : Ug
        return p(a, be(c, 3))
      }
      const gM = al(function (a, c, p) {
        Ze.call(a, p) ? a[p].push(c) : Tr(a, p, [c])
      })
      function bM (a, c, p, y) {
        (a = yn(a) ? a : Do(a)), (p = p && !y ? Ie(p) : 0)
        const v = a.length
        return (
          p < 0 && (p = It(v + p, 0)),
          wl(a)
            ? p <= v && a.indexOf(c, p) > -1
            : !!v && _o(a, c, p) > -1
        )
      }
      const yM = He(function (a, c, p) {
        let y = -1
        const v = typeof c === 'function'
        const _ = yn(a) ? B(a.length) : []
        return (
          oi(a, function (C) {
            _[++y] = v ? Tn(c, C, p) : As(C, c, p)
          }),
          _
        )
      })
      const EM = al(function (a, c, p) {
        Tr(a, p, c)
      })
      function gl (a, c) {
        const p = ke(a) ? lt : Jg
        return p(a, be(c, 3))
      }
      function vM (a, c, p, y) {
        return a == null
          ? []
          : (ke(c) || (c = c == null ? [] : [c]),
            (p = y ? t : p),
            ke(p) || (p = p == null ? [] : [p]),
            Qg(a, c, p))
      }
      const wM = al(
        function (a, c, p) {
          a[p ? 0 : 1].push(c)
        },
        function () {
          return [[], []]
        }
      )
      function xM (a, c, p) {
        const y = ke(a) ? Zu : _g
        const v = arguments.length < 3
        return y(a, be(c, 4), p, v, oi)
      }
      function _M (a, c, p) {
        const y = ke(a) ? LT : _g
        const v = arguments.length < 3
        return y(a, be(c, 4), p, v, Ug)
      }
      function SM (a, c) {
        const p = ke(a) ? ei : Wg
        return p(a, El(be(c, 3)))
      }
      function TM (a) {
        const c = ke(a) ? Fg : bC
        return c(a)
      }
      function CM (a, c, p) {
        (p ? un(a, c, p) : c === t) ? (c = 1) : (c = Ie(c))
        const y = ke(a) ? Y1 : yC
        return y(a, c)
      }
      function AM (a) {
        const c = ke(a) ? J1 : vC
        return c(a)
      }
      function MM (a) {
        if (a == null) return 0
        if (yn(a)) return wl(a) ? To(a) : a.length
        const c = Qt(a)
        return c == pt || c == V ? a.size : gd(a).length
      }
      function NM (a, c, p) {
        const y = ke(a) ? ju : wC
        return p && un(a, c, p) && (c = t), y(a, be(c, 3))
      }
      const kM = He(function (a, c) {
        if (a == null) return []
        const p = c.length
        return (
          p > 1 && un(a, c[0], c[1])
            ? (c = [])
            : p > 2 && un(c[0], c[1], c[2]) && (c = [c[0]]),
          Qg(a, Vt(c, 1), [])
        )
      })
      const bl =
                u1 ||
                function () {
                  return Ht.Date.now()
                }
      function OM (a, c) {
        if (typeof c !== 'function') throw new Dn(i)
        return (
          (a = Ie(a)),
          function () {
            if (--a < 1) return c.apply(this, arguments)
          }
        )
      }
      function qb (a, c, p) {
        return (
          (c = p ? t : c),
          (c = a && c == null ? a.length : c),
          Cr(a, P, t, t, t, t, c)
        )
      }
      function Yb (a, c) {
        let p
        if (typeof c !== 'function') throw new Dn(i)
        return (
          (a = Ie(a)),
          function () {
            return (
              --a > 0 && (p = c.apply(this, arguments)),
              a <= 1 && (c = t),
              p
            )
          }
        )
      }
      var $d = He(function (a, c, p) {
        let y = g
        if (p.length) {
          var v = ni(p, Ro($d))
          y |= k
        }
        return Cr(a, y, c, p, v)
      })
      var Jb = He(function (a, c, p) {
        let y = g | E
        if (p.length) {
          var v = ni(p, Ro(Jb))
          y |= k
        }
        return Cr(c, y, a, p, v)
      })
      function Xb (a, c, p) {
        c = p ? t : c
        const y = Cr(a, S, t, t, t, t, t, c)
        return (y.placeholder = Xb.placeholder), y
      }
      function Zb (a, c, p) {
        c = p ? t : c
        const y = Cr(a, O, t, t, t, t, t, c)
        return (y.placeholder = Zb.placeholder), y
      }
      function jb (a, c, p) {
        let y
        let v
        let _
        let C
        let M
        let R
        let U = 0
        let W = !1
        let G = !1
        let te = !0
        if (typeof a !== 'function') throw new Dn(i);
        (c = Hn(c) || 0),
        ft(p) &&
                        ((W = !!p.leading),
                        (G = 'maxWait' in p),
                        (_ = G ? It(Hn(p.maxWait) || 0, c) : _),
                        (te = 'trailing' in p ? !!p.trailing : te))
        function de (vt) {
          const nr = y
          const Or = v
          return (y = v = t), (U = vt), (C = a.apply(Or, nr)), C
        }
        function Ee (vt) {
          return (U = vt), (M = Rs($e, c)), W ? de(vt) : C
        }
        function Le (vt) {
          const nr = vt - R
          const Or = vt - U
          const by = c - nr
          return G ? jt(by, _ - Or) : by
        }
        function ve (vt) {
          const nr = vt - R
          const Or = vt - U
          return R === t || nr >= c || nr < 0 || (G && Or >= _)
        }
        function $e () {
          const vt = bl()
          if (ve(vt)) return Ve(vt)
          M = Rs($e, Le(vt))
        }
        function Ve (vt) {
          return (M = t), te && y ? de(vt) : ((y = v = t), C)
        }
        function Nn () {
          M !== t && lb(M), (U = 0), (y = R = v = M = t)
        }
        function dn () {
          return M === t ? C : Ve(bl())
        }
        function kn () {
          const vt = bl()
          const nr = ve(vt)
          if (((y = arguments), (v = this), (R = vt), nr)) {
            if (M === t) return Ee(R)
            if (G) return lb(M), (M = Rs($e, c)), de(R)
          }
          return M === t && (M = Rs($e, c)), C
        }
        return (kn.cancel = Nn), (kn.flush = dn), kn
      }
      const RM = He(function (a, c) {
        return zg(a, 1, c)
      })
      const IM = He(function (a, c, p) {
        return zg(a, Hn(c) || 0, p)
      })
      function DM (a) {
        return Cr(a, Y)
      }
      function yl (a, c) {
        if (
          typeof a !== 'function' ||
                    (c != null && typeof c !== 'function')
        ) {
          throw new Dn(i)
        }
        const p = function () {
          const y = arguments
          const v = c ? c.apply(this, y) : y[0]
          const _ = p.cache
          if (_.has(v)) return _.get(v)
          const C = a.apply(this, y)
          return (p.cache = _.set(v, C) || _), C
        }
        return (p.cache = new (yl.Cache || Sr)()), p
      }
      yl.Cache = Sr
      function El (a) {
        if (typeof a !== 'function') throw new Dn(i)
        return function () {
          const c = arguments
          switch (c.length) {
            case 0:
              return !a.call(this)
            case 1:
              return !a.call(this, c[0])
            case 2:
              return !a.call(this, c[0], c[1])
            case 3:
              return !a.call(this, c[0], c[1], c[2])
          }
          return !a.apply(this, c)
        }
      }
      function LM (a) {
        return Yb(2, a)
      }
      const PM = xC(function (a, c) {
        c =
                    c.length == 1 && ke(c[0])
                      ? lt(c[0], Cn(be()))
                      : lt(Vt(c, 1), Cn(be()))
        const p = c.length
        return He(function (y) {
          for (let v = -1, _ = jt(y.length, p); ++v < _;) {
            y[v] = c[v].call(this, y[v])
          }
          return Tn(a, this, y)
        })
      })
      var zd = He(function (a, c) {
        const p = ni(c, Ro(zd))
        return Cr(a, k, t, c, p)
      })
      var Qb = He(function (a, c) {
        const p = ni(c, Ro(Qb))
        return Cr(a, T, t, c, p)
      })
      const BM = Ar(function (a, c) {
        return Cr(a, I, t, t, t, c)
      })
      function FM (a, c) {
        if (typeof a !== 'function') throw new Dn(i)
        return (c = c === t ? c : Ie(c)), He(a, c)
      }
      function HM (a, c) {
        if (typeof a !== 'function') throw new Dn(i)
        return (
          (c = c == null ? 0 : It(Ie(c), 0)),
          He(function (p) {
            const y = p[c]
            const v = li(p, 0, c)
            return y && ti(v, y), Tn(a, this, v)
          })
        )
      }
      function $M (a, c, p) {
        let y = !0
        let v = !0
        if (typeof a !== 'function') throw new Dn(i)
        return (
          ft(p) &&
                        ((y = 'leading' in p ? !!p.leading : y),
                        (v = 'trailing' in p ? !!p.trailing : v)),
          jb(a, c, { leading: y, maxWait: c, trailing: v })
        )
      }
      function zM (a) {
        return qb(a, 1)
      }
      function UM (a, c) {
        return zd(Td(c), a)
      }
      function WM () {
        if (!arguments.length) return []
        const a = arguments[0]
        return ke(a) ? a : [a]
      }
      function KM (a) {
        return Pn(a, h)
      }
      function VM (a, c) {
        return (c = typeof c === 'function' ? c : t), Pn(a, h, c)
      }
      function GM (a) {
        return Pn(a, d | h)
      }
      function qM (a, c) {
        return (c = typeof c === 'function' ? c : t), Pn(a, d | h, c)
      }
      function YM (a, c) {
        return c == null || $g(a, c, $t(c))
      }
      function tr (a, c) {
        return a === c || (a !== a && c !== c)
      }
      const JM = dl(pd)
      const XM = dl(function (a, c) {
        return a >= c
      })
      var Fi = Gg(
        (function () {
          return arguments
        })()
      )
        ? Gg
        : function (a) {
          return (
            ht(a) && Ze.call(a, 'callee') && !Rg.call(a, 'callee')
          )
        }
      var ke = B.isArray
      const ZM = pg ? Cn(pg) : oC
      function yn (a) {
        return a != null && vl(a.length) && !Nr(a)
      }
      function Et (a) {
        return ht(a) && yn(a)
      }
      function jM (a) {
        return a === !0 || a === !1 || (ht(a) && cn(a) == Be)
      }
      var ci = f1 || jd
      const QM = hg ? Cn(hg) : sC
      function eN (a) {
        return ht(a) && a.nodeType === 1 && !Is(a)
      }
      function tN (a) {
        if (a == null) return !0
        if (
          yn(a) &&
                    (ke(a) ||
                        typeof a === 'string' ||
                        typeof a.splice === 'function' ||
                        ci(a) ||
                        Io(a) ||
                        Fi(a))
        ) {
          return !a.length
        }
        const c = Qt(a)
        if (c == pt || c == V) return !a.size
        if (Os(a)) return !gd(a).length
        for (const p in a) if (Ze.call(a, p)) return !1
        return !0
      }
      function nN (a, c) {
        return Ms(a, c)
      }
      function rN (a, c, p) {
        p = typeof p === 'function' ? p : t
        const y = p ? p(a, c) : t
        return y === t ? Ms(a, c, t, p) : !!y
      }
      function Ud (a) {
        if (!ht(a)) return !1
        const c = cn(a)
        return (
          c == Re ||
                    c == kt ||
                    (typeof a.message === 'string' &&
                        typeof a.name === 'string' &&
                        !Is(a))
        )
      }
      function iN (a) {
        return typeof a === 'number' && Dg(a)
      }
      function Nr (a) {
        if (!ft(a)) return !1
        const c = cn(a)
        return c == St || c == Xt || c == Ne || c == jn
      }
      function ey (a) {
        return typeof a === 'number' && a == Ie(a)
      }
      function vl (a) {
        return typeof a === 'number' && a > -1 && a % 1 == 0 && a <= ye
      }
      function ft (a) {
        const c = typeof a
        return a != null && (c == 'object' || c == 'function')
      }
      function ht (a) {
        return a != null && typeof a === 'object'
      }
      var ty = mg ? Cn(mg) : lC
      function oN (a, c) {
        return a === c || md(a, c, Rd(c))
      }
      function sN (a, c, p) {
        return (
          (p = typeof p === 'function' ? p : t), md(a, c, Rd(c), p)
        )
      }
      function aN (a) {
        return ny(a) && a != +a
      }
      function lN (a) {
        if (VC(a)) throw new Me(r)
        return qg(a)
      }
      function cN (a) {
        return a === null
      }
      function uN (a) {
        return a == null
      }
      function ny (a) {
        return typeof a === 'number' || (ht(a) && cn(a) == an)
      }
      function Is (a) {
        if (!ht(a) || cn(a) != Tt) return !1
        const c = qa(a)
        if (c === null) return !0
        const p = Ze.call(c, 'constructor') && c.constructor
        return (
          typeof p === 'function' &&
                    p instanceof p &&
                    Wa.call(p) == s1
        )
      }
      const Wd = gg ? Cn(gg) : cC
      function dN (a) {
        return ey(a) && a >= -ye && a <= ye
      }
      var ry = bg ? Cn(bg) : uC
      function wl (a) {
        return (
          typeof a === 'string' || (!ke(a) && ht(a) && cn(a) == yt)
        )
      }
      function Mn (a) {
        return typeof a === 'symbol' || (ht(a) && cn(a) == _e)
      }
      var Io = yg ? Cn(yg) : dC
      function fN (a) {
        return a === t
      }
      function pN (a) {
        return ht(a) && Qt(a) == ut
      }
      function hN (a) {
        return ht(a) && cn(a) == dt
      }
      const mN = dl(bd)
      const gN = dl(function (a, c) {
        return a <= c
      })
      function iy (a) {
        if (!a) return []
        if (yn(a)) return wl(a) ? Qn(a) : bn(a)
        if (vs && a[vs]) return YT(a[vs]())
        const c = Qt(a)
        const p = c == pt ? id : c == V ? $a : Do
        return p(a)
      }
      function kr (a) {
        if (!a) return a === 0 ? a : 0
        if (((a = Hn(a)), a === ge || a === -ge)) {
          const c = a < 0 ? -1 : 1
          return c * A
        }
        return a === a ? a : 0
      }
      function Ie (a) {
        const c = kr(a)
        const p = c % 1
        return c === c ? (p ? c - p : c) : 0
      }
      function oy (a) {
        return a ? Di(Ie(a), 0, z) : 0
      }
      function Hn (a) {
        if (typeof a === 'number') return a
        if (Mn(a)) return D
        if (ft(a)) {
          const c = typeof a.valueOf === 'function' ? a.valueOf() : a
          a = ft(c) ? c + '' : c
        }
        if (typeof a !== 'string') return a === 0 ? a : +a
        a = Sg(a)
        const p = ZS.test(a)
        return p || QS.test(a)
          ? OT(a.slice(2), p ? 2 : 8)
          : XS.test(a)
            ? D
            : +a
      }
      function sy (a) {
        return dr(a, En(a))
      }
      function bN (a) {
        return a ? Di(Ie(a), -ye, ye) : a === 0 ? a : 0
      }
      function Xe (a) {
        return a == null ? '' : An(a)
      }
      const yN = ko(function (a, c) {
        if (Os(c) || yn(c)) {
          dr(c, $t(c), a)
          return
        }
        for (const p in c) Ze.call(c, p) && Ts(a, p, c[p])
      })
      const ay = ko(function (a, c) {
        dr(c, En(c), a)
      })
      const xl = ko(function (a, c, p, y) {
        dr(c, En(c), a, y)
      })
      const EN = ko(function (a, c, p, y) {
        dr(c, $t(c), a, y)
      })
      const vN = Ar(ud)
      function wN (a, c) {
        const p = No(a)
        return c == null ? p : Hg(p, c)
      }
      const xN = He(function (a, c) {
        a = Qe(a)
        let p = -1
        let y = c.length
        const v = y > 2 ? c[2] : t
        for (v && un(c[0], c[1], v) && (y = 1); ++p < y;) {
          for (
            let _ = c[p], C = En(_), M = -1, R = C.length;
            ++M < R;

          ) {
            const U = C[M]
            const W = a[U];
            (W === t || (tr(W, Co[U]) && !Ze.call(a, U))) &&
                            (a[U] = _[U])
          }
        }
        return a
      })
      const _N = He(function (a) {
        return a.push(t, Sb), Tn(ly, t, a)
      })
      function SN (a, c) {
        return vg(a, be(c, 3), ur)
      }
      function TN (a, c) {
        return vg(a, be(c, 3), fd)
      }
      function CN (a, c) {
        return a == null ? a : dd(a, be(c, 3), En)
      }
      function AN (a, c) {
        return a == null ? a : Kg(a, be(c, 3), En)
      }
      function MN (a, c) {
        return a && ur(a, be(c, 3))
      }
      function NN (a, c) {
        return a && fd(a, be(c, 3))
      }
      function kN (a) {
        return a == null ? [] : rl(a, $t(a))
      }
      function ON (a) {
        return a == null ? [] : rl(a, En(a))
      }
      function Kd (a, c, p) {
        const y = a == null ? t : Li(a, c)
        return y === t ? p : y
      }
      function RN (a, c) {
        return a != null && Ab(a, c, tC)
      }
      function Vd (a, c) {
        return a != null && Ab(a, c, nC)
      }
      const IN = Eb(function (a, c, p) {
        c != null &&
                    typeof c.toString !== 'function' &&
                    (c = Ka.call(c)),
        (a[c] = p)
      }, qd(vn))
      const DN = Eb(function (a, c, p) {
        c != null &&
                    typeof c.toString !== 'function' &&
                    (c = Ka.call(c)),
        Ze.call(a, c) ? a[c].push(p) : (a[c] = [p])
      }, be)
      const LN = He(As)
      function $t (a) {
        return yn(a) ? Bg(a) : gd(a)
      }
      function En (a) {
        return yn(a) ? Bg(a, !0) : fC(a)
      }
      function PN (a, c) {
        const p = {}
        return (
          (c = be(c, 3)),
          ur(a, function (y, v, _) {
            Tr(p, c(y, v, _), y)
          }),
          p
        )
      }
      function BN (a, c) {
        const p = {}
        return (
          (c = be(c, 3)),
          ur(a, function (y, v, _) {
            Tr(p, v, c(y, v, _))
          }),
          p
        )
      }
      const FN = ko(function (a, c, p) {
        il(a, c, p)
      })
      var ly = ko(function (a, c, p, y) {
        il(a, c, p, y)
      })
      const HN = Ar(function (a, c) {
        let p = {}
        if (a == null) return p
        let y = !1;
        (c = lt(c, function (_) {
          return (_ = ai(_, a)), y || (y = _.length > 1), _
        })),
        dr(a, kd(a), p),
        y && (p = Pn(p, d | f | h, IC))
        for (let v = c.length; v--;) xd(p, c[v])
        return p
      })
      function $N (a, c) {
        return cy(a, El(be(c)))
      }
      const zN = Ar(function (a, c) {
        return a == null ? {} : hC(a, c)
      })
      function cy (a, c) {
        if (a == null) return {}
        const p = lt(kd(a), function (y) {
          return [y]
        })
        return (
          (c = be(c)),
          eb(a, p, function (y, v) {
            return c(y, v[0])
          })
        )
      }
      function UN (a, c, p) {
        c = ai(c, a)
        let y = -1
        let v = c.length
        for (v || ((v = 1), (a = t)); ++y < v;) {
          let _ = a == null ? t : a[fr(c[y])]
          _ === t && ((y = v), (_ = p)), (a = Nr(_) ? _.call(a) : _)
        }
        return a
      }
      function WN (a, c, p) {
        return a == null ? a : Ns(a, c, p)
      }
      function KN (a, c, p, y) {
        return (
          (y = typeof y === 'function' ? y : t),
          a == null ? a : Ns(a, c, p, y)
        )
      }
      const uy = xb($t)
      const dy = xb(En)
      function VN (a, c, p) {
        const y = ke(a)
        const v = y || ci(a) || Io(a)
        if (((c = be(c, 4)), p == null)) {
          const _ = a && a.constructor
          v
            ? (p = y ? new _() : [])
            : ft(a)
              ? (p = Nr(_) ? No(qa(a)) : {})
              : (p = {})
        }
        return (
          (v ? In : ur)(a, function (C, M, R) {
            return c(p, C, M, R)
          }),
          p
        )
      }
      function GN (a, c) {
        return a == null ? !0 : xd(a, c)
      }
      function qN (a, c, p) {
        return a == null ? a : ob(a, c, Td(p))
      }
      function YN (a, c, p, y) {
        return (
          (y = typeof y === 'function' ? y : t),
          a == null ? a : ob(a, c, Td(p), y)
        )
      }
      function Do (a) {
        return a == null ? [] : rd(a, $t(a))
      }
      function JN (a) {
        return a == null ? [] : rd(a, En(a))
      }
      function XN (a, c, p) {
        return (
          p === t && ((p = c), (c = t)),
          p !== t && ((p = Hn(p)), (p = p === p ? p : 0)),
          c !== t && ((c = Hn(c)), (c = c === c ? c : 0)),
          Di(Hn(a), c, p)
        )
      }
      function ZN (a, c, p) {
        return (
          (c = kr(c)),
          p === t ? ((p = c), (c = 0)) : (p = kr(p)),
          (a = Hn(a)),
          rC(a, c, p)
        )
      }
      function jN (a, c, p) {
        if (
          (p && typeof p !== 'boolean' && un(a, c, p) && (c = p = t),
          p === t &&
                        (typeof c === 'boolean'
                          ? ((p = c), (c = t))
                          : typeof a === 'boolean' && ((p = a), (a = t))),
          a === t && c === t
            ? ((a = 0), (c = 1))
            : ((a = kr(a)),
              c === t ? ((c = a), (a = 0)) : (c = kr(c))),
          a > c)
        ) {
          const y = a;
          (a = c), (c = y)
        }
        if (p || a % 1 || c % 1) {
          const v = Lg()
          return jt(
            a + v * (c - a + kT('1e-' + ((v + '').length - 1))),
            c
          )
        }
        return Ed(a, c)
      }
      const QN = Oo(function (a, c, p) {
        return (c = c.toLowerCase()), a + (p ? fy(c) : c)
      })
      function fy (a) {
        return Gd(Xe(a).toLowerCase())
      }
      function py (a) {
        return (a = Xe(a)), a && a.replace(tT, WT).replace(vT, '')
      }
      function ek (a, c, p) {
        (a = Xe(a)), (c = An(c))
        const y = a.length
        p = p === t ? y : Di(Ie(p), 0, y)
        const v = p
        return (p -= c.length), p >= 0 && a.slice(p, v) == c
      }
      function tk (a) {
        return (a = Xe(a)), a && Da.test(a) ? a.replace(ln, KT) : a
      }
      function nk (a) {
        return (a = Xe(a)), a && zS.test(a) ? a.replace(Qr, '\\$&') : a
      }
      const rk = Oo(function (a, c, p) {
        return a + (p ? '-' : '') + c.toLowerCase()
      })
      const ik = Oo(function (a, c, p) {
        return a + (p ? ' ' : '') + c.toLowerCase()
      })
      const ok = gb('toLowerCase')
      function sk (a, c, p) {
        (a = Xe(a)), (c = Ie(c))
        const y = c ? To(a) : 0
        if (!c || y >= c) return a
        const v = (c - y) / 2
        return ul(Za(v), p) + a + ul(Xa(v), p)
      }
      function ak (a, c, p) {
        (a = Xe(a)), (c = Ie(c))
        const y = c ? To(a) : 0
        return c && y < c ? a + ul(c - y, p) : a
      }
      function lk (a, c, p) {
        (a = Xe(a)), (c = Ie(c))
        const y = c ? To(a) : 0
        return c && y < c ? ul(c - y, p) + a : a
      }
      function ck (a, c, p) {
        return (
          p || c == null ? (c = 0) : c && (c = +c),
          g1(Xe(a).replace(Uu, ''), c || 0)
        )
      }
      function uk (a, c, p) {
        return (
          (p ? un(a, c, p) : c === t) ? (c = 1) : (c = Ie(c)),
          vd(Xe(a), c)
        )
      }
      function dk () {
        const a = arguments
        const c = Xe(a[0])
        return a.length < 3 ? c : c.replace(a[1], a[2])
      }
      const fk = Oo(function (a, c, p) {
        return a + (p ? '_' : '') + c.toLowerCase()
      })
      function pk (a, c, p) {
        return (
          p && typeof p !== 'number' && un(a, c, p) && (c = p = t),
          (p = p === t ? z : p >>> 0),
          p
            ? ((a = Xe(a)),
              a &&
                          (typeof c === 'string' || (c != null && !Wd(c))) &&
                          ((c = An(c)), !c && So(a))
                ? li(Qn(a), 0, p)
                : a.split(c, p))
            : []
        )
      }
      const hk = Oo(function (a, c, p) {
        return a + (p ? ' ' : '') + Gd(c)
      })
      function mk (a, c, p) {
        return (
          (a = Xe(a)),
          (p = p == null ? 0 : Di(Ie(p), 0, a.length)),
          (c = An(c)),
          a.slice(p, p + c.length) == c
        )
      }
      function gk (a, c, p) {
        const y = x.templateSettings
        p && un(a, c, p) && (c = t),
        (a = Xe(a)),
        (c = xl({}, c, y, _b))
        const v = xl({}, c.imports, y.imports, _b)
        const _ = $t(v)
        const C = rd(v, _)
        let M
        let R
        let U = 0
        const W = c.interpolate || La
        let G = "__p += '"
        const te = od(
          (c.escape || La).source +
                        '|' +
                        W.source +
                        '|' +
                        (W === Ni ? JS : La).source +
                        '|' +
                        (c.evaluate || La).source +
                        '|$',
          'g'
        )
        const de =
                    '//# sourceURL=' +
                    (Ze.call(c, 'sourceURL')
                      ? (c.sourceURL + '').replace(/\s/g, ' ')
                      : 'lodash.templateSources[' + ++TT + ']') +
                    `
`
        a.replace(te, function (ve, $e, Ve, Nn, dn, kn) {
          return (
            Ve || (Ve = Nn),
            (G += a.slice(U, kn).replace(nT, VT)),
            $e &&
                            ((M = !0),
                            (G +=
                                `' +
__e(` +
                                $e +
                                `) +
'`)),
            dn &&
                            ((R = !0),
                            (G +=
                                `';
` +
                                dn +
                                `;
__p += '`)),
            Ve &&
                            (G +=
                                `' +
((__t = (` +
                                Ve +
                                `)) == null ? '' : __t) +
'`),
            (U = kn + ve.length),
            ve
          )
        }),
        (G += `';
`)
        const Ee = Ze.call(c, 'variable') && c.variable
        if (!Ee) {
          G =
                        `with (obj) {
` +
                        G +
                        `
}
`
        } else if (qS.test(Ee)) throw new Me(o);
        (G = (R ? G.replace(Se, '') : G)
          .replace(qe, '$1')
          .replace(Ke, '$1;')),
        (G =
                        'function(' +
                        (Ee || 'obj') +
                        `) {
` +
                        (Ee
                          ? ''
                          : `obj || (obj = {});
`) +
                        "var __t, __p = ''" +
                        (M ? ', __e = _.escape' : '') +
                        (R
                          ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
                          : `;
`) +
                        G +
                        `return __p
}`)
        const Le = my(function () {
          return Ye(_, de + 'return ' + G).apply(t, C)
        })
        if (((Le.source = G), Ud(Le))) throw Le
        return Le
      }
      function bk (a) {
        return Xe(a).toLowerCase()
      }
      function yk (a) {
        return Xe(a).toUpperCase()
      }
      function Ek (a, c, p) {
        if (((a = Xe(a)), a && (p || c === t))) return Sg(a)
        if (!a || !(c = An(c))) return a
        const y = Qn(a)
        const v = Qn(c)
        const _ = Tg(y, v)
        const C = Cg(y, v) + 1
        return li(y, _, C).join('')
      }
      function vk (a, c, p) {
        if (((a = Xe(a)), a && (p || c === t))) {
          return a.slice(0, Mg(a) + 1)
        }
        if (!a || !(c = An(c))) return a
        const y = Qn(a)
        const v = Cg(y, Qn(c)) + 1
        return li(y, 0, v).join('')
      }
      function wk (a, c, p) {
        if (((a = Xe(a)), a && (p || c === t))) {
          return a.replace(Uu, '')
        }
        if (!a || !(c = An(c))) return a
        const y = Qn(a)
        const v = Tg(y, Qn(c))
        return li(y, v).join('')
      }
      function xk (a, c) {
        let p = ne
        let y = q
        if (ft(c)) {
          var v = 'separator' in c ? c.separator : v;
          (p = 'length' in c ? Ie(c.length) : p),
          (y = 'omission' in c ? An(c.omission) : y)
        }
        a = Xe(a)
        let _ = a.length
        if (So(a)) {
          var C = Qn(a)
          _ = C.length
        }
        if (p >= _) return a
        let M = p - To(y)
        if (M < 1) return y
        let R = C ? li(C, 0, M).join('') : a.slice(0, M)
        if (v === t) return R + y
        if ((C && (M += R.length - M), Wd(v))) {
          if (a.slice(M).search(v)) {
            let U
            const W = R
            for (
              v.global ||
                                (v = od(v.source, Xe(Gm.exec(v)) + 'g')),
              v.lastIndex = 0;
              (U = v.exec(W));

            ) {
              var G = U.index
            }
            R = R.slice(0, G === t ? M : G)
          }
        } else if (a.indexOf(An(v), M) != M) {
          const te = R.lastIndexOf(v)
          te > -1 && (R = R.slice(0, te))
        }
        return R + y
      }
      function _k (a) {
        return (a = Xe(a)), a && Zr.test(a) ? a.replace(Ft, jT) : a
      }
      const Sk = Oo(function (a, c, p) {
        return a + (p ? ' ' : '') + c.toUpperCase()
      })
      var Gd = gb('toUpperCase')
      function hy (a, c, p) {
        return (
          (a = Xe(a)),
          (c = p ? t : c),
          c === t ? (qT(a) ? t1(a) : FT(a)) : a.match(c) || []
        )
      }
      var my = He(function (a, c) {
        try {
          return Tn(a, t, c)
        } catch (p) {
          return Ud(p) ? p : new Me(p)
        }
      })
      const Tk = Ar(function (a, c) {
        return (
          In(c, function (p) {
            (p = fr(p)), Tr(a, p, $d(a[p], a))
          }),
          a
        )
      })
      function Ck (a) {
        const c = a == null ? 0 : a.length
        const p = be()
        return (
          (a = c
            ? lt(a, function (y) {
              if (typeof y[1] !== 'function') {
                throw new Dn(i)
              }
              return [p(y[0]), y[1]]
            })
            : []),
          He(function (y) {
            for (let v = -1; ++v < c;) {
              const _ = a[v]
              if (Tn(_[0], this, y)) return Tn(_[1], this, y)
            }
          })
        )
      }
      function Ak (a) {
        return j1(Pn(a, d))
      }
      function qd (a) {
        return function () {
          return a
        }
      }
      function Mk (a, c) {
        return a == null || a !== a ? c : a
      }
      const Nk = yb()
      const kk = yb(!0)
      function vn (a) {
        return a
      }
      function Yd (a) {
        return Yg(typeof a === 'function' ? a : Pn(a, d))
      }
      function Ok (a) {
        return Xg(Pn(a, d))
      }
      function Rk (a, c) {
        return Zg(a, Pn(c, d))
      }
      const Ik = He(function (a, c) {
        return function (p) {
          return As(p, a, c)
        }
      })
      const Dk = He(function (a, c) {
        return function (p) {
          return As(a, p, c)
        }
      })
      function Jd (a, c, p) {
        const y = $t(c)
        let v = rl(c, y)
        p == null &&
                    !(ft(c) && (v.length || !y.length)) &&
                    ((p = c), (c = a), (a = this), (v = rl(c, $t(c))))
        const _ = !(ft(p) && 'chain' in p) || !!p.chain
        const C = Nr(a)
        return (
          In(v, function (M) {
            const R = c[M];
            (a[M] = R),
            C &&
                                (a.prototype[M] = function () {
                                  const U = this.__chain__
                                  if (_ || U) {
                                    const W = a(this.__wrapped__)
                                    const G = (W.__actions__ = bn(
                                      this.__actions__
                                    ))
                                    return (
                                      G.push({
                                        func: R,
                                        args: arguments,
                                        thisArg: a
                                      }),
                                      (W.__chain__ = U),
                                      W
                                    )
                                  }
                                  return R.apply(
                                    a,
                                    ti([this.value()], arguments)
                                  )
                                })
          }),
          a
        )
      }
      function Lk () {
        return Ht._ === this && (Ht._ = a1), this
      }
      function Xd () {}
      function Pk (a) {
        return (
          (a = Ie(a)),
          He(function (c) {
            return jg(c, a)
          })
        )
      }
      const Bk = Ad(lt)
      const Fk = Ad(Eg)
      const Hk = Ad(ju)
      function gy (a) {
        return Dd(a) ? Qu(fr(a)) : mC(a)
      }
      function $k (a) {
        return function (c) {
          return a == null ? t : Li(a, c)
        }
      }
      const zk = vb()
      const Uk = vb(!0)
      function Zd () {
        return []
      }
      function jd () {
        return !1
      }
      function Wk () {
        return {}
      }
      function Kk () {
        return ''
      }
      function Vk () {
        return !0
      }
      function Gk (a, c) {
        if (((a = Ie(a)), a < 1 || a > ye)) return []
        let p = z
        const y = jt(a, z);
        (c = be(c)), (a -= z)
        for (var v = nd(y, c); ++p < a;) c(p)
        return v
      }
      function qk (a) {
        return ke(a) ? lt(a, fr) : Mn(a) ? [a] : bn(Pb(Xe(a)))
      }
      function Yk (a) {
        const c = ++o1
        return Xe(a) + c
      }
      const Jk = cl(function (a, c) {
        return a + c
      }, 0)
      const Xk = Md('ceil')
      const Zk = cl(function (a, c) {
        return a / c
      }, 1)
      const jk = Md('floor')
      function Qk (a) {
        return a && a.length ? nl(a, vn, pd) : t
      }
      function eO (a, c) {
        return a && a.length ? nl(a, be(c, 2), pd) : t
      }
      function tO (a) {
        return xg(a, vn)
      }
      function nO (a, c) {
        return xg(a, be(c, 2))
      }
      function rO (a) {
        return a && a.length ? nl(a, vn, bd) : t
      }
      function iO (a, c) {
        return a && a.length ? nl(a, be(c, 2), bd) : t
      }
      const oO = cl(function (a, c) {
        return a * c
      }, 1)
      const sO = Md('round')
      const aO = cl(function (a, c) {
        return a - c
      }, 0)
      function lO (a) {
        return a && a.length ? td(a, vn) : 0
      }
      function cO (a, c) {
        return a && a.length ? td(a, be(c, 2)) : 0
      }
      return (
        (x.after = OM),
        (x.ary = qb),
        (x.assign = yN),
        (x.assignIn = ay),
        (x.assignInWith = xl),
        (x.assignWith = EN),
        (x.at = vN),
        (x.before = Yb),
        (x.bind = $d),
        (x.bindAll = Tk),
        (x.bindKey = Jb),
        (x.castArray = WM),
        (x.chain = Kb),
        (x.chunk = jC),
        (x.compact = QC),
        (x.concat = eA),
        (x.cond = Ck),
        (x.conforms = Ak),
        (x.constant = qd),
        (x.countBy = lM),
        (x.create = wN),
        (x.curry = Xb),
        (x.curryRight = Zb),
        (x.debounce = jb),
        (x.defaults = xN),
        (x.defaultsDeep = _N),
        (x.defer = RM),
        (x.delay = IM),
        (x.difference = tA),
        (x.differenceBy = nA),
        (x.differenceWith = rA),
        (x.drop = iA),
        (x.dropRight = oA),
        (x.dropRightWhile = sA),
        (x.dropWhile = aA),
        (x.fill = lA),
        (x.filter = uM),
        (x.flatMap = pM),
        (x.flatMapDeep = hM),
        (x.flatMapDepth = mM),
        (x.flatten = $b),
        (x.flattenDeep = cA),
        (x.flattenDepth = uA),
        (x.flip = DM),
        (x.flow = Nk),
        (x.flowRight = kk),
        (x.fromPairs = dA),
        (x.functions = kN),
        (x.functionsIn = ON),
        (x.groupBy = gM),
        (x.initial = pA),
        (x.intersection = hA),
        (x.intersectionBy = mA),
        (x.intersectionWith = gA),
        (x.invert = IN),
        (x.invertBy = DN),
        (x.invokeMap = yM),
        (x.iteratee = Yd),
        (x.keyBy = EM),
        (x.keys = $t),
        (x.keysIn = En),
        (x.map = gl),
        (x.mapKeys = PN),
        (x.mapValues = BN),
        (x.matches = Ok),
        (x.matchesProperty = Rk),
        (x.memoize = yl),
        (x.merge = FN),
        (x.mergeWith = ly),
        (x.method = Ik),
        (x.methodOf = Dk),
        (x.mixin = Jd),
        (x.negate = El),
        (x.nthArg = Pk),
        (x.omit = HN),
        (x.omitBy = $N),
        (x.once = LM),
        (x.orderBy = vM),
        (x.over = Bk),
        (x.overArgs = PM),
        (x.overEvery = Fk),
        (x.overSome = Hk),
        (x.partial = zd),
        (x.partialRight = Qb),
        (x.partition = wM),
        (x.pick = zN),
        (x.pickBy = cy),
        (x.property = gy),
        (x.propertyOf = $k),
        (x.pull = vA),
        (x.pullAll = Ub),
        (x.pullAllBy = wA),
        (x.pullAllWith = xA),
        (x.pullAt = _A),
        (x.range = zk),
        (x.rangeRight = Uk),
        (x.rearg = BM),
        (x.reject = SM),
        (x.remove = SA),
        (x.rest = FM),
        (x.reverse = Fd),
        (x.sampleSize = CM),
        (x.set = WN),
        (x.setWith = KN),
        (x.shuffle = AM),
        (x.slice = TA),
        (x.sortBy = kM),
        (x.sortedUniq = RA),
        (x.sortedUniqBy = IA),
        (x.split = pk),
        (x.spread = HM),
        (x.tail = DA),
        (x.take = LA),
        (x.takeRight = PA),
        (x.takeRightWhile = BA),
        (x.takeWhile = FA),
        (x.tap = QA),
        (x.throttle = $M),
        (x.thru = ml),
        (x.toArray = iy),
        (x.toPairs = uy),
        (x.toPairsIn = dy),
        (x.toPath = qk),
        (x.toPlainObject = sy),
        (x.transform = VN),
        (x.unary = zM),
        (x.union = HA),
        (x.unionBy = $A),
        (x.unionWith = zA),
        (x.uniq = UA),
        (x.uniqBy = WA),
        (x.uniqWith = KA),
        (x.unset = GN),
        (x.unzip = Hd),
        (x.unzipWith = Wb),
        (x.update = qN),
        (x.updateWith = YN),
        (x.values = Do),
        (x.valuesIn = JN),
        (x.without = VA),
        (x.words = hy),
        (x.wrap = UM),
        (x.xor = GA),
        (x.xorBy = qA),
        (x.xorWith = YA),
        (x.zip = JA),
        (x.zipObject = XA),
        (x.zipObjectDeep = ZA),
        (x.zipWith = jA),
        (x.entries = uy),
        (x.entriesIn = dy),
        (x.extend = ay),
        (x.extendWith = xl),
        Jd(x, x),
        (x.add = Jk),
        (x.attempt = my),
        (x.camelCase = QN),
        (x.capitalize = fy),
        (x.ceil = Xk),
        (x.clamp = XN),
        (x.clone = KM),
        (x.cloneDeep = GM),
        (x.cloneDeepWith = qM),
        (x.cloneWith = VM),
        (x.conformsTo = YM),
        (x.deburr = py),
        (x.defaultTo = Mk),
        (x.divide = Zk),
        (x.endsWith = ek),
        (x.eq = tr),
        (x.escape = tk),
        (x.escapeRegExp = nk),
        (x.every = cM),
        (x.find = dM),
        (x.findIndex = Fb),
        (x.findKey = SN),
        (x.findLast = fM),
        (x.findLastIndex = Hb),
        (x.findLastKey = TN),
        (x.floor = jk),
        (x.forEach = Vb),
        (x.forEachRight = Gb),
        (x.forIn = CN),
        (x.forInRight = AN),
        (x.forOwn = MN),
        (x.forOwnRight = NN),
        (x.get = Kd),
        (x.gt = JM),
        (x.gte = XM),
        (x.has = RN),
        (x.hasIn = Vd),
        (x.head = zb),
        (x.identity = vn),
        (x.includes = bM),
        (x.indexOf = fA),
        (x.inRange = ZN),
        (x.invoke = LN),
        (x.isArguments = Fi),
        (x.isArray = ke),
        (x.isArrayBuffer = ZM),
        (x.isArrayLike = yn),
        (x.isArrayLikeObject = Et),
        (x.isBoolean = jM),
        (x.isBuffer = ci),
        (x.isDate = QM),
        (x.isElement = eN),
        (x.isEmpty = tN),
        (x.isEqual = nN),
        (x.isEqualWith = rN),
        (x.isError = Ud),
        (x.isFinite = iN),
        (x.isFunction = Nr),
        (x.isInteger = ey),
        (x.isLength = vl),
        (x.isMap = ty),
        (x.isMatch = oN),
        (x.isMatchWith = sN),
        (x.isNaN = aN),
        (x.isNative = lN),
        (x.isNil = uN),
        (x.isNull = cN),
        (x.isNumber = ny),
        (x.isObject = ft),
        (x.isObjectLike = ht),
        (x.isPlainObject = Is),
        (x.isRegExp = Wd),
        (x.isSafeInteger = dN),
        (x.isSet = ry),
        (x.isString = wl),
        (x.isSymbol = Mn),
        (x.isTypedArray = Io),
        (x.isUndefined = fN),
        (x.isWeakMap = pN),
        (x.isWeakSet = hN),
        (x.join = bA),
        (x.kebabCase = rk),
        (x.last = Fn),
        (x.lastIndexOf = yA),
        (x.lowerCase = ik),
        (x.lowerFirst = ok),
        (x.lt = mN),
        (x.lte = gN),
        (x.max = Qk),
        (x.maxBy = eO),
        (x.mean = tO),
        (x.meanBy = nO),
        (x.min = rO),
        (x.minBy = iO),
        (x.stubArray = Zd),
        (x.stubFalse = jd),
        (x.stubObject = Wk),
        (x.stubString = Kk),
        (x.stubTrue = Vk),
        (x.multiply = oO),
        (x.nth = EA),
        (x.noConflict = Lk),
        (x.noop = Xd),
        (x.now = bl),
        (x.pad = sk),
        (x.padEnd = ak),
        (x.padStart = lk),
        (x.parseInt = ck),
        (x.random = jN),
        (x.reduce = xM),
        (x.reduceRight = _M),
        (x.repeat = uk),
        (x.replace = dk),
        (x.result = UN),
        (x.round = sO),
        (x.runInContext = N),
        (x.sample = TM),
        (x.size = MM),
        (x.snakeCase = fk),
        (x.some = NM),
        (x.sortedIndex = CA),
        (x.sortedIndexBy = AA),
        (x.sortedIndexOf = MA),
        (x.sortedLastIndex = NA),
        (x.sortedLastIndexBy = kA),
        (x.sortedLastIndexOf = OA),
        (x.startCase = hk),
        (x.startsWith = mk),
        (x.subtract = aO),
        (x.sum = lO),
        (x.sumBy = cO),
        (x.template = gk),
        (x.times = Gk),
        (x.toFinite = kr),
        (x.toInteger = Ie),
        (x.toLength = oy),
        (x.toLower = bk),
        (x.toNumber = Hn),
        (x.toSafeInteger = bN),
        (x.toString = Xe),
        (x.toUpper = yk),
        (x.trim = Ek),
        (x.trimEnd = vk),
        (x.trimStart = wk),
        (x.truncate = xk),
        (x.unescape = _k),
        (x.uniqueId = Yk),
        (x.upperCase = Sk),
        (x.upperFirst = Gd),
        (x.each = Vb),
        (x.eachRight = Gb),
        (x.first = zb),
        Jd(
          x,
          (function () {
            const a = {}
            return (
              ur(x, function (c, p) {
                Ze.call(x.prototype, p) || (a[p] = c)
              }),
              a
            )
          })(),
          { chain: !1 }
        ),
        (x.VERSION = e),
        In(
          [
            'bind',
            'bindKey',
            'curry',
            'curryRight',
            'partial',
            'partialRight'
          ],
          function (a) {
            x[a].placeholder = x
          }
        ),
        In(['drop', 'take'], function (a, c) {
          (Ue.prototype[a] = function (p) {
            p = p === t ? 1 : It(Ie(p), 0)
            const y =
                            this.__filtered__ && !c
                              ? new Ue(this)
                              : this.clone()
            return (
              y.__filtered__
                ? (y.__takeCount__ = jt(p, y.__takeCount__))
                : y.__views__.push({
                  size: jt(p, z),
                  type: a + (y.__dir__ < 0 ? 'Right' : '')
                }),
              y
            )
          }),
          (Ue.prototype[a + 'Right'] = function (p) {
            return this.reverse()[a](p).reverse()
          })
        }),
        In(['filter', 'map', 'takeWhile'], function (a, c) {
          const p = c + 1
          const y = p == we || p == Ce
          Ue.prototype[a] = function (v) {
            const _ = this.clone()
            return (
              _.__iteratees__.push({
                iteratee: be(v, 3),
                type: p
              }),
              (_.__filtered__ = _.__filtered__ || y),
              _
            )
          }
        }),
        In(['head', 'last'], function (a, c) {
          const p = 'take' + (c ? 'Right' : '')
          Ue.prototype[a] = function () {
            return this[p](1).value()[0]
          }
        }),
        In(['initial', 'tail'], function (a, c) {
          const p = 'drop' + (c ? '' : 'Right')
          Ue.prototype[a] = function () {
            return this.__filtered__ ? new Ue(this) : this[p](1)
          }
        }),
        (Ue.prototype.compact = function () {
          return this.filter(vn)
        }),
        (Ue.prototype.find = function (a) {
          return this.filter(a).head()
        }),
        (Ue.prototype.findLast = function (a) {
          return this.reverse().find(a)
        }),
        (Ue.prototype.invokeMap = He(function (a, c) {
          return typeof a === 'function'
            ? new Ue(this)
            : this.map(function (p) {
              return As(p, a, c)
            })
        })),
        (Ue.prototype.reject = function (a) {
          return this.filter(El(be(a)))
        }),
        (Ue.prototype.slice = function (a, c) {
          a = Ie(a)
          let p = this
          return p.__filtered__ && (a > 0 || c < 0)
            ? new Ue(p)
            : (a < 0 ? (p = p.takeRight(-a)) : a && (p = p.drop(a)),
              c !== t &&
                              ((c = Ie(c)),
                              (p = c < 0 ? p.dropRight(-c) : p.take(c - a))),
              p)
        }),
        (Ue.prototype.takeRightWhile = function (a) {
          return this.reverse().takeWhile(a).reverse()
        }),
        (Ue.prototype.toArray = function () {
          return this.take(z)
        }),
        ur(Ue.prototype, function (a, c) {
          const p = /^(?:filter|find|map|reject)|While$/.test(c)
          const y = /^(?:head|last)$/.test(c)
          const v = x[y ? 'take' + (c == 'last' ? 'Right' : '') : c]
          const _ = y || /^find/.test(c)
          v &&
                        (x.prototype[c] = function () {
                          let C = this.__wrapped__
                          const M = y ? [1] : arguments
                          let R = C instanceof Ue
                          const U = M[0]
                          let W = R || ke(C)
                          const G = function ($e) {
                            const Ve = v.apply(x, ti([$e], M))
                            return y && te ? Ve[0] : Ve
                          }
                          W &&
                                p &&
                                typeof U === 'function' &&
                                U.length != 1 &&
                                (R = W = !1)
                          var te = this.__chain__
                          const de = !!this.__actions__.length
                          const Ee = _ && !te
                          const Le = R && !de
                          if (!_ && W) {
                            C = Le ? C : new Ue(this)
                            var ve = a.apply(C, M)
                            return (
                              ve.__actions__.push({
                                func: ml,
                                args: [G],
                                thisArg: t
                              }),
                              new Ln(ve, te)
                            )
                          }
                          return Ee && Le
                            ? a.apply(this, M)
                            : ((ve = this.thru(G)),
                              Ee ? (y ? ve.value()[0] : ve.value()) : ve)
                        })
        }),
        In(
          ['pop', 'push', 'shift', 'sort', 'splice', 'unshift'],
          function (a) {
            const c = za[a]
            const p = /^(?:push|sort|unshift)$/.test(a)
              ? 'tap'
              : 'thru'
            const y = /^(?:pop|shift)$/.test(a)
            x.prototype[a] = function () {
              const v = arguments
              if (y && !this.__chain__) {
                const _ = this.value()
                return c.apply(ke(_) ? _ : [], v)
              }
              return this[p](function (C) {
                return c.apply(ke(C) ? C : [], v)
              })
            }
          }
        ),
        ur(Ue.prototype, function (a, c) {
          const p = x[c]
          if (p) {
            const y = p.name + ''
            Ze.call(Mo, y) || (Mo[y] = []),
            Mo[y].push({ name: c, func: p })
          }
        }),
        (Mo[ll(t, E).name] = [{ name: 'wrapper', func: t }]),
        (Ue.prototype.clone = _1),
        (Ue.prototype.reverse = S1),
        (Ue.prototype.value = T1),
        (x.prototype.at = eM),
        (x.prototype.chain = tM),
        (x.prototype.commit = nM),
        (x.prototype.next = rM),
        (x.prototype.plant = oM),
        (x.prototype.reverse = sM),
        (x.prototype.toJSON =
                    x.prototype.valueOf =
                    x.prototype.value =
                        aM),
        (x.prototype.first = x.prototype.head),
        vs && (x.prototype[vs] = iM),
        x
      )
    }
    var ri = n1()
    typeof define === 'function' &&
        typeof define.amd === 'object' &&
        define.amd
      ? ((Ht._ = ri),
        define(function () {
          return ri
        }))
      : ki
        ? (((ki.exports = ri)._ = ri), (Yu._ = ri))
        : (Ht._ = ri)
  }).call(gs)
})
function en (t) {
  this.content = t
}
en.prototype = {
  constructor: en,
  find: function (t) {
    for (let e = 0; e < this.content.length; e += 2) {
      if (this.content[e] === t) return e
    }
    return -1
  },
  get: function (t) {
    const e = this.find(t)
    return e == -1 ? void 0 : this.content[e + 1]
  },
  update: function (t, e, n) {
    const r = n && n != t ? this.remove(n) : this
    const i = r.find(t)
    const o = r.content.slice()
    return (
      i == -1 ? o.push(n || t, e) : ((o[i + 1] = e), n && (o[i] = n)),
      new en(o)
    )
  },
  remove: function (t) {
    const e = this.find(t)
    if (e == -1) return this
    const n = this.content.slice()
    return n.splice(e, 2), new en(n)
  },
  addToStart: function (t, e) {
    return new en([t, e].concat(this.remove(t).content))
  },
  addToEnd: function (t, e) {
    const n = this.remove(t).content.slice()
    return n.push(t, e), new en(n)
  },
  addBefore: function (t, e, n) {
    const r = this.remove(e)
    const i = r.content.slice()
    const o = r.find(t)
    return i.splice(o == -1 ? i.length : o, 0, e, n), new en(i)
  },
  forEach: function (t) {
    for (let e = 0; e < this.content.length; e += 2) {
      t(this.content[e], this.content[e + 1])
    }
  },
  prepend: function (t) {
    return (
      (t = en.from(t)),
      t.size ? new en(t.content.concat(this.subtract(t).content)) : this
    )
  },
  append: function (t) {
    return (
      (t = en.from(t)),
      t.size ? new en(this.subtract(t).content.concat(t.content)) : this
    )
  },
  subtract: function (t) {
    let e = this
    t = en.from(t)
    for (let n = 0; n < t.content.length; n += 2) {
      e = e.remove(t.content[n])
    }
    return e
  },
  toObject: function () {
    const t = {}
    return (
      this.forEach(function (e, n) {
        t[e] = n
      }),
      t
    )
  },
  get size () {
    return this.content.length >> 1
  }
}
en.from = function (t) {
  if (t instanceof en) return t
  const e = []
  if (t) for (const n in t) e.push(n, t[n])
  return new en(e)
}
const tf = en
function My (t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount) {
      return t.childCount == e.childCount ? null : n
    }
    const i = t.child(r)
    const o = e.child(r)
    if (i == o) {
      n += i.nodeSize
      continue
    }
    if (!i.sameMarkup(o)) return n
    if (i.isText && i.text != o.text) {
      for (let s = 0; i.text[s] == o.text[s]; s++) n++
      return n
    }
    if (i.content.size || o.content.size) {
      const s = My(i.content, o.content, n + 1)
      if (s != null) return s
    }
    n += i.nodeSize
  }
}
function Ny (t, e, n, r) {
  for (let i = t.childCount, o = e.childCount; ;) {
    if (i == 0 || o == 0) return i == o ? null : { a: n, b: r }
    const s = t.child(--i)
    const l = e.child(--o)
    const u = s.nodeSize
    if (s == l) {
      (n -= u), (r -= u)
      continue
    }
    if (!s.sameMarkup(l)) return { a: n, b: r }
    if (s.isText && s.text != l.text) {
      let d = 0
      const f = Math.min(s.text.length, l.text.length)
      for (
        ;
        d < f &&
                s.text[s.text.length - d - 1] == l.text[l.text.length - d - 1];

      ) {
        d++, n--, r--
      }
      return { a: n, b: r }
    }
    if (s.content.size || l.content.size) {
      const d = Ny(s.content, l.content, n - 1, r - 1)
      if (d) return d
    }
    (n -= u), (r -= u)
  }
}
const K = class t {
  constructor (e, n) {
    if (((this.content = e), (this.size = n || 0), n == null)) {
      for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize
    }
  }

  nodesBetween (e, n, r, i = 0, o) {
    for (let s = 0, l = 0; l < n; s++) {
      const u = this.content[s]
      const d = l + u.nodeSize
      if (d > e && r(u, i + l, o || null, s) !== !1 && u.content.size) {
        const f = l + 1
        u.nodesBetween(
          Math.max(0, e - f),
          Math.min(u.content.size, n - f),
          r,
          i + f
        )
      }
      l = d
    }
  }

  descendants (e) {
    this.nodesBetween(0, this.size, e)
  }

  textBetween (e, n, r, i) {
    let o = ''
    let s = !0
    return (
      this.nodesBetween(
        e,
        n,
        (l, u) => {
          const d = l.isText
            ? l.text.slice(Math.max(e, u) - u, n - u)
            : l.isLeaf
              ? i
                ? typeof i === 'function'
                  ? i(l)
                  : i
                : l.type.spec.leafText
                  ? l.type.spec.leafText(l)
                  : ''
              : ''
          l.isBlock &&
                        ((l.isLeaf && d) || l.isTextblock) &&
                        r &&
                        (s ? (s = !1) : (o += r)),
          (o += d)
        },
        0
      ),
      o
    )
  }

  append (e) {
    if (!e.size) return this
    if (!this.size) return e
    const n = this.lastChild
    const r = e.firstChild
    const i = this.content.slice()
    let o = 0
    for (
      n.isText &&
            n.sameMarkup(r) &&
            ((i[i.length - 1] = n.withText(n.text + r.text)), (o = 1));
      o < e.content.length;
      o++
    ) {
      i.push(e.content[o])
    }
    return new t(i, this.size + e.size)
  }

  cut (e, n = this.size) {
    if (e == 0 && n == this.size) return this
    const r = []
    let i = 0
    if (n > e) {
      for (let o = 0, s = 0; s < n; o++) {
        let l = this.content[o]
        const u = s + l.nodeSize
        u > e &&
                    ((s < e || u > n) &&
                        (l.isText
                          ? (l = l.cut(
                              Math.max(0, e - s),
                              Math.min(l.text.length, n - s)
                            ))
                          : (l = l.cut(
                              Math.max(0, e - s - 1),
                              Math.min(l.content.size, n - s - 1)
                            ))),
                    r.push(l),
                    (i += l.nodeSize)),
        (s = u)
      }
    }
    return new t(r, i)
  }

  cutByIndex (e, n) {
    return e == n
      ? t.empty
      : e == 0 && n == this.content.length
        ? this
        : new t(this.content.slice(e, n))
  }

  replaceChild (e, n) {
    const r = this.content[e]
    if (r == n) return this
    const i = this.content.slice()
    const o = this.size + n.nodeSize - r.nodeSize
    return (i[e] = n), new t(i, o)
  }

  addToStart (e) {
    return new t([e].concat(this.content), this.size + e.nodeSize)
  }

  addToEnd (e) {
    return new t(this.content.concat(e), this.size + e.nodeSize)
  }

  eq (e) {
    if (this.content.length != e.content.length) return !1
    for (let n = 0; n < this.content.length; n++) {
      if (!this.content[n].eq(e.content[n])) return !1
    }
    return !0
  }

  get firstChild () {
    return this.content.length ? this.content[0] : null
  }

  get lastChild () {
    return this.content.length
      ? this.content[this.content.length - 1]
      : null
  }

  get childCount () {
    return this.content.length
  }

  child (e) {
    const n = this.content[e]
    if (!n) {
      throw new RangeError('Index ' + e + ' out of range for ' + this)
    }
    return n
  }

  maybeChild (e) {
    return this.content[e] || null
  }

  forEach (e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      const i = this.content[n]
      e(i, r, n), (r += i.nodeSize)
    }
  }

  findDiffStart (e, n = 0) {
    return My(this, e, n)
  }

  findDiffEnd (e, n = this.size, r = e.size) {
    return Ny(this, e, n, r)
  }

  findIndex (e, n = -1) {
    if (e == 0) return _l(0, e)
    if (e == this.size) return _l(this.content.length, e)
    if (e > this.size || e < 0) {
      throw new RangeError(`Position ${e} outside of fragment (${this})`)
    }
    for (let r = 0, i = 0; ; r++) {
      const o = this.child(r)
      const s = i + o.nodeSize
      if (s >= e) return s == e || n > 0 ? _l(r + 1, s) : _l(r, i)
      i = s
    }
  }

  toString () {
    return '<' + this.toStringInner() + '>'
  }

  toStringInner () {
    return this.content.join(', ')
  }

  toJSON () {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null
  }

  static fromJSON (e, n) {
    if (!n) return t.empty
    if (!Array.isArray(n)) {
      throw new RangeError('Invalid input for Fragment.fromJSON')
    }
    return new t(n.map(e.nodeFromJSON))
  }

  static fromArray (e) {
    if (!e.length) return t.empty
    let n
    let r = 0
    for (let i = 0; i < e.length; i++) {
      const o = e[i];
      (r += o.nodeSize),
      i && o.isText && e[i - 1].sameMarkup(o)
        ? (n || (n = e.slice(0, i)),
          (n[n.length - 1] = o.withText(
            n[n.length - 1].text + o.text
          )))
        : n && n.push(o)
    }
    return new t(n || e, r)
  }

  static from (e) {
    if (!e) return t.empty
    if (e instanceof t) return e
    if (Array.isArray(e)) return this.fromArray(e)
    if (e.attrs) return new t([e], e.nodeSize)
    throw new RangeError(
      'Can not convert ' +
                e +
                ' to a Fragment' +
                (e.nodesBetween
                  ? ' (looks like multiple versions of prosemirror-model were loaded)'
                  : '')
    )
  }
}
K.empty = new K([], 0)
const nf = { index: 0, offset: 0 }
function _l (t, e) {
  return (nf.index = t), (nf.offset = e), nf
}
function Tl (t, e) {
  if (t === e) return !0
  if (!(t && typeof t === 'object') || !(e && typeof e === 'object')) {
    return !1
  }
  const n = Array.isArray(t)
  if (Array.isArray(e) != n) return !1
  if (n) {
    if (t.length != e.length) return !1
    for (let r = 0; r < t.length; r++) if (!Tl(t[r], e[r])) return !1
  } else {
    for (const r in t) if (!(r in e) || !Tl(t[r], e[r])) return !1
    for (const r in e) if (!(r in t)) return !1
  }
  return !0
}
const Ge = class t {
  constructor (e, n) {
    (this.type = e), (this.attrs = n)
  }

  addToSet (e) {
    let n
    let r = !1
    for (let i = 0; i < e.length; i++) {
      const o = e[i]
      if (this.eq(o)) return e
      if (this.type.excludes(o.type)) n || (n = e.slice(0, i))
      else {
        if (o.type.excludes(this.type)) return e
        !r &&
                    o.type.rank > this.type.rank &&
                    (n || (n = e.slice(0, i)), n.push(this), (r = !0)),
        n && n.push(o)
      }
    }
    return n || (n = e.slice()), r || n.push(this), n
  }

  removeFromSet (e) {
    for (let n = 0; n < e.length; n++) {
      if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1))
    }
    return e
  }

  isInSet (e) {
    for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0
    return !1
  }

  eq (e) {
    return this == e || (this.type == e.type && Tl(this.attrs, e.attrs))
  }

  toJSON () {
    const e = { type: this.type.name }
    for (const n in this.attrs) {
      e.attrs = this.attrs
      break
    }
    return e
  }

  static fromJSON (e, n) {
    if (!n) throw new RangeError('Invalid input for Mark.fromJSON')
    const r = e.marks[n.type]
    if (!r) {
      throw new RangeError(
                `There is no mark type ${n.type} in this schema`
      )
    }
    const i = r.create(n.attrs)
    return r.checkAttrs(i.attrs), i
  }

  static sameSet (e, n) {
    if (e == n) return !0
    if (e.length != n.length) return !1
    for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1
    return !0
  }

  static setFrom (e) {
    if (!e || (Array.isArray(e) && e.length == 0)) return t.none
    if (e instanceof t) return [e]
    const n = e.slice()
    return n.sort((r, i) => r.type.rank - i.type.rank), n
  }
}
Ge.none = []
const zi = class extends Error {}
const Z = class t {
  constructor (e, n, r) {
    (this.content = e), (this.openStart = n), (this.openEnd = r)
  }

  get size () {
    return this.content.size - this.openStart - this.openEnd
  }

  insertAt (e, n) {
    const r = Oy(this.content, e + this.openStart, n)
    return r && new t(r, this.openStart, this.openEnd)
  }

  removeBetween (e, n) {
    return new t(
      ky(this.content, e + this.openStart, n + this.openStart),
      this.openStart,
      this.openEnd
    )
  }

  eq (e) {
    return (
      this.content.eq(e.content) &&
            this.openStart == e.openStart &&
            this.openEnd == e.openEnd
    )
  }

  toString () {
    return this.content + '(' + this.openStart + ',' + this.openEnd + ')'
  }

  toJSON () {
    if (!this.content.size) return null
    const e = { content: this.content.toJSON() }
    return (
      this.openStart > 0 && (e.openStart = this.openStart),
      this.openEnd > 0 && (e.openEnd = this.openEnd),
      e
    )
  }

  static fromJSON (e, n) {
    if (!n) return t.empty
    const r = n.openStart || 0
    const i = n.openEnd || 0
    if (typeof r !== 'number' || typeof i !== 'number') {
      throw new RangeError('Invalid input for Slice.fromJSON')
    }
    return new t(K.fromJSON(e, n.content), r, i)
  }

  static maxOpen (e, n = !0) {
    let r = 0
    let i = 0
    for (
      let o = e.firstChild;
      o && !o.isLeaf && (n || !o.type.spec.isolating);
      o = o.firstChild
    ) {
      r++
    }
    for (
      let o = e.lastChild;
      o && !o.isLeaf && (n || !o.type.spec.isolating);
      o = o.lastChild
    ) {
      i++
    }
    return new t(e, r, i)
  }
}
Z.empty = new Z(K.empty, 0, 0)
function ky (t, e, n) {
  const { index: r, offset: i } = t.findIndex(e)
  const o = t.maybeChild(r)
  const { index: s, offset: l } = t.findIndex(n)
  if (i == e || o.isText) {
    if (l != n && !t.child(s).isText) {
      throw new RangeError('Removing non-flat range')
    }
    return t.cut(0, e).append(t.cut(n))
  }
  if (r != s) throw new RangeError('Removing non-flat range')
  return t.replaceChild(r, o.copy(ky(o.content, e - i - 1, n - i - 1)))
}
function Oy (t, e, n, r) {
  const { index: i, offset: o } = t.findIndex(e)
  const s = t.maybeChild(i)
  if (o == e || s.isText) {
    return r && !r.canReplace(i, i, n)
      ? null
      : t.cut(0, e).append(n).append(t.cut(e))
  }
  const l = Oy(s.content, e - o - 1, n)
  return l && t.replaceChild(i, s.copy(l))
}
function gO (t, e, n) {
  if (n.openStart > t.depth) {
    throw new zi('Inserted content deeper than insertion position')
  }
  if (t.depth - n.openStart != e.depth - n.openEnd) {
    throw new zi('Inconsistent open depths')
  }
  return Ry(t, e, n, 0)
}
function Ry (t, e, n, r) {
  const i = t.index(r)
  const o = t.node(r)
  if (i == e.index(r) && r < t.depth - n.openStart) {
    const s = Ry(t, e, n, r + 1)
    return o.copy(o.content.replaceChild(i, s))
  } else if (n.content.size) {
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      const s = t.parent
      const l = s.content
      return $i(
        s,
        l
          .cut(0, t.parentOffset)
          .append(n.content)
          .append(l.cut(e.parentOffset))
      )
    } else {
      const { start: s, end: l } = bO(n, t)
      return $i(o, Dy(t, s, l, e, r))
    }
  } else return $i(o, Cl(t, e, r))
}
function Iy (t, e) {
  if (!e.type.compatibleContent(t.type)) {
    throw new zi('Cannot join ' + e.type.name + ' onto ' + t.type.name)
  }
}
function of (t, e, n) {
  const r = t.node(n)
  return Iy(r, e.node(n)), r
}
function Hi (t, e) {
  const n = e.length - 1
  n >= 0 && t.isText && t.sameMarkup(e[n])
    ? (e[n] = t.withText(e[n].text + t.text))
    : e.push(t)
}
function Ds (t, e, n, r) {
  const i = (e || t).node(n)
  let o = 0
  const s = e ? e.index(n) : i.childCount
  t &&
        ((o = t.index(n)),
        t.depth > n ? o++ : t.textOffset && (Hi(t.nodeAfter, r), o++))
  for (let l = o; l < s; l++) Hi(i.child(l), r)
  e && e.depth == n && e.textOffset && Hi(e.nodeBefore, r)
}
function $i (t, e) {
  return t.type.checkContent(e), t.copy(e)
}
function Dy (t, e, n, r, i) {
  const o = t.depth > i && of(t, e, i + 1)
  const s = r.depth > i && of(n, r, i + 1)
  const l = []
  return (
    Ds(null, t, i, l),
    o && s && e.index(i) == n.index(i)
      ? (Iy(o, s), Hi($i(o, Dy(t, e, n, r, i + 1)), l))
      : (o && Hi($i(o, Cl(t, e, i + 1)), l),
        Ds(e, n, i, l),
        s && Hi($i(s, Cl(n, r, i + 1)), l)),
    Ds(r, null, i, l),
    new K(l)
  )
}
function Cl (t, e, n) {
  const r = []
  if ((Ds(null, t, n, r), t.depth > n)) {
    const i = of(t, e, n + 1)
    Hi($i(i, Cl(t, e, n + 1)), r)
  }
  return Ds(e, null, n, r), new K(r)
}
function bO (t, e) {
  const n = e.depth - t.openStart
  let i = e.node(n).copy(t.content)
  for (let o = n - 1; o >= 0; o--) i = e.node(o).copy(K.from(i))
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  }
}
const Al = class t {
  constructor (e, n, r) {
    (this.pos = e),
    (this.path = n),
    (this.parentOffset = r),
    (this.depth = n.length / 3 - 1)
  }

  resolveDepth (e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e
  }

  get parent () {
    return this.node(this.depth)
  }

  get doc () {
    return this.node(0)
  }

  node (e) {
    return this.path[this.resolveDepth(e) * 3]
  }

  index (e) {
    return this.path[this.resolveDepth(e) * 3 + 1]
  }

  indexAfter (e) {
    return (
      (e = this.resolveDepth(e)),
      this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
    )
  }

  start (e) {
    return (
      (e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1
    )
  }

  end (e) {
    return (
      (e = this.resolveDepth(e)),
      this.start(e) + this.node(e).content.size
    )
  }

  before (e) {
    if (((e = this.resolveDepth(e)), !e)) {
      throw new RangeError(
        'There is no position before the top-level node'
      )
    }
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1]
  }

  after (e) {
    if (((e = this.resolveDepth(e)), !e)) {
      throw new RangeError(
        'There is no position after the top-level node'
      )
    }
    return e == this.depth + 1
      ? this.pos
      : this.path[e * 3 - 1] + this.path[e * 3].nodeSize
  }

  get textOffset () {
    return this.pos - this.path[this.path.length - 1]
  }

  get nodeAfter () {
    const e = this.parent
    const n = this.index(this.depth)
    if (n == e.childCount) return null
    const r = this.pos - this.path[this.path.length - 1]
    const i = e.child(n)
    return r ? e.child(n).cut(r) : i
  }

  get nodeBefore () {
    const e = this.index(this.depth)
    const n = this.pos - this.path[this.path.length - 1]
    return n
      ? this.parent.child(e).cut(0, n)
      : e == 0
        ? null
        : this.parent.child(e - 1)
  }

  posAtIndex (e, n) {
    n = this.resolveDepth(n)
    const r = this.path[n * 3]
    let i = n == 0 ? 0 : this.path[n * 3 - 1] + 1
    for (let o = 0; o < e; o++) i += r.child(o).nodeSize
    return i
  }

  marks () {
    const e = this.parent
    const n = this.index()
    if (e.content.size == 0) return Ge.none
    if (this.textOffset) return e.child(n).marks
    let r = e.maybeChild(n - 1)
    let i = e.maybeChild(n)
    if (!r) {
      const l = r;
      (r = i), (i = l)
    }
    let o = r.marks
    for (let s = 0; s < o.length; s++) {
      o[s].type.spec.inclusive === !1 &&
                (!i || !o[s].isInSet(i.marks)) &&
                (o = o[s--].removeFromSet(o))
    }
    return o
  }

  marksAcross (e) {
    const n = this.parent.maybeChild(this.index())
    if (!n || !n.isInline) return null
    let r = n.marks
    const i = e.parent.maybeChild(e.index())
    for (let o = 0; o < r.length; o++) {
      r[o].type.spec.inclusive === !1 &&
                (!i || !r[o].isInSet(i.marks)) &&
                (r = r[o--].removeFromSet(r))
    }
    return r
  }

  sharedDepth (e) {
    for (let n = this.depth; n > 0; n--) {
      if (this.start(n) <= e && this.end(n) >= e) return n
    }
    return 0
  }

  blockRange (e = this, n) {
    if (e.pos < this.pos) return e.blockRange(this)
    for (
      let r =
                this.depth -
                (this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
      r >= 0;
      r--
    ) {
      if (e.pos <= this.end(r) && (!n || n(this.node(r)))) {
        return new Ui(this, e, r)
      }
    }
    return null
  }

  sameParent (e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset
  }

  max (e) {
    return e.pos > this.pos ? e : this
  }

  min (e) {
    return e.pos < this.pos ? e : this
  }

  toString () {
    let e = ''
    for (let n = 1; n <= this.depth; n++) {
      e +=
                (e ? '/' : '') +
                this.node(n).type.name +
                '_' +
                this.index(n - 1)
    }
    return e + ':' + this.parentOffset
  }

  static resolve (e, n) {
    if (!(n >= 0 && n <= e.content.size)) {
      throw new RangeError('Position ' + n + ' out of range')
    }
    const r = []
    let i = 0
    let o = n
    for (let s = e; ;) {
      const { index: l, offset: u } = s.content.findIndex(o)
      const d = o - u
      if ((r.push(s, l, i + u), !d || ((s = s.child(l)), s.isText))) {
        break
      }
      (o = d - 1), (i += u + 1)
    }
    return new t(n, r, o)
  }

  static resolveCached (e, n) {
    let r = Ey.get(e)
    if (r) {
      for (let o = 0; o < r.elts.length; o++) {
        const s = r.elts[o]
        if (s.pos == n) return s
      }
    } else Ey.set(e, (r = new sf()))
    const i = (r.elts[r.i] = t.resolve(e, n))
    return (r.i = (r.i + 1) % yO), i
  }
}
var sf = class {
  constructor () {
    (this.elts = []), (this.i = 0)
  }
}
var yO = 12
var Ey = new WeakMap()
var Ui = class {
  constructor (e, n, r) {
    (this.$from = e), (this.$to = n), (this.depth = r)
  }

  get start () {
    return this.$from.before(this.depth + 1)
  }

  get end () {
    return this.$to.after(this.depth + 1)
  }

  get parent () {
    return this.$from.node(this.depth)
  }

  get startIndex () {
    return this.$from.index(this.depth)
  }

  get endIndex () {
    return this.$to.indexAfter(this.depth)
  }
}
const EO = Object.create(null)
const $n = class t {
  constructor (e, n, r, i = Ge.none) {
    (this.type = e),
    (this.attrs = n),
    (this.marks = i),
    (this.content = r || K.empty)
  }

  get children () {
    return this.content.content
  }

  get nodeSize () {
    return this.isLeaf ? 1 : 2 + this.content.size
  }

  get childCount () {
    return this.content.childCount
  }

  child (e) {
    return this.content.child(e)
  }

  maybeChild (e) {
    return this.content.maybeChild(e)
  }

  forEach (e) {
    this.content.forEach(e)
  }

  nodesBetween (e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this)
  }

  descendants (e) {
    this.nodesBetween(0, this.content.size, e)
  }

  get textContent () {
    return this.isLeaf && this.type.spec.leafText
      ? this.type.spec.leafText(this)
      : this.textBetween(0, this.content.size, '')
  }

  textBetween (e, n, r, i) {
    return this.content.textBetween(e, n, r, i)
  }

  get firstChild () {
    return this.content.firstChild
  }

  get lastChild () {
    return this.content.lastChild
  }

  eq (e) {
    return this == e || (this.sameMarkup(e) && this.content.eq(e.content))
  }

  sameMarkup (e) {
    return this.hasMarkup(e.type, e.attrs, e.marks)
  }

  hasMarkup (e, n, r) {
    return (
      this.type == e &&
            Tl(this.attrs, n || e.defaultAttrs || EO) &&
            Ge.sameSet(this.marks, r || Ge.none)
    )
  }

  copy (e = null) {
    return e == this.content
      ? this
      : new t(this.type, this.attrs, e, this.marks)
  }

  mark (e) {
    return e == this.marks
      ? this
      : new t(this.type, this.attrs, this.content, e)
  }

  cut (e, n = this.content.size) {
    return e == 0 && n == this.content.size
      ? this
      : this.copy(this.content.cut(e, n))
  }

  slice (e, n = this.content.size, r = !1) {
    if (e == n) return Z.empty
    const i = this.resolve(e)
    const o = this.resolve(n)
    const s = r ? 0 : i.sharedDepth(n)
    const l = i.start(s)
    const d = i.node(s).content.cut(i.pos - l, o.pos - l)
    return new Z(d, i.depth - s, o.depth - s)
  }

  replace (e, n, r) {
    return gO(this.resolve(e), this.resolve(n), r)
  }

  nodeAt (e) {
    for (let n = this; ;) {
      const { index: r, offset: i } = n.content.findIndex(e)
      if (((n = n.maybeChild(r)), !n)) return null
      if (i == e || n.isText) return n
      e -= i + 1
    }
  }

  childAfter (e) {
    const { index: n, offset: r } = this.content.findIndex(e)
    return { node: this.content.maybeChild(n), index: n, offset: r }
  }

  childBefore (e) {
    if (e == 0) return { node: null, index: 0, offset: 0 }
    const { index: n, offset: r } = this.content.findIndex(e)
    if (r < e) {
      return { node: this.content.child(n), index: n, offset: r }
    }
    const i = this.content.child(n - 1)
    return { node: i, index: n - 1, offset: r - i.nodeSize }
  }

  resolve (e) {
    return Al.resolveCached(this, e)
  }

  resolveNoCache (e) {
    return Al.resolve(this, e)
  }

  rangeHasMark (e, n, r) {
    let i = !1
    return (
      n > e &&
                this.nodesBetween(
                  e,
                  n,
                  (o) => (r.isInSet(o.marks) && (i = !0), !i)
                ),
      i
    )
  }

  get isBlock () {
    return this.type.isBlock
  }

  get isTextblock () {
    return this.type.isTextblock
  }

  get inlineContent () {
    return this.type.inlineContent
  }

  get isInline () {
    return this.type.isInline
  }

  get isText () {
    return this.type.isText
  }

  get isLeaf () {
    return this.type.isLeaf
  }

  get isAtom () {
    return this.type.isAtom
  }

  toString () {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this)
    }
    let e = this.type.name
    return (
      this.content.size &&
                (e += '(' + this.content.toStringInner() + ')'),
      Ly(this.marks, e)
    )
  }

  contentMatchAt (e) {
    const n = this.type.contentMatch.matchFragment(this.content, 0, e)
    if (!n) {
      throw new Error(
        'Called contentMatchAt on a node with invalid content'
      )
    }
    return n
  }

  canReplace (e, n, r = K.empty, i = 0, o = r.childCount) {
    const s = this.contentMatchAt(e).matchFragment(r, i, o)
    const l = s && s.matchFragment(this.content, n)
    if (!l || !l.validEnd) return !1
    for (let u = i; u < o; u++) {
      if (!this.type.allowsMarks(r.child(u).marks)) return !1
    }
    return !0
  }

  canReplaceWith (e, n, r, i) {
    if (i && !this.type.allowsMarks(i)) return !1
    const o = this.contentMatchAt(e).matchType(r)
    const s = o && o.matchFragment(this.content, n)
    return s ? s.validEnd : !1
  }

  canAppend (e) {
    return e.content.size
      ? this.canReplace(this.childCount, this.childCount, e.content)
      : this.type.compatibleContent(e.type)
  }

  check () {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs)
    let e = Ge.none
    for (let n = 0; n < this.marks.length; n++) {
      const r = this.marks[n]
      r.type.checkAttrs(r.attrs), (e = r.addToSet(e))
    }
    if (!Ge.sameSet(e, this.marks)) {
      throw new RangeError(
                `Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`
      )
    }
    this.content.forEach((n) => n.check())
  }

  toJSON () {
    const e = { type: this.type.name }
    for (const n in this.attrs) {
      e.attrs = this.attrs
      break
    }
    return (
      this.content.size && (e.content = this.content.toJSON()),
      this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
      e
    )
  }

  static fromJSON (e, n) {
    if (!n) throw new RangeError('Invalid input for Node.fromJSON')
    let r
    if (n.marks) {
      if (!Array.isArray(n.marks)) {
        throw new RangeError('Invalid mark data for Node.fromJSON')
      }
      r = n.marks.map(e.markFromJSON)
    }
    if (n.type == 'text') {
      if (typeof n.text !== 'string') {
        throw new RangeError('Invalid text node in JSON')
      }
      return e.text(n.text, r)
    }
    const i = K.fromJSON(e, n.content)
    const o = e.nodeType(n.type).create(n.attrs, i, r)
    return o.type.checkAttrs(o.attrs), o
  }
}
$n.prototype.text = void 0
const af = class t extends $n {
  constructor (e, n, r, i) {
    if ((super(e, n, null, i), !r)) {
      throw new RangeError('Empty text nodes are not allowed')
    }
    this.text = r
  }

  toString () {
    return this.type.spec.toDebugString
      ? this.type.spec.toDebugString(this)
      : Ly(this.marks, JSON.stringify(this.text))
  }

  get textContent () {
    return this.text
  }

  textBetween (e, n) {
    return this.text.slice(e, n)
  }

  get nodeSize () {
    return this.text.length
  }

  mark (e) {
    return e == this.marks
      ? this
      : new t(this.type, this.attrs, this.text, e)
  }

  withText (e) {
    return e == this.text
      ? this
      : new t(this.type, this.attrs, e, this.marks)
  }

  cut (e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length
      ? this
      : this.withText(this.text.slice(e, n))
  }

  eq (e) {
    return this.sameMarkup(e) && this.text == e.text
  }

  toJSON () {
    const e = super.toJSON()
    return (e.text = this.text), e
  }
}
function Ly (t, e) {
  for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + '(' + e + ')'
  return e
}
const Wi = class t {
  constructor (e) {
    (this.validEnd = e), (this.next = []), (this.wrapCache = [])
  }

  static parse (e, n) {
    const r = new lf(e, n)
    if (r.next == null) return t.empty
    const i = Py(r)
    r.next && r.err('Unexpected trailing text')
    const o = CO(TO(i))
    return AO(o, r), o
  }

  matchType (e) {
    for (let n = 0; n < this.next.length; n++) {
      if (this.next[n].type == e) return this.next[n].next
    }
    return null
  }

  matchFragment (e, n = 0, r = e.childCount) {
    let i = this
    for (let o = n; i && o < r; o++) i = i.matchType(e.child(o).type)
    return i
  }

  get inlineContent () {
    return this.next.length != 0 && this.next[0].type.isInline
  }

  get defaultType () {
    for (let e = 0; e < this.next.length; e++) {
      const { type: n } = this.next[e]
      if (!(n.isText || n.hasRequiredAttrs())) return n
    }
    return null
  }

  compatible (e) {
    for (let n = 0; n < this.next.length; n++) {
      for (let r = 0; r < e.next.length; r++) {
        if (this.next[n].type == e.next[r].type) return !0
      }
    }
    return !1
  }

  fillBefore (e, n = !1, r = 0) {
    const i = [this]
    function o (s, l) {
      const u = s.matchFragment(e, r)
      if (u && (!n || u.validEnd)) {
        return K.from(l.map((d) => d.createAndFill()))
      }
      for (let d = 0; d < s.next.length; d++) {
        const { type: f, next: h } = s.next[d]
        if (!(f.isText || f.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h)
          const m = o(h, l.concat(f))
          if (m) return m
        }
      }
      return null
    }
    return o(this, [])
  }

  findWrapping (e) {
    for (let r = 0; r < this.wrapCache.length; r += 2) {
      if (this.wrapCache[r] == e) return this.wrapCache[r + 1]
    }
    const n = this.computeWrapping(e)
    return this.wrapCache.push(e, n), n
  }

  computeWrapping (e) {
    const n = Object.create(null)
    const r = [{ match: this, type: null, via: null }]
    for (; r.length;) {
      const i = r.shift()
      const o = i.match
      if (o.matchType(e)) {
        const s = []
        for (let l = i; l.type; l = l.via) s.push(l.type)
        return s.reverse()
      }
      for (let s = 0; s < o.next.length; s++) {
        const { type: l, next: u } = o.next[s]
        !l.isLeaf &&
                    !l.hasRequiredAttrs() &&
                    !(l.name in n) &&
                    (!i.type || u.validEnd) &&
                    (r.push({ match: l.contentMatch, type: l, via: i }),
                    (n[l.name] = !0))
      }
    }
    return null
  }

  get edgeCount () {
    return this.next.length
  }

  edge (e) {
    if (e >= this.next.length) {
      throw new RangeError(
                `There's no ${e}th edge in this content match`
      )
    }
    return this.next[e]
  }

  toString () {
    const e = []
    function n (r) {
      e.push(r)
      for (let i = 0; i < r.next.length; i++) {
        e.indexOf(r.next[i].next) == -1 && n(r.next[i].next)
      }
    }
    return (
      n(this),
      e.map((r, i) => {
        let o = i + (r.validEnd ? '*' : ' ') + ' '
        for (let s = 0; s < r.next.length; s++) {
          o +=
                        (s ? ', ' : '') +
                        r.next[s].type.name +
                        '->' +
                        e.indexOf(r.next[s].next)
        }
        return o
      }).join(`
`)
    )
  }
}
Wi.empty = new Wi(!0)
var lf = class {
  constructor (e, n) {
    (this.string = e),
    (this.nodeTypes = n),
    (this.inline = null),
    (this.pos = 0),
    (this.tokens = e.split(/\s*(?=\b|\W|$)/)),
    this.tokens[this.tokens.length - 1] == '' && this.tokens.pop(),
    this.tokens[0] == '' && this.tokens.shift()
  }

  get next () {
    return this.tokens[this.pos]
  }

  eat (e) {
    return this.next == e && (this.pos++ || !0)
  }

  err (e) {
    throw new SyntaxError(
      e + " (in content expression '" + this.string + "')"
    )
  }
}
function Py (t) {
  const e = []
  do e.push(vO(t))
  while (t.eat('|'))
  return e.length == 1 ? e[0] : { type: 'choice', exprs: e }
}
function vO (t) {
  const e = []
  do e.push(wO(t))
  while (t.next && t.next != ')' && t.next != '|')
  return e.length == 1 ? e[0] : { type: 'seq', exprs: e }
}
function wO (t) {
  let e = SO(t)
  for (;;) {
    if (t.eat('+')) e = { type: 'plus', expr: e }
    else if (t.eat('*')) e = { type: 'star', expr: e }
    else if (t.eat('?')) e = { type: 'opt', expr: e }
    else if (t.eat('{')) e = xO(t, e)
    else break
  }
  return e
}
function vy (t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'")
  const e = Number(t.next)
  return t.pos++, e
}
function xO (t, e) {
  const n = vy(t)
  let r = n
  return (
    t.eat(',') && (t.next != '}' ? (r = vy(t)) : (r = -1)),
    t.eat('}') || t.err('Unclosed braced range'),
    { type: 'range', min: n, max: r, expr: e }
  )
}
function _O (t, e) {
  const n = t.nodeTypes
  const r = n[e]
  if (r) return [r]
  const i = []
  for (const o in n) {
    const s = n[o]
    s.isInGroup(e) && i.push(s)
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i
}
function SO (t) {
  if (t.eat('(')) {
    const e = Py(t)
    return t.eat(')') || t.err('Missing closing paren'), e
  } else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'")
  else {
    const e = _O(t, t.next).map(
      (n) => (
        t.inline == null
          ? (t.inline = n.isInline)
          : t.inline != n.isInline &&
                      t.err('Mixing inline and block content'),
        { type: 'name', value: n }
      )
    )
    return t.pos++, e.length == 1 ? e[0] : { type: 'choice', exprs: e }
  }
}
function TO (t) {
  const e = [[]]
  return i(o(t, 0), n()), e
  function n () {
    return e.push([]) - 1
  }
  function r (s, l, u) {
    const d = { term: u, to: l }
    return e[s].push(d), d
  }
  function i (s, l) {
    s.forEach((u) => (u.to = l))
  }
  function o (s, l) {
    if (s.type == 'choice') {
      return s.exprs.reduce((u, d) => u.concat(o(d, l)), [])
    }
    if (s.type == 'seq') {
      for (let u = 0; ; u++) {
        const d = o(s.exprs[u], l)
        if (u == s.exprs.length - 1) return d
        i(d, (l = n()))
      }
    } else if (s.type == 'star') {
      const u = n()
      return r(l, u), i(o(s.expr, u), u), [r(u)]
    } else if (s.type == 'plus') {
      const u = n()
      return i(o(s.expr, l), u), i(o(s.expr, u), u), [r(u)]
    } else {
      if (s.type == 'opt') return [r(l)].concat(o(s.expr, l))
      if (s.type == 'range') {
        let u = l
        for (let d = 0; d < s.min; d++) {
          const f = n()
          i(o(s.expr, u), f), (u = f)
        }
        if (s.max == -1) i(o(s.expr, u), u)
        else {
          for (let d = s.min; d < s.max; d++) {
            const f = n()
            r(u, f), i(o(s.expr, u), f), (u = f)
          }
        }
        return [r(u)]
      } else {
        if (s.type == 'name') return [r(l, void 0, s.value)]
        throw new Error('Unknown expr type')
      }
    }
  }
}
function By (t, e) {
  return e - t
}
function wy (t, e) {
  const n = []
  return r(e), n.sort(By)
  function r (i) {
    const o = t[i]
    if (o.length == 1 && !o[0].term) return r(o[0].to)
    n.push(i)
    for (let s = 0; s < o.length; s++) {
      const { term: l, to: u } = o[s]
      !l && n.indexOf(u) == -1 && r(u)
    }
  }
}
function CO (t) {
  const e = Object.create(null)
  return n(wy(t, 0))
  function n (r) {
    const i = []
    r.forEach((s) => {
      t[s].forEach(({ term: l, to: u }) => {
        if (!l) return
        let d
        for (let f = 0; f < i.length; f++) {
          i[f][0] == l && (d = i[f][1])
        }
        wy(t, u).forEach((f) => {
          d || i.push([l, (d = [])]), d.indexOf(f) == -1 && d.push(f)
        })
      })
    })
    const o = (e[r.join(',')] = new Wi(r.indexOf(t.length - 1) > -1))
    for (let s = 0; s < i.length; s++) {
      const l = i[s][1].sort(By)
      o.next.push({ type: i[s][0], next: e[l.join(',')] || n(l) })
    }
    return o
  }
}
function AO (t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    const i = r[n]
    let o = !i.validEnd
    const s = []
    for (let l = 0; l < i.next.length; l++) {
      const { type: u, next: d } = i.next[l]
      s.push(u.name),
      o && !(u.isText || u.hasRequiredAttrs()) && (o = !1),
      r.indexOf(d) == -1 && r.push(d)
    }
    o &&
            e.err(
              'Only non-generatable nodes (' +
                    s.join(', ') +
                    ') in a required position (see https://prosemirror.net/docs/guide/#generatable)'
            )
  }
}
function Fy (t) {
  const e = Object.create(null)
  for (const n in t) {
    const r = t[n]
    if (!r.hasDefault) return null
    e[n] = r.default
  }
  return e
}
function Hy (t, e) {
  const n = Object.create(null)
  for (const r in t) {
    let i = e && e[r]
    if (i === void 0) {
      const o = t[r]
      if (o.hasDefault) i = o.default
      else throw new RangeError('No value supplied for attribute ' + r)
    }
    n[r] = i
  }
  return n
}
function $y (t, e, n, r) {
  for (const i in e) {
    if (!(i in t)) {
      throw new RangeError(
                `Unsupported attribute ${i} for ${n} of type ${i}`
      )
    }
  }
  for (const i in t) {
    const o = t[i]
    o.validate && o.validate(e[i])
  }
}
function zy (t, e) {
  const n = Object.create(null)
  if (e) for (const r in e) n[r] = new cf(t, r, e[r])
  return n
}
const Ml = class t {
  constructor (e, n, r) {
    (this.name = e),
    (this.schema = n),
    (this.spec = r),
    (this.markSet = null),
    (this.groups = r.group ? r.group.split(' ') : []),
    (this.attrs = zy(e, r.attrs)),
    (this.defaultAttrs = Fy(this.attrs)),
    (this.contentMatch = null),
    (this.inlineContent = null),
    (this.isBlock = !(r.inline || e == 'text')),
    (this.isText = e == 'text')
  }

  get isInline () {
    return !this.isBlock
  }

  get isTextblock () {
    return this.isBlock && this.inlineContent
  }

  get isLeaf () {
    return this.contentMatch == Wi.empty
  }

  get isAtom () {
    return this.isLeaf || !!this.spec.atom
  }

  isInGroup (e) {
    return this.groups.indexOf(e) > -1
  }

  get whitespace () {
    return this.spec.whitespace || (this.spec.code ? 'pre' : 'normal')
  }

  hasRequiredAttrs () {
    for (const e in this.attrs) if (this.attrs[e].isRequired) return !0
    return !1
  }

  compatibleContent (e) {
    return this == e || this.contentMatch.compatible(e.contentMatch)
  }

  computeAttrs (e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : Hy(this.attrs, e)
  }

  create (e = null, n, r) {
    if (this.isText) {
      throw new Error("NodeType.create can't construct text nodes")
    }
    return new $n(this, this.computeAttrs(e), K.from(n), Ge.setFrom(r))
  }

  createChecked (e = null, n, r) {
    return (
      (n = K.from(n)),
      this.checkContent(n),
      new $n(this, this.computeAttrs(e), n, Ge.setFrom(r))
    )
  }

  createAndFill (e = null, n, r) {
    if (((e = this.computeAttrs(e)), (n = K.from(n)), n.size)) {
      const s = this.contentMatch.fillBefore(n)
      if (!s) return null
      n = s.append(n)
    }
    const i = this.contentMatch.matchFragment(n)
    const o = i && i.fillBefore(K.empty, !0)
    return o ? new $n(this, e, n.append(o), Ge.setFrom(r)) : null
  }

  validContent (e) {
    const n = this.contentMatch.matchFragment(e)
    if (!n || !n.validEnd) return !1
    for (let r = 0; r < e.childCount; r++) {
      if (!this.allowsMarks(e.child(r).marks)) return !1
    }
    return !0
  }

  checkContent (e) {
    if (!this.validContent(e)) {
      throw new RangeError(
                `Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`
      )
    }
  }

  checkAttrs (e) {
    $y(this.attrs, e, 'node', this.name)
  }

  allowsMarkType (e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1
  }

  allowsMarks (e) {
    if (this.markSet == null) return !0
    for (let n = 0; n < e.length; n++) {
      if (!this.allowsMarkType(e[n].type)) return !1
    }
    return !0
  }

  allowedMarks (e) {
    if (this.markSet == null) return e
    let n
    for (let r = 0; r < e.length; r++) {
      this.allowsMarkType(e[r].type)
        ? n && n.push(e[r])
        : n || (n = e.slice(0, r))
    }
    return n ? (n.length ? n : Ge.none) : e
  }

  static compile (e, n) {
    const r = Object.create(null)
    e.forEach((o, s) => (r[o] = new t(o, n, s)))
    const i = n.spec.topNode || 'doc'
    if (!r[i]) {
      throw new RangeError(
        "Schema is missing its top node type ('" + i + "')"
      )
    }
    if (!r.text) throw new RangeError("Every schema needs a 'text' type")
    for (const o in r.text.attrs) {
      throw new RangeError(
        'The text node type should not have attributes'
      )
    }
    return r
  }
}
function MO (t, e, n) {
  const r = n.split('|')
  return (i) => {
    const o = i === null ? 'null' : typeof i
    if (r.indexOf(o) < 0) {
      throw new RangeError(
                `Expected value of type ${r} for attribute ${e} on type ${t}, got ${o}`
      )
    }
  }
}
var cf = class {
  constructor (e, n, r) {
    (this.hasDefault = Object.prototype.hasOwnProperty.call(r, 'default')),
    (this.default = r.default),
    (this.validate =
                typeof r.validate === 'string'
                  ? MO(e, n, r.validate)
                  : r.validate)
  }

  get isRequired () {
    return !this.hasDefault
  }
}
const Ps = class t {
  constructor (e, n, r, i) {
    (this.name = e),
    (this.rank = n),
    (this.schema = r),
    (this.spec = i),
    (this.attrs = zy(e, i.attrs)),
    (this.excluded = null)
    const o = Fy(this.attrs)
    this.instance = o ? new Ge(this, o) : null
  }

  create (e = null) {
    return !e && this.instance
      ? this.instance
      : new Ge(this, Hy(this.attrs, e))
  }

  static compile (e, n) {
    const r = Object.create(null)
    let i = 0
    return e.forEach((o, s) => (r[o] = new t(o, i++, n, s))), r
  }

  removeFromSet (e) {
    for (let n = 0; n < e.length; n++) {
      e[n].type == this &&
                ((e = e.slice(0, n).concat(e.slice(n + 1))), n--)
    }
    return e
  }

  isInSet (e) {
    for (let n = 0; n < e.length; n++) {
      if (e[n].type == this) return e[n]
    }
  }

  checkAttrs (e) {
    $y(this.attrs, e, 'mark', this.name)
  }

  excludes (e) {
    return this.excluded.indexOf(e) > -1
  }
}
const Bs = class {
  constructor (e) {
    (this.linebreakReplacement = null), (this.cached = Object.create(null))
    const n = (this.spec = {})
    for (const i in e) n[i] = e[i];
    (n.nodes = tf.from(e.nodes)),
    (n.marks = tf.from(e.marks || {})),
    (this.nodes = Ml.compile(this.spec.nodes, this)),
    (this.marks = Ps.compile(this.spec.marks, this))
    const r = Object.create(null)
    for (const i in this.nodes) {
      if (i in this.marks) {
        throw new RangeError(i + ' can not be both a node and a mark')
      }
      const o = this.nodes[i]
      const s = o.spec.content || ''
      const l = o.spec.marks
      if (
        ((o.contentMatch = r[s] || (r[s] = Wi.parse(s, this.nodes))),
        (o.inlineContent = o.contentMatch.inlineContent),
        o.spec.linebreakReplacement)
      ) {
        if (this.linebreakReplacement) {
          throw new RangeError('Multiple linebreak nodes defined')
        }
        if (!o.isInline || !o.isLeaf) {
          throw new RangeError(
            'Linebreak replacement nodes must be inline leaf nodes'
          )
        }
        this.linebreakReplacement = o
      }
      o.markSet =
                l == '_'
                  ? null
                  : l
                    ? xy(this, l.split(' '))
                    : l == '' || !o.inlineContent
                      ? []
                      : null
    }
    for (const i in this.marks) {
      const o = this.marks[i]
      const s = o.spec.excludes
      o.excluded =
                s == null ? [o] : s == '' ? [] : xy(this, s.split(' '))
    }
    (this.nodeFromJSON = this.nodeFromJSON.bind(this)),
    (this.markFromJSON = this.markFromJSON.bind(this)),
    (this.topNodeType = this.nodes[this.spec.topNode || 'doc']),
    (this.cached.wrappings = Object.create(null))
  }

  node (e, n = null, r, i) {
    if (typeof e === 'string') e = this.nodeType(e)
    else if (e instanceof Ml) {
      if (e.schema != this) {
        throw new RangeError(
          'Node type from different schema used (' + e.name + ')'
        )
      }
    } else throw new RangeError('Invalid node type: ' + e)
    return e.createChecked(n, r, i)
  }

  text (e, n) {
    const r = this.nodes.text
    return new af(r, r.defaultAttrs, e, Ge.setFrom(n))
  }

  mark (e, n) {
    return typeof e === 'string' && (e = this.marks[e]), e.create(n)
  }

  nodeFromJSON (e) {
    return $n.fromJSON(this, e)
  }

  markFromJSON (e) {
    return Ge.fromJSON(this, e)
  }

  nodeType (e) {
    const n = this.nodes[e]
    if (!n) throw new RangeError('Unknown node type: ' + e)
    return n
  }
}
function xy (t, e) {
  const n = []
  for (let r = 0; r < e.length; r++) {
    const i = e[r]
    const o = t.marks[i]
    let s = o
    if (o) n.push(o)
    else {
      for (const l in t.marks) {
        const u = t.marks[l];
        (i == '_' ||
                    (u.spec.group &&
                        u.spec.group.split(' ').indexOf(i) > -1)) &&
                    n.push((s = u))
      }
    }
    if (!s) throw new SyntaxError("Unknown mark type: '" + e[r] + "'")
  }
  return n
}
function NO (t) {
  return t.tag != null
}
function kO (t) {
  return t.style != null
}
const Rr = class t {
  constructor (e, n) {
    (this.schema = e),
    (this.rules = n),
    (this.tags = []),
    (this.styles = [])
    const r = (this.matchedStyles = [])
    n.forEach((i) => {
      if (NO(i)) this.tags.push(i)
      else if (kO(i)) {
        const o = /[^=]*/.exec(i.style)[0]
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i)
      }
    }),
    (this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1
      const o = e.nodes[i.node]
      return o.contentMatch.matchType(o)
    }))
  }

  parse (e, n = {}) {
    const r = new Nl(this, n, !1)
    return r.addAll(e, Ge.none, n.from, n.to), r.finish()
  }

  parseSlice (e, n = {}) {
    const r = new Nl(this, n, !0)
    return r.addAll(e, Ge.none, n.from, n.to), Z.maxOpen(r.finish())
  }

  matchTag (e, n, r) {
    for (
      let i = r ? this.tags.indexOf(r) + 1 : 0;
      i < this.tags.length;
      i++
    ) {
      const o = this.tags[i]
      if (
        IO(e, o.tag) &&
                (o.namespace === void 0 || e.namespaceURI == o.namespace) &&
                (!o.context || n.matchesContext(o.context))
      ) {
        if (o.getAttrs) {
          const s = o.getAttrs(e)
          if (s === !1) continue
          o.attrs = s || void 0
        }
        return o
      }
    }
  }

  matchStyle (e, n, r, i) {
    for (
      let o = i ? this.styles.indexOf(i) + 1 : 0;
      o < this.styles.length;
      o++
    ) {
      const s = this.styles[o]
      const l = s.style
      if (
        !(
          l.indexOf(e) != 0 ||
                    (s.context && !r.matchesContext(s.context)) ||
                    (l.length > e.length &&
                        (l.charCodeAt(e.length) != 61 ||
                            l.slice(e.length + 1) != n))
        )
      ) {
        if (s.getAttrs) {
          const u = s.getAttrs(n)
          if (u === !1) continue
          s.attrs = u || void 0
        }
        return s
      }
    }
  }

  static schemaRules (e) {
    const n = []
    function r (i) {
      const o = i.priority == null ? 50 : i.priority
      let s = 0
      for (; s < n.length; s++) {
        const l = n[s]
        if ((l.priority == null ? 50 : l.priority) < o) break
      }
      n.splice(s, 0, i)
    }
    for (const i in e.marks) {
      const o = e.marks[i].spec.parseDOM
      o &&
                o.forEach((s) => {
                  r((s = Sy(s))),
                  s.mark || s.ignore || s.clearMark || (s.mark = i)
                })
    }
    for (const i in e.nodes) {
      const o = e.nodes[i].spec.parseDOM
      o &&
                o.forEach((s) => {
                  r((s = Sy(s))),
                  s.node || s.ignore || s.mark || (s.node = i)
                })
    }
    return n
  }

  static fromSchema (e) {
    return (
      e.cached.domParser ||
            (e.cached.domParser = new t(e, t.schemaRules(e)))
    )
  }
}
const Uy = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}
const OO = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}
const Wy = { ol: !0, ul: !0 }
const Fs = 1
const uf = 2
const Ls = 4
function _y (t, e, n) {
  return e != null
    ? (e ? Fs : 0) | (e === 'full' ? uf : 0)
    : t && t.whitespace == 'pre'
      ? Fs | uf
      : n & ~Ls
}
const Lo = class {
  constructor (e, n, r, i, o, s) {
    (this.type = e),
    (this.attrs = n),
    (this.marks = r),
    (this.solid = i),
    (this.options = s),
    (this.content = []),
    (this.activeMarks = Ge.none),
    (this.match = o || (s & Ls ? null : e.contentMatch))
  }

  findWrapping (e) {
    if (!this.match) {
      if (!this.type) return []
      const n = this.type.contentMatch.fillBefore(K.from(e))
      if (n) this.match = this.type.contentMatch.matchFragment(n)
      else {
        const r = this.type.contentMatch
        let i
        return (i = r.findWrapping(e.type))
          ? ((this.match = r), i)
          : null
      }
    }
    return this.match.findWrapping(e.type)
  }

  finish (e) {
    if (!(this.options & Fs)) {
      const r = this.content[this.content.length - 1]
      let i
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        const o = r
        r.text.length == i[0].length
          ? this.content.pop()
          : (this.content[this.content.length - 1] = o.withText(
              o.text.slice(0, o.text.length - i[0].length)
            ))
      }
    }
    let n = K.from(this.content)
    return (
      !e &&
                this.match &&
                (n = n.append(this.match.fillBefore(K.empty, !0))),
      this.type ? this.type.create(this.attrs, n, this.marks) : n
    )
  }

  inlineContext (e) {
    return this.type
      ? this.type.inlineContent
      : this.content.length
        ? this.content[0].isInline
        : e.parentNode &&
                !Uy.hasOwnProperty(e.parentNode.nodeName.toLowerCase())
  }
}
var Nl = class {
  constructor (e, n, r) {
    (this.parser = e),
    (this.options = n),
    (this.isOpen = r),
    (this.open = 0),
    (this.localPreserveWS = !1)
    const i = n.topNode
    let o
    const s = _y(null, n.preserveWhitespace, 0) | (r ? Ls : 0)
    i
      ? (o = new Lo(
          i.type,
          i.attrs,
          Ge.none,
          !0,
          n.topMatch || i.type.contentMatch,
          s
        ))
      : r
        ? (o = new Lo(null, null, Ge.none, !0, null, s))
        : (o = new Lo(e.schema.topNodeType, null, Ge.none, !0, null, s)),
    (this.nodes = [o]),
    (this.find = n.findPositions),
    (this.needsBlock = !1)
  }

  get top () {
    return this.nodes[this.open]
  }

  addDOM (e, n) {
    e.nodeType == 3
      ? this.addTextNode(e, n)
      : e.nodeType == 1 && this.addElement(e, n)
  }

  addTextNode (e, n) {
    let r = e.nodeValue
    const i = this.top
    const o =
            i.options & uf
              ? 'full'
              : this.localPreserveWS || (i.options & Fs) > 0
    if (o === 'full' || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o) {
        o !== 'full'
          ? (r = r.replace(/\r?\n|\r/g, ' '))
          : (r = r.replace(
              /\r\n?/g,
                          `
`
            ))
      } else if (
        ((r = r.replace(/[ \t\r\n\u000c]+/g, ' ')),
        /^[ \t\r\n\u000c]/.test(r) &&
                    this.open == this.nodes.length - 1)
      ) {
        const s = i.content[i.content.length - 1]
        const l = e.previousSibling;
        (!s ||
                    (l && l.nodeName == 'BR') ||
                    (s.isText && /[ \t\r\n\u000c]$/.test(s.text))) &&
                    (r = r.slice(1))
      }
      r && this.insertNode(this.parser.schema.text(r), n),
      this.findInText(e)
    } else this.findInside(e)
  }

  addElement (e, n, r) {
    const i = this.localPreserveWS
    let o = this.top;
    (e.tagName == 'PRE' || /pre/.test(e.style && e.style.whiteSpace)) &&
            (this.localPreserveWS = !0)
    const s = e.nodeName.toLowerCase()
    let l
    Wy.hasOwnProperty(s) && this.parser.normalizeLists && RO(e)
    const u =
            (this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
            (l = this.parser.matchTag(e, this, r))
    e: if (u ? u.ignore : OO.hasOwnProperty(s)) {
      this.findInside(e), this.ignoreFallback(e, n)
    } else if (!u || u.skip || u.closeParent) {
      u && u.closeParent
        ? (this.open = Math.max(0, this.open - 1))
        : u && u.skip.nodeType && (e = u.skip)
      let d
      const f = this.needsBlock
      if (Uy.hasOwnProperty(s)) {
        o.content.length &&
                    o.content[0].isInline &&
                    this.open &&
                    (this.open--, (o = this.top)),
        (d = !0),
        o.type || (this.needsBlock = !0)
      } else if (!e.firstChild) {
        this.leafFallback(e, n)
        break e
      }
      const h = u && u.skip ? n : this.readStyles(e, n)
      h && this.addAll(e, h), d && this.sync(o), (this.needsBlock = f)
    } else {
      const d = this.readStyles(e, n)
      d &&
                this.addElementByRule(e, u, d, u.consuming === !1 ? l : void 0)
    }
    this.localPreserveWS = i
  }

  leafFallback (e, n) {
    e.nodeName == 'BR' &&
            this.top.type &&
            this.top.type.inlineContent &&
            this.addTextNode(
              e.ownerDocument.createTextNode(`
`),
              n
            )
  }

  ignoreFallback (e, n) {
    e.nodeName == 'BR' &&
            (!this.top.type || !this.top.type.inlineContent) &&
            this.findPlace(this.parser.schema.text('-'), n)
  }

  readStyles (e, n) {
    const r = e.style
    if (r && r.length) {
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        const o = this.parser.matchedStyles[i]
        const s = r.getPropertyValue(o)
        if (s) {
          for (let l = void 0; ;) {
            const u = this.parser.matchStyle(o, s, this, l)
            if (!u) break
            if (u.ignore) return null
            if (
              (u.clearMark
                ? (n = n.filter((d) => !u.clearMark(d)))
                : (n = n.concat(
                    this.parser.schema.marks[u.mark].create(
                      u.attrs
                    )
                  )),
              u.consuming === !1)
            ) {
              l = u
            } else break
          }
        }
      }
    }
    return n
  }

  addElementByRule (e, n, r, i) {
    let o, s
    if (n.node) {
      if (((s = this.parser.schema.nodes[n.node]), s.isLeaf)) {
        this.insertNode(s.create(n.attrs), r) ||
                    this.leafFallback(e, r)
      } else {
        const u = this.enter(
          s,
          n.attrs || null,
          r,
          n.preserveWhitespace
        )
        u && ((o = !0), (r = u))
      }
    } else {
      const u = this.parser.schema.marks[n.mark]
      r = r.concat(u.create(n.attrs))
    }
    const l = this.top
    if (s && s.isLeaf) this.findInside(e)
    else if (i) this.addElement(e, r, i)
    else if (n.getContent) {
      this.findInside(e),
      n
        .getContent(e, this.parser.schema)
        .forEach((u) => this.insertNode(u, r))
    } else {
      let u = e
      typeof n.contentElement === 'string'
        ? (u = e.querySelector(n.contentElement))
        : typeof n.contentElement === 'function'
          ? (u = n.contentElement(e))
          : n.contentElement && (u = n.contentElement),
      this.findAround(e, u, !0),
      this.addAll(u, r),
      this.findAround(e, u, !1)
    }
    o && this.sync(l) && this.open--
  }

  addAll (e, n, r, i) {
    let o = r || 0
    for (
      let s = r ? e.childNodes[r] : e.firstChild,
        l = i == null ? null : e.childNodes[i];
      s != l;
      s = s.nextSibling, ++o
    ) {
      this.findAtPoint(e, o), this.addDOM(s, n)
    }
    this.findAtPoint(e, o)
  }

  findPlace (e, n) {
    let r, i
    for (let o = this.open; o >= 0; o--) {
      const s = this.nodes[o]
      const l = s.findWrapping(e)
      if (
        (l &&
                    (!r || r.length > l.length) &&
                    ((r = l), (i = s), !l.length)) ||
                s.solid
      ) {
        break
      }
    }
    if (!r) return null
    this.sync(i)
    for (let o = 0; o < r.length; o++) {
      n = this.enterInner(r[o], null, n, !1)
    }
    return n
  }

  insertNode (e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      const i = this.textblockFromContext()
      i && (n = this.enterInner(i, null, n))
    }
    const r = this.findPlace(e, n)
    if (r) {
      this.closeExtra()
      const i = this.top
      i.match && (i.match = i.match.matchType(e.type))
      let o = Ge.none
      for (const s of r.concat(e.marks)) {
        (i.type ? i.type.allowsMarkType(s.type) : Ty(s.type, e.type)) &&
                    (o = s.addToSet(o))
      }
      return i.content.push(e.mark(o)), !0
    }
    return !1
  }

  enter (e, n, r, i) {
    let o = this.findPlace(e.create(n), r)
    return o && (o = this.enterInner(e, n, r, !0, i)), o
  }

  enterInner (e, n, r, i = !1, o) {
    this.closeExtra()
    const s = this.top
    s.match = s.match && s.match.matchType(e)
    let l = _y(e, o, s.options)
    s.options & Ls && s.content.length == 0 && (l |= Ls)
    let u = Ge.none
    return (
      (r = r.filter((d) =>
        (s.type ? s.type.allowsMarkType(d.type) : Ty(d.type, e))
          ? ((u = d.addToSet(u)), !1)
          : !0
      )),
      this.nodes.push(new Lo(e, n, u, i, null, l)),
      this.open++,
      r
    )
  }

  closeExtra (e = !1) {
    let n = this.nodes.length - 1
    if (n > this.open) {
      for (; n > this.open; n--) {
        this.nodes[n - 1].content.push(this.nodes[n].finish(e))
      }
      this.nodes.length = this.open + 1
    }
  }

  finish () {
    return (
      (this.open = 0),
      this.closeExtra(this.isOpen),
      this.nodes[0].finish(!!(this.isOpen || this.options.topOpen))
    )
  }

  sync (e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e) return (this.open = n), !0
      this.localPreserveWS && (this.nodes[n].options |= Fs)
    }
    return !1
  }

  get currentPos () {
    this.closeExtra()
    let e = 0
    for (let n = this.open; n >= 0; n--) {
      const r = this.nodes[n].content
      for (let i = r.length - 1; i >= 0; i--) e += r[i].nodeSize
      n && e++
    }
    return e
  }

  findAtPoint (e, n) {
    if (this.find) {
      for (let r = 0; r < this.find.length; r++) {
        this.find[r].node == e &&
                    this.find[r].offset == n &&
                    (this.find[r].pos = this.currentPos)
      }
    }
  }

  findInside (e) {
    if (this.find) {
      for (let n = 0; n < this.find.length; n++) {
        this.find[n].pos == null &&
                    e.nodeType == 1 &&
                    e.contains(this.find[n].node) &&
                    (this.find[n].pos = this.currentPos)
      }
    }
  }

  findAround (e, n, r) {
    if (e != n && this.find) {
      for (let i = 0; i < this.find.length; i++) {
        this.find[i].pos == null &&
                    e.nodeType == 1 &&
                    e.contains(this.find[i].node) &&
                    n.compareDocumentPosition(this.find[i].node) &
                        (r ? 2 : 4) &&
                    (this.find[i].pos = this.currentPos)
      }
    }
  }

  findInText (e) {
    if (this.find) {
      for (let n = 0; n < this.find.length; n++) {
        this.find[n].node == e &&
                    (this.find[n].pos =
                        this.currentPos -
                        (e.nodeValue.length - this.find[n].offset))
      }
    }
  }

  matchesContext (e) {
    if (e.indexOf('|') > -1) {
      return e.split(/\s*\|\s*/).some(this.matchesContext, this)
    }
    const n = e.split('/')
    const r = this.options.context
    const i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type)
    const o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1)
    const s = (l, u) => {
      for (; l >= 0; l--) {
        const d = n[l]
        if (d == '') {
          if (l == n.length - 1 || l == 0) continue
          for (; u >= o; u--) if (s(l - 1, u)) return !0
          return !1
        } else {
          const f =
                        u > 0 || (u == 0 && i)
                          ? this.nodes[u].type
                          : r && u >= o
                            ? r.node(u - o).type
                            : null
          if (!f || (f.name != d && !f.isInGroup(d))) {
            return !1
          }
          u--
        }
      }
      return !0
    }
    return s(n.length - 1, this.open)
  }

  textblockFromContext () {
    const e = this.options.context
    if (e) {
      for (let n = e.depth; n >= 0; n--) {
        const r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType
        if (r && r.isTextblock && r.defaultAttrs) return r
      }
    }
    for (const n in this.parser.schema.nodes) {
      const r = this.parser.schema.nodes[n]
      if (r.isTextblock && r.defaultAttrs) return r
    }
  }
}
function RO (t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    const r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null
    r && Wy.hasOwnProperty(r) && n
      ? (n.appendChild(e), (e = n))
      : r == 'li'
        ? (n = e)
        : r && (n = null)
  }
}
function IO (t, e) {
  return (
    t.matches ||
        t.msMatchesSelector ||
        t.webkitMatchesSelector ||
        t.mozMatchesSelector
  ).call(t, e)
}
function Sy (t) {
  const e = {}
  for (const n in t) e[n] = t[n]
  return e
}
function Ty (t, e) {
  const n = e.schema.nodes
  for (const r in n) {
    const i = n[r]
    if (!i.allowsMarkType(t)) continue
    const o = []
    const s = (l) => {
      o.push(l)
      for (let u = 0; u < l.edgeCount; u++) {
        const { type: d, next: f } = l.edge(u)
        if (d == e || (o.indexOf(f) < 0 && s(f))) return !0
      }
    }
    if (s(i.contentMatch)) return !0
  }
}
const Ir = class t {
  constructor (e, n) {
    (this.nodes = e), (this.marks = n)
  }

  serializeFragment (e, n = {}, r) {
    r || (r = rf(n).createDocumentFragment())
    let i = r
    const o = []
    return (
      e.forEach((s) => {
        if (o.length || s.marks.length) {
          let l = 0
          let u = 0
          for (; l < o.length && u < s.marks.length;) {
            const d = s.marks[u]
            if (!this.marks[d.type.name]) {
              u++
              continue
            }
            if (!d.eq(o[l][0]) || d.type.spec.spanning === !1) {
              break
            }
            l++, u++
          }
          for (; l < o.length;) i = o.pop()[1]
          for (; u < s.marks.length;) {
            const d = s.marks[u++]
            const f = this.serializeMark(d, s.isInline, n)
            f &&
                            (o.push([d, i]),
                            i.appendChild(f.dom),
                            (i = f.contentDOM || f.dom))
          }
        }
        i.appendChild(this.serializeNodeInner(s, n))
      }),
      r
    )
  }

  serializeNodeInner (e, n) {
    const { dom: r, contentDOM: i } = Sl(
      rf(n),
      this.nodes[e.type.name](e),
      null,
      e.attrs
    )
    if (i) {
      if (e.isLeaf) {
        throw new RangeError(
          'Content hole not allowed in a leaf node spec'
        )
      }
      this.serializeFragment(e.content, n, i)
    }
    return r
  }

  serializeNode (e, n = {}) {
    let r = this.serializeNodeInner(e, n)
    for (let i = e.marks.length - 1; i >= 0; i--) {
      const o = this.serializeMark(e.marks[i], e.isInline, n)
      o && ((o.contentDOM || o.dom).appendChild(r), (r = o.dom))
    }
    return r
  }

  serializeMark (e, n, r = {}) {
    const i = this.marks[e.type.name]
    return i && Sl(rf(r), i(e, n), null, e.attrs)
  }

  static renderSpec (e, n, r = null, i) {
    return Sl(e, n, r, i)
  }

  static fromSchema (e) {
    return (
      e.cached.domSerializer ||
            (e.cached.domSerializer = new t(
              this.nodesFromSchema(e),
              this.marksFromSchema(e)
            ))
    )
  }

  static nodesFromSchema (e) {
    const n = Cy(e.nodes)
    return n.text || (n.text = (r) => r.text), n
  }

  static marksFromSchema (e) {
    return Cy(e.marks)
  }
}
function Cy (t) {
  const e = {}
  for (const n in t) {
    const r = t[n].spec.toDOM
    r && (e[n] = r)
  }
  return e
}
function rf (t) {
  return t.document || window.document
}
const Ay = new WeakMap()
function DO (t) {
  let e = Ay.get(t)
  return e === void 0 && Ay.set(t, (e = LO(t))), e
}
function LO (t) {
  let e = null
  function n (r) {
    if (r && typeof r === 'object') {
      if (Array.isArray(r)) {
        if (typeof r[0] === 'string') e || (e = []), e.push(r)
        else for (let i = 0; i < r.length; i++) n(r[i])
      } else for (const i in r) n(r[i])
    }
  }
  return n(t), e
}
function Sl (t, e, n, r) {
  if (typeof e === 'string') return { dom: t.createTextNode(e) }
  if (e.nodeType != null) return { dom: e }
  if (e.dom && e.dom.nodeType != null) return e
  let i = e[0]
  let o
  if (typeof i !== 'string') {
    throw new RangeError('Invalid array passed to renderSpec')
  }
  if (r && (o = DO(r)) && o.indexOf(e) > -1) {
    throw new RangeError(
      'Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.'
    )
  }
  const s = i.indexOf(' ')
  s > 0 && ((n = i.slice(0, s)), (i = i.slice(s + 1)))
  let l
  const u = n ? t.createElementNS(n, i) : t.createElement(i)
  const d = e[1]
  let f = 1
  if (d && typeof d === 'object' && d.nodeType == null && !Array.isArray(d)) {
    f = 2
    for (const h in d) {
      if (d[h] != null) {
        const m = h.indexOf(' ')
        m > 0
          ? u.setAttributeNS(h.slice(0, m), h.slice(m + 1), d[h])
          : u.setAttribute(h, d[h])
      }
    }
  }
  for (let h = f; h < e.length; h++) {
    const m = e[h]
    if (m === 0) {
      if (h < e.length - 1 || h > f) {
        throw new RangeError(
          'Content hole must be the only child of its parent node'
        )
      }
      return { dom: u, contentDOM: u }
    } else {
      const { dom: b, contentDOM: g } = Sl(t, m, n, r)
      if ((u.appendChild(b), g)) {
        if (l) throw new RangeError('Multiple content holes')
        l = g
      }
    }
  }
  return { dom: u, contentDOM: l }
}
const Gy = 65535
const qy = Math.pow(2, 16)
function PO (t, e) {
  return t + e * qy
}
function Ky (t) {
  return t & Gy
}
function BO (t) {
  return (t - (t & Gy)) / qy
}
const Yy = 1
const Jy = 2
const kl = 4
const Xy = 8
const zs = class {
  constructor (e, n, r) {
    (this.pos = e), (this.delInfo = n), (this.recover = r)
  }

  get deleted () {
    return (this.delInfo & Xy) > 0
  }

  get deletedBefore () {
    return (this.delInfo & (Yy | kl)) > 0
  }

  get deletedAfter () {
    return (this.delInfo & (Jy | kl)) > 0
  }

  get deletedAcross () {
    return (this.delInfo & kl) > 0
  }
}
const Dr = class t {
  constructor (e, n = !1) {
    if (((this.ranges = e), (this.inverted = n), !e.length && t.empty)) {
      return t.empty
    }
  }

  recover (e) {
    let n = 0
    const r = Ky(e)
    if (!this.inverted) {
      for (let i = 0; i < r; i++) {
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]
      }
    }
    return this.ranges[r * 3] + n + BO(e)
  }

  mapResult (e, n = 1) {
    return this._map(e, n, !1)
  }

  map (e, n = 1) {
    return this._map(e, n, !0)
  }

  _map (e, n, r) {
    let i = 0
    const o = this.inverted ? 2 : 1
    const s = this.inverted ? 1 : 2
    for (let l = 0; l < this.ranges.length; l += 3) {
      const u = this.ranges[l] - (this.inverted ? i : 0)
      if (u > e) break
      const d = this.ranges[l + o]
      const f = this.ranges[l + s]
      const h = u + d
      if (e <= h) {
        const m = d ? (e == u ? -1 : e == h ? 1 : n) : n
        const b = u + i + (m < 0 ? 0 : f)
        if (r) return b
        const g = e == (n < 0 ? u : h) ? null : PO(l / 3, e - u)
        let E = e == u ? Jy : e == h ? Yy : kl
        return (n < 0 ? e != u : e != h) && (E |= Xy), new zs(b, E, g)
      }
      i += f - d
    }
    return r ? e + i : new zs(e + i, 0, null)
  }

  touches (e, n) {
    let r = 0
    const i = Ky(n)
    const o = this.inverted ? 2 : 1
    const s = this.inverted ? 1 : 2
    for (let l = 0; l < this.ranges.length; l += 3) {
      const u = this.ranges[l] - (this.inverted ? r : 0)
      if (u > e) break
      const d = this.ranges[l + o]
      const f = u + d
      if (e <= f && l == i * 3) return !0
      r += this.ranges[l + s] - d
    }
    return !1
  }

  forEach (e) {
    const n = this.inverted ? 2 : 1
    const r = this.inverted ? 1 : 2
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      const s = this.ranges[i]
      const l = s - (this.inverted ? o : 0)
      const u = s + (this.inverted ? 0 : o)
      const d = this.ranges[i + n]
      const f = this.ranges[i + r]
      e(l, l + d, u, u + f), (o += f - d)
    }
  }

  invert () {
    return new t(this.ranges, !this.inverted)
  }

  toString () {
    return (this.inverted ? '-' : '') + JSON.stringify(this.ranges)
  }

  static offset (e) {
    return e == 0 ? t.empty : new t(e < 0 ? [0, -e, 0] : [0, 0, e])
  }
}
Dr.empty = new Dr([])
const Us = class t {
  constructor (e = [], n, r = 0, i = e.length) {
    (this.maps = e), (this.mirror = n), (this.from = r), (this.to = i)
  }

  slice (e = 0, n = this.maps.length) {
    return new t(this.maps, this.mirror, e, n)
  }

  copy () {
    return new t(
      this.maps.slice(),
      this.mirror && this.mirror.slice(),
      this.from,
      this.to
    )
  }

  appendMap (e, n) {
    (this.to = this.maps.push(e)),
    n != null && this.setMirror(this.maps.length - 1, n)
  }

  appendMapping (e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      const i = e.getMirror(n)
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0)
    }
  }

  getMirror (e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++) {
        if (this.mirror[n] == e) {
          return this.mirror[n + (n % 2 ? -1 : 1)]
        }
      }
    }
  }

  setMirror (e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n)
  }

  appendMappingInverted (e) {
    for (
      let n = e.maps.length - 1, r = this.maps.length + e.maps.length;
      n >= 0;
      n--
    ) {
      const i = e.getMirror(n)
      this.appendMap(
        e.maps[n].invert(),
        i != null && i > n ? r - i - 1 : void 0
      )
    }
  }

  invert () {
    const e = new t()
    return e.appendMappingInverted(this), e
  }

  map (e, n = 1) {
    if (this.mirror) return this._map(e, n, !0)
    for (let r = this.from; r < this.to; r++) {
      e = this.maps[r].map(e, n)
    }
    return e
  }

  mapResult (e, n = 1) {
    return this._map(e, n, !1)
  }

  _map (e, n, r) {
    let i = 0
    for (let o = this.from; o < this.to; o++) {
      const s = this.maps[o]
      const l = s.mapResult(e, n)
      if (l.recover != null) {
        const u = this.getMirror(o)
        if (u != null && u > o && u < this.to) {
          (o = u), (e = this.maps[u].recover(l.recover))
          continue
        }
      }
      (i |= l.delInfo), (e = l.pos)
    }
    return r ? e : new zs(e, i, null)
  }
}
const df = Object.create(null)
const zt = class {
  getMap () {
    return Dr.empty
  }

  merge (e) {
    return null
  }

  static fromJSON (e, n) {
    if (!n || !n.stepType) {
      throw new RangeError('Invalid input for Step.fromJSON')
    }
    const r = df[n.stepType]
    if (!r) throw new RangeError(`No step type ${n.stepType} defined`)
    return r.fromJSON(e, n)
  }

  static jsonID (e, n) {
    if (e in df) {
      throw new RangeError('Duplicate use of step JSON ID ' + e)
    }
    return (df[e] = n), (n.prototype.jsonID = e), n
  }
}
const Gt = class t {
  constructor (e, n) {
    (this.doc = e), (this.failed = n)
  }

  static ok (e) {
    return new t(e, null)
  }

  static fail (e) {
    return new t(null, e)
  }

  static fromReplace (e, n, r, i) {
    try {
      return t.ok(e.replace(n, r, i))
    } catch (o) {
      if (o instanceof zi) return t.fail(o.message)
      throw o
    }
  }
}
function gf (t, e, n) {
  const r = []
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i)
    o.content.size && (o = o.copy(gf(o.content, e, o))),
    o.isInline && (o = e(o, n, i)),
    r.push(o)
  }
  return K.fromArray(r)
}
const Ws = class t extends zt {
  constructor (e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r)
  }

  apply (e) {
    const n = e.slice(this.from, this.to)
    const r = e.resolve(this.from)
    const i = r.node(r.sharedDepth(this.to))
    const o = new Z(
      gf(
        n.content,
        (s, l) =>
          !s.isAtom || !l.type.allowsMarkType(this.mark.type)
            ? s
            : s.mark(this.mark.addToSet(s.marks)),
        i
      ),
      n.openStart,
      n.openEnd
    )
    return Gt.fromReplace(e, this.from, this.to, o)
  }

  invert () {
    return new Ki(this.from, this.to, this.mark)
  }

  map (e) {
    const n = e.mapResult(this.from, 1)
    const r = e.mapResult(this.to, -1)
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new t(n.pos, r.pos, this.mark)
  }

  merge (e) {
    return e instanceof t &&
            e.mark.eq(this.mark) &&
            this.from <= e.to &&
            this.to >= e.from
      ? new t(
        Math.min(this.from, e.from),
        Math.max(this.to, e.to),
        this.mark
      )
      : null
  }

  toJSON () {
    return {
      stepType: 'addMark',
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    }
  }

  static fromJSON (e, n) {
    if (typeof n.from !== 'number' || typeof n.to !== 'number') {
      throw new RangeError('Invalid input for AddMarkStep.fromJSON')
    }
    return new t(n.from, n.to, e.markFromJSON(n.mark))
  }
}
zt.jsonID('addMark', Ws)
var Ki = class t extends zt {
  constructor (e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r)
  }

  apply (e) {
    const n = e.slice(this.from, this.to)
    const r = new Z(
      gf(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e),
      n.openStart,
      n.openEnd
    )
    return Gt.fromReplace(e, this.from, this.to, r)
  }

  invert () {
    return new Ws(this.from, this.to, this.mark)
  }

  map (e) {
    const n = e.mapResult(this.from, 1)
    const r = e.mapResult(this.to, -1)
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new t(n.pos, r.pos, this.mark)
  }

  merge (e) {
    return e instanceof t &&
            e.mark.eq(this.mark) &&
            this.from <= e.to &&
            this.to >= e.from
      ? new t(
        Math.min(this.from, e.from),
        Math.max(this.to, e.to),
        this.mark
      )
      : null
  }

  toJSON () {
    return {
      stepType: 'removeMark',
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    }
  }

  static fromJSON (e, n) {
    if (typeof n.from !== 'number' || typeof n.to !== 'number') {
      throw new RangeError('Invalid input for RemoveMarkStep.fromJSON')
    }
    return new t(n.from, n.to, e.markFromJSON(n.mark))
  }
}
zt.jsonID('removeMark', Ki)
const Ks = class t extends zt {
  constructor (e, n) {
    super(), (this.pos = e), (this.mark = n)
  }

  apply (e) {
    const n = e.nodeAt(this.pos)
    if (!n) return Gt.fail("No node at mark step's position")
    const r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks))
    return Gt.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new Z(K.from(r), 0, n.isLeaf ? 0 : 1)
    )
  }

  invert (e) {
    const n = e.nodeAt(this.pos)
    if (n) {
      const r = this.mark.addToSet(n.marks)
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++) {
          if (!n.marks[i].isInSet(r)) {
            return new t(this.pos, n.marks[i])
          }
        }
        return new t(this.pos, this.mark)
      }
    }
    return new Vs(this.pos, this.mark)
  }

  map (e) {
    const n = e.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new t(n.pos, this.mark)
  }

  toJSON () {
    return {
      stepType: 'addNodeMark',
      pos: this.pos,
      mark: this.mark.toJSON()
    }
  }

  static fromJSON (e, n) {
    if (typeof n.pos !== 'number') {
      throw new RangeError('Invalid input for AddNodeMarkStep.fromJSON')
    }
    return new t(n.pos, e.markFromJSON(n.mark))
  }
}
zt.jsonID('addNodeMark', Ks)
var Vs = class t extends zt {
  constructor (e, n) {
    super(), (this.pos = e), (this.mark = n)
  }

  apply (e) {
    const n = e.nodeAt(this.pos)
    if (!n) return Gt.fail("No node at mark step's position")
    const r = n.type.create(
      n.attrs,
      null,
      this.mark.removeFromSet(n.marks)
    )
    return Gt.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new Z(K.from(r), 0, n.isLeaf ? 0 : 1)
    )
  }

  invert (e) {
    const n = e.nodeAt(this.pos)
    return !n || !this.mark.isInSet(n.marks)
      ? this
      : new Ks(this.pos, this.mark)
  }

  map (e) {
    const n = e.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new t(n.pos, this.mark)
  }

  toJSON () {
    return {
      stepType: 'removeNodeMark',
      pos: this.pos,
      mark: this.mark.toJSON()
    }
  }

  static fromJSON (e, n) {
    if (typeof n.pos !== 'number') {
      throw new RangeError(
        'Invalid input for RemoveNodeMarkStep.fromJSON'
      )
    }
    return new t(n.pos, e.markFromJSON(n.mark))
  }
}
zt.jsonID('removeNodeMark', Vs)
const tn = class t extends zt {
  constructor (e, n, r, i = !1) {
    super(),
    (this.from = e),
    (this.to = n),
    (this.slice = r),
    (this.structure = i)
  }

  apply (e) {
    return this.structure && hf(e, this.from, this.to)
      ? Gt.fail('Structure replace would overwrite content')
      : Gt.fromReplace(e, this.from, this.to, this.slice)
  }

  getMap () {
    return new Dr([this.from, this.to - this.from, this.slice.size])
  }

  invert (e) {
    return new t(
      this.from,
      this.from + this.slice.size,
      e.slice(this.from, this.to)
    )
  }

  map (e) {
    const n = e.mapResult(this.from, 1)
    const r = e.mapResult(this.to, -1)
    return n.deletedAcross && r.deletedAcross
      ? null
      : new t(n.pos, Math.max(n.pos, r.pos), this.slice)
  }

  merge (e) {
    if (!(e instanceof t) || e.structure || this.structure) return null
    if (
      this.from + this.slice.size == e.from &&
            !this.slice.openEnd &&
            !e.slice.openStart
    ) {
      const n =
                this.slice.size + e.slice.size == 0
                  ? Z.empty
                  : new Z(
                    this.slice.content.append(e.slice.content),
                    this.slice.openStart,
                    e.slice.openEnd
                  )
      return new t(
        this.from,
        this.to + (e.to - e.from),
        n,
        this.structure
      )
    } else if (
      e.to == this.from &&
            !this.slice.openStart &&
            !e.slice.openEnd
    ) {
      const n =
                this.slice.size + e.slice.size == 0
                  ? Z.empty
                  : new Z(
                    e.slice.content.append(this.slice.content),
                    e.slice.openStart,
                    this.slice.openEnd
                  )
      return new t(e.from, this.to, n, this.structure)
    } else return null
  }

  toJSON () {
    const e = { stepType: 'replace', from: this.from, to: this.to }
    return (
      this.slice.size && (e.slice = this.slice.toJSON()),
      this.structure && (e.structure = !0),
      e
    )
  }

  static fromJSON (e, n) {
    if (typeof n.from !== 'number' || typeof n.to !== 'number') {
      throw new RangeError('Invalid input for ReplaceStep.fromJSON')
    }
    return new t(n.from, n.to, Z.fromJSON(e, n.slice), !!n.structure)
  }
}
zt.jsonID('replace', tn)
const Ct = class t extends zt {
  constructor (e, n, r, i, o, s, l = !1) {
    super(),
    (this.from = e),
    (this.to = n),
    (this.gapFrom = r),
    (this.gapTo = i),
    (this.slice = o),
    (this.insert = s),
    (this.structure = l)
  }

  apply (e) {
    if (
      this.structure &&
            (hf(e, this.from, this.gapFrom) || hf(e, this.gapTo, this.to))
    ) {
      return Gt.fail('Structure gap-replace would overwrite content')
    }
    const n = e.slice(this.gapFrom, this.gapTo)
    if (n.openStart || n.openEnd) return Gt.fail('Gap is not a flat range')
    const r = this.slice.insertAt(this.insert, n.content)
    return r
      ? Gt.fromReplace(e, this.from, this.to, r)
      : Gt.fail('Content does not fit in gap')
  }

  getMap () {
    return new Dr([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ])
  }

  invert (e) {
    const n = this.gapTo - this.gapFrom
    return new t(
      this.from,
      this.from + this.slice.size + n,
      this.from + this.insert,
      this.from + this.insert + n,
      e
        .slice(this.from, this.to)
        .removeBetween(
          this.gapFrom - this.from,
          this.gapTo - this.from
        ),
      this.gapFrom - this.from,
      this.structure
    )
  }

  map (e) {
    const n = e.mapResult(this.from, 1)
    const r = e.mapResult(this.to, -1)
    const i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1)
    const o = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1)
    return (n.deletedAcross && r.deletedAcross) || i < n.pos || o > r.pos
      ? null
      : new t(
        n.pos,
        r.pos,
        i,
        o,
        this.slice,
        this.insert,
        this.structure
      )
  }

  toJSON () {
    const e = {
      stepType: 'replaceAround',
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    }
    return (
      this.slice.size && (e.slice = this.slice.toJSON()),
      this.structure && (e.structure = !0),
      e
    )
  }

  static fromJSON (e, n) {
    if (
      typeof n.from !== 'number' ||
            typeof n.to !== 'number' ||
            typeof n.gapFrom !== 'number' ||
            typeof n.gapTo !== 'number' ||
            typeof n.insert !== 'number'
    ) {
      throw new RangeError(
        'Invalid input for ReplaceAroundStep.fromJSON'
      )
    }
    return new t(
      n.from,
      n.to,
      n.gapFrom,
      n.gapTo,
      Z.fromJSON(e, n.slice),
      n.insert,
      !!n.structure
    )
  }
}
zt.jsonID('replaceAround', Ct)
function hf (t, e, n) {
  const r = t.resolve(e)
  let i = n - e
  let o = r.depth
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount;) {
    o--, i--
  }
  if (i > 0) {
    let s = r.node(o).maybeChild(r.indexAfter(o))
    for (; i > 0;) {
      if (!s || s.isLeaf) return !0;
      (s = s.firstChild), i--
    }
  }
  return !1
}
function FO (t, e, n, r) {
  const i = []
  const o = []
  let s
  let l
  t.doc.nodesBetween(e, n, (u, d, f) => {
    if (!u.isInline) return
    const h = u.marks
    if (!r.isInSet(h) && f.type.allowsMarkType(r.type)) {
      const m = Math.max(d, e)
      const b = Math.min(d + u.nodeSize, n)
      const g = r.addToSet(h)
      for (let E = 0; E < h.length; E++) {
        h[E].isInSet(g) ||
                    (s && s.to == m && s.mark.eq(h[E])
                      ? (s.to = b)
                      : i.push((s = new Ki(m, b, h[E]))))
      }
      l && l.to == m ? (l.to = b) : o.push((l = new Ws(m, b, r)))
    }
  }),
  i.forEach((u) => t.step(u)),
  o.forEach((u) => t.step(u))
}
function HO (t, e, n, r) {
  const i = []
  let o = 0
  t.doc.nodesBetween(e, n, (s, l) => {
    if (!s.isInline) return
    o++
    let u = null
    if (r instanceof Ps) {
      let d = s.marks
      let f
      for (; (f = r.isInSet(d));) {
        (u || (u = [])).push(f), (d = f.removeFromSet(d))
      }
    } else r ? r.isInSet(s.marks) && (u = [r]) : (u = s.marks)
    if (u && u.length) {
      const d = Math.min(l + s.nodeSize, n)
      for (let f = 0; f < u.length; f++) {
        const h = u[f]
        let m
        for (let b = 0; b < i.length; b++) {
          const g = i[b]
          g.step == o - 1 && h.eq(i[b].style) && (m = g)
        }
        m
          ? ((m.to = d), (m.step = o))
          : i.push({
            style: h,
            from: Math.max(l, e),
            to: d,
            step: o
          })
      }
    }
  }),
  i.forEach((s) => t.step(new Ki(s.from, s.to, s.style)))
}
function bf (t, e, n, r = n.contentMatch, i = !0) {
  const o = t.doc.nodeAt(e)
  const s = []
  let l = e + 1
  for (let u = 0; u < o.childCount; u++) {
    const d = o.child(u)
    const f = l + d.nodeSize
    const h = r.matchType(d.type)
    if (!h) s.push(new tn(l, f, Z.empty))
    else {
      r = h
      for (let m = 0; m < d.marks.length; m++) {
        n.allowsMarkType(d.marks[m].type) ||
                    t.step(new Ki(l, f, d.marks[m]))
      }
      if (i && d.isText && n.whitespace != 'pre') {
        let m
        const b = /\r?\n|\r/g
        let g
        for (; (m = b.exec(d.text));) {
          g ||
                        (g = new Z(
                          K.from(n.schema.text(' ', n.allowedMarks(d.marks))),
                          0,
                          0
                        )),
          s.push(
            new tn(l + m.index, l + m.index + m[0].length, g)
          )
        }
      }
    }
    l = f
  }
  if (!r.validEnd) {
    const u = r.fillBefore(K.empty, !0)
    t.replace(l, l, new Z(u, 0, 0))
  }
  for (let u = s.length - 1; u >= 0; u--) t.step(s[u])
}
function $O (t, e, n) {
  return (
    (e == 0 || t.canReplace(e, t.childCount)) &&
        (n == t.childCount || t.canReplace(0, n))
  )
}
function Lr (t) {
  const n = t.parent.content.cutByIndex(t.startIndex, t.endIndex)
  for (let r = t.depth; ; --r) {
    const i = t.$from.node(r)
    const o = t.$from.index(r)
    const s = t.$to.indexAfter(r)
    if (r < t.depth && i.canReplace(o, s, n)) return r
    if (r == 0 || i.type.spec.isolating || !$O(i, o, s)) break
  }
  return null
}
function zO (t, e, n) {
  const { $from: r, $to: i, depth: o } = e
  const s = r.before(o + 1)
  const l = i.after(o + 1)
  let u = s
  let d = l
  let f = K.empty
  let h = 0
  for (let g = o, E = !1; g > n; g--) {
    E || r.index(g) > 0
      ? ((E = !0), (f = K.from(r.node(g).copy(f))), h++)
      : u--
  }
  let m = K.empty
  let b = 0
  for (let g = o, E = !1; g > n; g--) {
    E || i.after(g + 1) < i.end(g)
      ? ((E = !0), (m = K.from(i.node(g).copy(m))), b++)
      : d++
  }
  t.step(new Ct(u, d, s, l, new Z(f.append(m), h, b), f.size - h, !0))
}
function Bo (t, e, n = null, r = t) {
  const i = UO(t, e)
  const o = i && WO(r, e)
  return o ? i.map(Vy).concat({ type: e, attrs: n }).concat(o.map(Vy)) : null
}
function Vy (t) {
  return { type: t, attrs: null }
}
function UO (t, e) {
  const { parent: n, startIndex: r, endIndex: i } = t
  const o = n.contentMatchAt(r).findWrapping(e)
  if (!o) return null
  const s = o.length ? o[0] : e
  return n.canReplaceWith(r, i, s) ? o : null
}
function WO (t, e) {
  const { parent: n, startIndex: r, endIndex: i } = t
  const o = n.child(r)
  const s = e.contentMatch.findWrapping(o.type)
  if (!s) return null
  let u = (s.length ? s[s.length - 1] : e).contentMatch
  for (let d = r; u && d < i; d++) u = u.matchType(n.child(d).type)
  return !u || !u.validEnd ? null : s
}
function KO (t, e, n) {
  let r = K.empty
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      const l = n[s].type.contentMatch.matchFragment(r)
      if (!l || !l.validEnd) {
        throw new RangeError(
          'Wrapper type given to Transform.wrap does not form valid content of its parent wrapper'
        )
      }
    }
    r = K.from(n[s].type.create(n[s].attrs, r))
  }
  const i = e.start
  const o = e.end
  t.step(new Ct(i, o, i, o, new Z(r, 0, 0), n.length, !0))
}
function VO (t, e, n, r, i) {
  if (!r.isTextblock) {
    throw new RangeError(
      'Type given to setBlockType should be a textblock'
    )
  }
  const o = t.steps.length
  t.doc.nodesBetween(e, n, (s, l) => {
    const u = typeof i === 'function' ? i(s) : i
    if (
      s.isTextblock &&
            !s.hasMarkup(r, u) &&
            GO(t.doc, t.mapping.slice(o).map(l), r)
    ) {
      let d = null
      if (r.schema.linebreakReplacement) {
        const b = r.whitespace == 'pre'
        const g = !!r.contentMatch.matchType(
          r.schema.linebreakReplacement
        )
        b && !g ? (d = !1) : !b && g && (d = !0)
      }
      d === !1 && jy(t, s, l, o),
      bf(t, t.mapping.slice(o).map(l, 1), r, void 0, d === null)
      const f = t.mapping.slice(o)
      const h = f.map(l, 1)
      const m = f.map(l + s.nodeSize, 1)
      return (
        t.step(
          new Ct(
            h,
            m,
            h + 1,
            m - 1,
            new Z(K.from(r.create(u, null, s.marks)), 0, 0),
            1,
            !0
          )
        ),
        d === !0 && Zy(t, s, l, o),
        !1
      )
    }
  })
}
function Zy (t, e, n, r) {
  e.forEach((i, o) => {
    if (i.isText) {
      let s
      const l = /\r?\n|\r/g
      for (; (s = l.exec(i.text));) {
        const u = t.mapping.slice(r).map(n + 1 + o + s.index)
        t.replaceWith(
          u,
          u + 1,
          e.type.schema.linebreakReplacement.create()
        )
      }
    }
  })
}
function jy (t, e, n, r) {
  e.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      const s = t.mapping.slice(r).map(n + 1 + o)
      t.replaceWith(
        s,
        s + 1,
        e.type.schema.text(`
`)
      )
    }
  })
}
function GO (t, e, n) {
  const r = t.resolve(e)
  const i = r.index()
  return r.parent.canReplaceWith(i, i + 1, n)
}
function qO (t, e, n, r, i) {
  const o = t.doc.nodeAt(e)
  if (!o) throw new RangeError('No node at given position')
  n || (n = o.type)
  const s = n.create(r, null, i || o.marks)
  if (o.isLeaf) return t.replaceWith(e, e + o.nodeSize, s)
  if (!n.validContent(o.content)) {
    throw new RangeError('Invalid content for node type ' + n.name)
  }
  t.step(
    new Ct(
      e,
      e + o.nodeSize,
      e + 1,
      e + o.nodeSize - 1,
      new Z(K.from(s), 0, 0),
      1,
      !0
    )
  )
}
function zn (t, e, n = 1, r) {
  const i = t.resolve(e)
  const o = i.depth - n
  const s = (r && r[r.length - 1]) || i.parent
  if (
    o < 0 ||
        i.parent.type.spec.isolating ||
        !i.parent.canReplace(i.index(), i.parent.childCount) ||
        !s.type.validContent(
          i.parent.content.cutByIndex(i.index(), i.parent.childCount)
        )
  ) {
    return !1
  }
  for (let d = i.depth - 1, f = n - 2; d > o; d--, f--) {
    const h = i.node(d)
    const m = i.index(d)
    if (h.type.spec.isolating) return !1
    let b = h.content.cutByIndex(m, h.childCount)
    const g = r && r[f + 1]
    g && (b = b.replaceChild(0, g.type.create(g.attrs)))
    const E = (r && r[f]) || h
    if (!h.canReplace(m + 1, h.childCount) || !E.type.validContent(b)) {
      return !1
    }
  }
  const l = i.indexAfter(o)
  const u = r && r[0]
  return i.node(o).canReplaceWith(l, l, u ? u.type : i.node(o + 1).type)
}
function YO (t, e, n = 1, r) {
  const i = t.doc.resolve(e)
  let o = K.empty
  let s = K.empty
  for (let l = i.depth, u = i.depth - n, d = n - 1; l > u; l--, d--) {
    o = K.from(i.node(l).copy(o))
    const f = r && r[d]
    s = K.from(f ? f.type.create(f.attrs, s) : i.node(l).copy(s))
  }
  t.step(new tn(e, e, new Z(o.append(s), n, n), !0))
}
function rr (t, e) {
  const n = t.resolve(e)
  const r = n.index()
  return Qy(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function JO (t, e) {
  e.content.size || t.type.compatibleContent(e.type)
  let n = t.contentMatchAt(t.childCount)
  const { linebreakReplacement: r } = t.type.schema
  for (let i = 0; i < e.childCount; i++) {
    const o = e.child(i)
    const s = o.type == r ? t.type.schema.nodes.text : o.type
    if (((n = n.matchType(s)), !n || !t.type.allowsMarks(o.marks))) {
      return !1
    }
  }
  return n.validEnd
}
function Qy (t, e) {
  return !!(t && e && !t.isLeaf && JO(t, e))
}
function Fo (t, e, n = -1) {
  const r = t.resolve(e)
  for (let i = r.depth; ; i--) {
    let o
    let s
    let l = r.index(i)
    if (
      (i == r.depth
        ? ((o = r.nodeBefore), (s = r.nodeAfter))
        : n > 0
          ? ((o = r.node(i + 1)), l++, (s = r.node(i).maybeChild(l)))
          : ((o = r.node(i).maybeChild(l - 1)), (s = r.node(i + 1))),
      o && !o.isTextblock && Qy(o, s) && r.node(i).canReplace(l, l + 1))
    ) {
      return e
    }
    if (i == 0) break
    e = n < 0 ? r.before(i) : r.after(i)
  }
}
function XO (t, e, n) {
  let r = null
  const { linebreakReplacement: i } = t.doc.type.schema
  const o = t.doc.resolve(e - n)
  const s = o.node().type
  if (i && s.inlineContent) {
    const f = s.whitespace == 'pre'
    const h = !!s.contentMatch.matchType(i)
    f && !h ? (r = !1) : !f && h && (r = !0)
  }
  const l = t.steps.length
  if (r === !1) {
    const f = t.doc.resolve(e + n)
    jy(t, f.node(), f.before(), l)
  }
  s.inlineContent &&
        bf(t, e + n - 1, s, o.node().contentMatchAt(o.index()), r == null)
  const u = t.mapping.slice(l)
  const d = u.map(e - n)
  if ((t.step(new tn(d, u.map(e + n, -1), Z.empty, !0)), r === !0)) {
    const f = t.doc.resolve(d)
    Zy(t, f.node(), f.before(), t.steps.length)
  }
  return t
}
function ZO (t, e, n) {
  const r = t.resolve(e)
  if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e
  if (r.parentOffset == 0) {
    for (let i = r.depth - 1; i >= 0; i--) {
      const o = r.index(i)
      if (r.node(i).canReplaceWith(o, o, n)) return r.before(i + 1)
      if (o > 0) return null
    }
  }
  if (r.parentOffset == r.parent.content.size) {
    for (let i = r.depth - 1; i >= 0; i--) {
      const o = r.indexAfter(i)
      if (r.node(i).canReplaceWith(o, o, n)) return r.after(i + 1)
      if (o < r.node(i).childCount) return null
    }
  }
  return null
}
function Il (t, e, n) {
  const r = t.resolve(e)
  if (!n.content.size) return e
  let i = n.content
  for (let o = 0; o < n.openStart; o++) i = i.firstChild.content
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++) {
    for (let s = r.depth; s >= 0; s--) {
      const l =
                s == r.depth
                  ? 0
                  : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2
                    ? -1
                    : 1
      const u = r.index(s) + (l > 0 ? 1 : 0)
      const d = r.node(s)
      let f = !1
      if (o == 1) f = d.canReplace(u, u, i)
      else {
        const h = d.contentMatchAt(u).findWrapping(i.firstChild.type)
        f = h && d.canReplaceWith(u, u, h[0])
      }
      if (f) {
        return l == 0
          ? r.pos
          : l < 0
            ? r.before(s + 1)
            : r.after(s + 1)
      }
    }
  }
  return null
}
function Gs (t, e, n = e, r = Z.empty) {
  if (e == n && !r.size) return null
  const i = t.resolve(e)
  const o = t.resolve(n)
  return e0(i, o, r) ? new tn(e, n, r) : new mf(i, o, r).fit()
}
function e0 (t, e, n) {
  return (
    !n.openStart &&
        !n.openEnd &&
        t.start() == e.start() &&
        t.parent.canReplace(t.index(), e.index(), n.content)
  )
}
var mf = class {
  constructor (e, n, r) {
    (this.$from = e),
    (this.$to = n),
    (this.unplaced = r),
    (this.frontier = []),
    (this.placed = K.empty)
    for (let i = 0; i <= e.depth; i++) {
      const o = e.node(i)
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(i))
      })
    }
    for (let i = e.depth; i > 0; i--) {
      this.placed = K.from(e.node(i).copy(this.placed))
    }
  }

  get depth () {
    return this.frontier.length - 1
  }

  fit () {
    for (; this.unplaced.size;) {
      const d = this.findFittable()
      d ? this.placeNodes(d) : this.openMore() || this.dropNode()
    }
    const e = this.mustMoveInline()
    const n = this.placed.size - this.depth - this.$from.depth
    const r = this.$from
    const i = this.close(e < 0 ? this.$to : r.doc.resolve(e))
    if (!i) return null
    let o = this.placed
    let s = r.depth
    let l = i.depth
    for (; s && l && o.childCount == 1;) {
      (o = o.firstChild.content), s--, l--
    }
    const u = new Z(o, s, l)
    return e > -1
      ? new Ct(r.pos, e, this.$to.pos, this.$to.end(), u, n)
      : u.size || r.pos != this.$to.pos
        ? new tn(r.pos, i.pos, u)
        : null
  }

  findFittable () {
    let e = this.unplaced.openStart
    for (
      let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd;
      r < e;
      r++
    ) {
      const o = n.firstChild
      if (
        (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r)
      ) {
        e = r
        break
      }
      n = o.content
    }
    for (let n = 1; n <= 2; n++) {
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i
        let o = null
        r
          ? ((o = ff(this.unplaced.content, r - 1).firstChild),
            (i = o.content))
          : (i = this.unplaced.content)
        const s = i.firstChild
        for (let l = this.depth; l >= 0; l--) {
          const { type: u, match: d } = this.frontier[l]
          let f
          let h = null
          if (
            n == 1 &&
                        (s
                          ? d.matchType(s.type) ||
                              (h = d.fillBefore(K.from(s), !1))
                          : o && u.compatibleContent(o.type))
          ) {
            return {
              sliceDepth: r,
              frontierDepth: l,
              parent: o,
              inject: h
            }
          }
          if (n == 2 && s && (f = d.findWrapping(s.type))) {
            return {
              sliceDepth: r,
              frontierDepth: l,
              parent: o,
              wrap: f
            }
          }
          if (o && d.matchType(o.type)) break
        }
      }
    }
  }

  openMore () {
    const { content: e, openStart: n, openEnd: r } = this.unplaced
    const i = ff(e, n)
    return !i.childCount || i.firstChild.isLeaf
      ? !1
      : ((this.unplaced = new Z(
          e,
          n + 1,
          Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)
        )),
        !0)
  }

  dropNode () {
    const { content: e, openStart: n, openEnd: r } = this.unplaced
    const i = ff(e, n)
    if (i.childCount <= 1 && n > 0) {
      const o = e.size - n <= n + i.size
      this.unplaced = new Z(Hs(e, n - 1, 1), n - 1, o ? n - 1 : r)
    } else this.unplaced = new Z(Hs(e, n, 1), n, r)
  }

  placeNodes ({
    sliceDepth: e,
    frontierDepth: n,
    parent: r,
    inject: i,
    wrap: o
  }) {
    for (; this.depth > n;) this.closeFrontierNode()
    if (o) for (let E = 0; E < o.length; E++) this.openFrontierNode(o[E])
    const s = this.unplaced
    const l = r ? r.content : s.content
    const u = s.openStart - e
    let d = 0
    const f = []
    let { match: h, type: m } = this.frontier[n]
    if (i) {
      for (let E = 0; E < i.childCount; E++) f.push(i.child(E))
      h = h.matchFragment(i)
    }
    let b = l.size + e - (s.content.size - s.openEnd)
    for (; d < l.childCount;) {
      const E = l.child(d)
      const w = h.matchType(E.type)
      if (!w) break
      d++,
      (d > 1 || u == 0 || E.content.size) &&
                    ((h = w),
                    f.push(
                      t0(
                        E.mark(m.allowedMarks(E.marks)),
                        d == 1 ? u : 0,
                        d == l.childCount ? b : -1
                      )
                    ))
    }
    const g = d == l.childCount
    g || (b = -1),
    (this.placed = $s(this.placed, n, K.from(f))),
    (this.frontier[n].match = h),
    g &&
                b < 0 &&
                r &&
                r.type == this.frontier[this.depth].type &&
                this.frontier.length > 1 &&
                this.closeFrontierNode()
    for (let E = 0, w = l; E < b; E++) {
      const S = w.lastChild
      this.frontier.push({
        type: S.type,
        match: S.contentMatchAt(S.childCount)
      }),
      (w = S.content)
    }
    this.unplaced = g
      ? e == 0
        ? Z.empty
        : new Z(
          Hs(s.content, e - 1, 1),
          e - 1,
          b < 0 ? s.openEnd : e - 1
        )
      : new Z(Hs(s.content, e, d), s.openStart, s.openEnd)
  }

  mustMoveInline () {
    if (!this.$to.parent.isTextblock) return -1
    const e = this.frontier[this.depth]
    let n
    if (
      !e.type.isTextblock ||
            !pf(this.$to, this.$to.depth, e.type, e.match, !1) ||
            (this.$to.depth == this.depth &&
                (n = this.findCloseLevel(this.$to)) &&
                n.depth == this.depth)
    ) {
      return -1
    }
    let { depth: r } = this.$to
    let i = this.$to.after(r)
    for (; r > 1 && i == this.$to.end(--r);) ++i
    return i
  }

  findCloseLevel (e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      const { match: r, type: i } = this.frontier[n]
      const o =
                n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1))
      const s = pf(e, n, i, r, o)
      if (s) {
        for (let l = n - 1; l >= 0; l--) {
          const { match: u, type: d } = this.frontier[l]
          const f = pf(e, l, d, u, !0)
          if (!f || f.childCount) continue e
        }
        return {
          depth: n,
          fit: s,
          move: o ? e.doc.resolve(e.after(n + 1)) : e
        }
      }
    }
  }

  close (e) {
    const n = this.findCloseLevel(e)
    if (!n) return null
    for (; this.depth > n.depth;) this.closeFrontierNode()
    n.fit.childCount && (this.placed = $s(this.placed, n.depth, n.fit)),
    (e = n.move)
    for (let r = n.depth + 1; r <= e.depth; r++) {
      const i = e.node(r)
      const o = i.type.contentMatch.fillBefore(i.content, !0, e.index(r))
      this.openFrontierNode(i.type, i.attrs, o)
    }
    return e
  }

  openFrontierNode (e, n = null, r) {
    const i = this.frontier[this.depth];
    (i.match = i.match.matchType(e)),
    (this.placed = $s(this.placed, this.depth, K.from(e.create(n, r)))),
    this.frontier.push({ type: e, match: e.contentMatch })
  }

  closeFrontierNode () {
    const n = this.frontier.pop().match.fillBefore(K.empty, !0)
    n.childCount &&
            (this.placed = $s(this.placed, this.frontier.length, n))
  }
}
function Hs (t, e, n) {
  return e == 0
    ? t.cutByIndex(n, t.childCount)
    : t.replaceChild(
      0,
      t.firstChild.copy(Hs(t.firstChild.content, e - 1, n))
    )
}
function $s (t, e, n) {
  return e == 0
    ? t.append(n)
    : t.replaceChild(
      t.childCount - 1,
      t.lastChild.copy($s(t.lastChild.content, e - 1, n))
    )
}
function ff (t, e) {
  for (let n = 0; n < e; n++) t = t.firstChild.content
  return t
}
function t0 (t, e, n) {
  if (e <= 0) return t
  let r = t.content
  return (
    e > 1 &&
            (r = r.replaceChild(
              0,
              t0(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0)
            )),
    e > 0 &&
            ((r = t.type.contentMatch.fillBefore(r).append(r)),
            n <= 0 &&
                (r = r.append(
                  t.type.contentMatch
                    .matchFragment(r)
                    .fillBefore(K.empty, !0)
                ))),
    t.copy(r)
  )
}
function pf (t, e, n, r, i) {
  const o = t.node(e)
  const s = i ? t.indexAfter(e) : t.index(e)
  if (s == o.childCount && !n.compatibleContent(o.type)) return null
  const l = r.fillBefore(o.content, !0, s)
  return l && !jO(n, o.content, s) ? l : null
}
function jO (t, e, n) {
  for (let r = n; r < e.childCount; r++) {
    if (!t.allowsMarks(e.child(r).marks)) return !0
  }
  return !1
}
function QO (t) {
  return t.spec.defining || t.spec.definingForContent
}
function eR (t, e, n, r) {
  if (!r.size) return t.deleteRange(e, n)
  const i = t.doc.resolve(e)
  const o = t.doc.resolve(n)
  if (e0(i, o, r)) return t.step(new tn(e, n, r))
  const s = r0(i, t.doc.resolve(n))
  s[s.length - 1] == 0 && s.pop()
  let l = -(i.depth + 1)
  s.unshift(l)
  for (let m = i.depth, b = i.pos - 1; m > 0; m--, b--) {
    const g = i.node(m).type.spec
    if (g.defining || g.definingAsContext || g.isolating) break
    s.indexOf(m) > -1 ? (l = m) : i.before(m) == b && s.splice(1, 0, -m)
  }
  const u = s.indexOf(l)
  const d = []
  let f = r.openStart
  for (let m = r.content, b = 0; ; b++) {
    const g = m.firstChild
    if ((d.push(g), b == r.openStart)) break
    m = g.content
  }
  for (let m = f - 1; m >= 0; m--) {
    const b = d[m]
    const g = QO(b.type)
    if (g && !b.sameMarkup(i.node(Math.abs(l) - 1))) f = m
    else if (g || !b.type.isTextblock) break
  }
  for (let m = r.openStart; m >= 0; m--) {
    const b = (m + f + 1) % (r.openStart + 1)
    const g = d[b]
    if (g) {
      for (let E = 0; E < s.length; E++) {
        let w = s[(E + u) % s.length]
        let S = !0
        w < 0 && ((S = !1), (w = -w))
        const O = i.node(w - 1)
        const k = i.index(w - 1)
        if (O.canReplaceWith(k, k, g.type, g.marks)) {
          return t.replace(
            i.before(w),
            S ? o.after(w) : n,
            new Z(n0(r.content, 0, r.openStart, b), b, r.openEnd)
          )
        }
      }
    }
  }
  const h = t.steps.length
  for (
    let m = s.length - 1;
    m >= 0 && (t.replace(e, n, r), !(t.steps.length > h));
    m--
  ) {
    const b = s[m]
    b < 0 || ((e = i.before(b)), (n = o.after(b)))
  }
}
function n0 (t, e, n, r, i) {
  if (e < n) {
    const o = t.firstChild
    t = t.replaceChild(0, o.copy(n0(o.content, e + 1, n, r, o)))
  }
  if (e > r) {
    const o = i.contentMatchAt(0)
    const s = o.fillBefore(t).append(t)
    t = s.append(o.matchFragment(s).fillBefore(K.empty, !0))
  }
  return t
}
function tR (t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    const i = ZO(t.doc, e, r.type)
    i != null && (e = n = i)
  }
  t.replaceRange(e, n, new Z(K.from(r), 0, 0))
}
function nR (t, e, n) {
  const r = t.doc.resolve(e)
  const i = t.doc.resolve(n)
  const o = r0(r, i)
  for (let s = 0; s < o.length; s++) {
    const l = o[s]
    const u = s == o.length - 1
    if ((u && l == 0) || r.node(l).type.contentMatch.validEnd) {
      return t.delete(r.start(l), i.end(l))
    }
    if (
      l > 0 &&
            (u || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1)))
    ) {
      return t.delete(r.before(l), i.after(l))
    }
  }
  for (let s = 1; s <= r.depth && s <= i.depth; s++) {
    if (
      e - r.start(s) == r.depth - s &&
            n > r.end(s) &&
            i.end(s) - n != i.depth - s &&
            r.start(s - 1) == i.start(s - 1) &&
            r.node(s - 1).canReplace(r.index(s - 1), i.index(s - 1))
    ) {
      return t.delete(r.before(s), n)
    }
  }
  t.delete(e, n)
}
function r0 (t, e) {
  const n = []
  const r = Math.min(t.depth, e.depth)
  for (let i = r; i >= 0; i--) {
    const o = t.start(i)
    if (
      o < t.pos - (t.depth - i) ||
            e.end(i) > e.pos + (e.depth - i) ||
            t.node(i).type.spec.isolating ||
            e.node(i).type.spec.isolating
    ) {
      break
    }
    (o == e.start(i) ||
            (i == t.depth &&
                i == e.depth &&
                t.parent.inlineContent &&
                e.parent.inlineContent &&
                i &&
                e.start(i - 1) == o - 1)) &&
            n.push(i)
  }
  return n
}
const Ol = class t extends zt {
  constructor (e, n, r) {
    super(), (this.pos = e), (this.attr = n), (this.value = r)
  }

  apply (e) {
    const n = e.nodeAt(this.pos)
    if (!n) return Gt.fail("No node at attribute step's position")
    const r = Object.create(null)
    for (const o in n.attrs) r[o] = n.attrs[o]
    r[this.attr] = this.value
    const i = n.type.create(r, null, n.marks)
    return Gt.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new Z(K.from(i), 0, n.isLeaf ? 0 : 1)
    )
  }

  getMap () {
    return Dr.empty
  }

  invert (e) {
    return new t(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr])
  }

  map (e) {
    const n = e.mapResult(this.pos, 1)
    return n.deletedAfter ? null : new t(n.pos, this.attr, this.value)
  }

  toJSON () {
    return {
      stepType: 'attr',
      pos: this.pos,
      attr: this.attr,
      value: this.value
    }
  }

  static fromJSON (e, n) {
    if (typeof n.pos !== 'number' || typeof n.attr !== 'string') {
      throw new RangeError('Invalid input for AttrStep.fromJSON')
    }
    return new t(n.pos, n.attr, n.value)
  }
}
zt.jsonID('attr', Ol)
const Rl = class t extends zt {
  constructor (e, n) {
    super(), (this.attr = e), (this.value = n)
  }

  apply (e) {
    const n = Object.create(null)
    for (const i in e.attrs) n[i] = e.attrs[i]
    n[this.attr] = this.value
    const r = e.type.create(n, e.content, e.marks)
    return Gt.ok(r)
  }

  getMap () {
    return Dr.empty
  }

  invert (e) {
    return new t(this.attr, e.attrs[this.attr])
  }

  map (e) {
    return this
  }

  toJSON () {
    return { stepType: 'docAttr', attr: this.attr, value: this.value }
  }

  static fromJSON (e, n) {
    if (typeof n.attr !== 'string') {
      throw new RangeError('Invalid input for DocAttrStep.fromJSON')
    }
    return new t(n.attr, n.value)
  }
}
zt.jsonID('docAttr', Rl)
let Po = class extends Error {}
Po = function t (e) {
  const n = Error.call(this, e)
  return (n.__proto__ = t.prototype), n
}
Po.prototype = Object.create(Error.prototype)
Po.prototype.constructor = Po
Po.prototype.name = 'TransformError'
const ui = class {
  constructor (e) {
    (this.doc = e),
    (this.steps = []),
    (this.docs = []),
    (this.mapping = new Us())
  }

  get before () {
    return this.docs.length ? this.docs[0] : this.doc
  }

  step (e) {
    const n = this.maybeStep(e)
    if (n.failed) throw new Po(n.failed)
    return this
  }

  maybeStep (e) {
    const n = e.apply(this.doc)
    return n.failed || this.addStep(e, n.doc), n
  }

  get docChanged () {
    return this.steps.length > 0
  }

  addStep (e, n) {
    this.docs.push(this.doc),
    this.steps.push(e),
    this.mapping.appendMap(e.getMap()),
    (this.doc = n)
  }

  replace (e, n = e, r = Z.empty) {
    const i = Gs(this.doc, e, n, r)
    return i && this.step(i), this
  }

  replaceWith (e, n, r) {
    return this.replace(e, n, new Z(K.from(r), 0, 0))
  }

  delete (e, n) {
    return this.replace(e, n, Z.empty)
  }

  insert (e, n) {
    return this.replaceWith(e, e, n)
  }

  replaceRange (e, n, r) {
    return eR(this, e, n, r), this
  }

  replaceRangeWith (e, n, r) {
    return tR(this, e, n, r), this
  }

  deleteRange (e, n) {
    return nR(this, e, n), this
  }

  lift (e, n) {
    return zO(this, e, n), this
  }

  join (e, n = 1) {
    return XO(this, e, n), this
  }

  wrap (e, n) {
    return KO(this, e, n), this
  }

  setBlockType (e, n = e, r, i = null) {
    return VO(this, e, n, r, i), this
  }

  setNodeMarkup (e, n, r = null, i) {
    return qO(this, e, n, r, i), this
  }

  setNodeAttribute (e, n, r) {
    return this.step(new Ol(e, n, r)), this
  }

  setDocAttribute (e, n) {
    return this.step(new Rl(e, n)), this
  }

  addNodeMark (e, n) {
    return this.step(new Ks(e, n)), this
  }

  removeNodeMark (e, n) {
    if (!(n instanceof Ge)) {
      const r = this.doc.nodeAt(e)
      if (!r) throw new RangeError('No node at position ' + e)
      if (((n = n.isInSet(r.marks)), !n)) return this
    }
    return this.step(new Vs(e, n)), this
  }

  split (e, n = 1, r) {
    return YO(this, e, n, r), this
  }

  addMark (e, n, r) {
    return FO(this, e, n, r), this
  }

  removeMark (e, n, r) {
    return HO(this, e, n, r), this
  }

  clearIncompatible (e, n, r) {
    return bf(this, e, n, r), this
  }
}
const yf = Object.create(null)
const ue = class {
  constructor (e, n, r) {
    (this.$anchor = e),
    (this.$head = n),
    (this.ranges = r || [new $o(e.min(n), e.max(n))])
  }

  get anchor () {
    return this.$anchor.pos
  }

  get head () {
    return this.$head.pos
  }

  get from () {
    return this.$from.pos
  }

  get to () {
    return this.$to.pos
  }

  get $from () {
    return this.ranges[0].$from
  }

  get $to () {
    return this.ranges[0].$to
  }

  get empty () {
    const e = this.ranges
    for (let n = 0; n < e.length; n++) {
      if (e[n].$from.pos != e[n].$to.pos) return !1
    }
    return !0
  }

  content () {
    return this.$from.doc.slice(this.from, this.to, !0)
  }

  replace (e, n = Z.empty) {
    let r = n.content.lastChild
    let i = null
    for (let l = 0; l < n.openEnd; l++) (i = r), (r = r.lastChild)
    const o = e.steps.length
    const s = this.ranges
    for (let l = 0; l < s.length; l++) {
      const { $from: u, $to: d } = s[l]
      const f = e.mapping.slice(o)
      e.replaceRange(f.map(u.pos), f.map(d.pos), l ? Z.empty : n),
      l == 0 &&
                    s0(e, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1)
    }
  }

  replaceWith (e, n) {
    const r = e.steps.length
    const i = this.ranges
    for (let o = 0; o < i.length; o++) {
      const { $from: s, $to: l } = i[o]
      const u = e.mapping.slice(r)
      const d = u.map(s.pos)
      const f = u.map(l.pos)
      o
        ? e.deleteRange(d, f)
        : (e.replaceRangeWith(d, f, n), s0(e, r, n.isInline ? -1 : 1))
    }
  }

  static findFrom (e, n, r = !1) {
    const i = e.parent.inlineContent
      ? new le(e)
      : Ho(e.node(0), e.parent, e.pos, e.index(), n, r)
    if (i) return i
    for (let o = e.depth - 1; o >= 0; o--) {
      const s =
                n < 0
                  ? Ho(
                    e.node(0),
                    e.node(o),
                    e.before(o + 1),
                    e.index(o),
                    n,
                    r
                  )
                  : Ho(
                    e.node(0),
                    e.node(o),
                    e.after(o + 1),
                    e.index(o) + 1,
                    n,
                    r
                  )
      if (s) return s
    }
    return null
  }

  static near (e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new fn(e.node(0))
  }

  static atStart (e) {
    return Ho(e, e, 0, 0, 1) || new fn(e)
  }

  static atEnd (e) {
    return Ho(e, e, e.content.size, e.childCount, -1) || new fn(e)
  }

  static fromJSON (e, n) {
    if (!n || !n.type) {
      throw new RangeError('Invalid input for Selection.fromJSON')
    }
    const r = yf[n.type]
    if (!r) throw new RangeError(`No selection type ${n.type} defined`)
    return r.fromJSON(e, n)
  }

  static jsonID (e, n) {
    if (e in yf) {
      throw new RangeError('Duplicate use of selection JSON ID ' + e)
    }
    return (yf[e] = n), (n.prototype.jsonID = e), n
  }

  getBookmark () {
    return le.between(this.$anchor, this.$head).getBookmark()
  }
}
ue.prototype.visible = !0
var $o = class {
  constructor (e, n) {
    (this.$from = e), (this.$to = n)
  }
}
let i0 = !1
function o0 (t) {
  !i0 &&
        !t.parent.inlineContent &&
        ((i0 = !0),
        console.warn(
          'TextSelection endpoint not pointing into a node with inline content (' +
                t.parent.type.name +
                ')'
        ))
}
var le = class t extends ue {
  constructor (e, n = e) {
    o0(e), o0(n), super(e, n)
  }

  get $cursor () {
    return this.$anchor.pos == this.$head.pos ? this.$head : null
  }

  map (e, n) {
    const r = e.resolve(n.map(this.head))
    if (!r.parent.inlineContent) return ue.near(r)
    const i = e.resolve(n.map(this.anchor))
    return new t(i.parent.inlineContent ? i : r, r)
  }

  replace (e, n = Z.empty) {
    if ((super.replace(e, n), n == Z.empty)) {
      const r = this.$from.marksAcross(this.$to)
      r && e.ensureMarks(r)
    }
  }

  eq (e) {
    return e instanceof t && e.anchor == this.anchor && e.head == this.head
  }

  getBookmark () {
    return new Ll(this.anchor, this.head)
  }

  toJSON () {
    return { type: 'text', anchor: this.anchor, head: this.head }
  }

  static fromJSON (e, n) {
    if (typeof n.anchor !== 'number' || typeof n.head !== 'number') {
      throw new RangeError('Invalid input for TextSelection.fromJSON')
    }
    return new t(e.resolve(n.anchor), e.resolve(n.head))
  }

  static create (e, n, r = n) {
    const i = e.resolve(n)
    return new this(i, r == n ? i : e.resolve(r))
  }

  static between (e, n, r) {
    const i = e.pos - n.pos
    if (((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent)) {
      const o = ue.findFrom(n, r, !0) || ue.findFrom(n, -r, !0)
      if (o) n = o.$head
      else return ue.near(n, r)
    }
    return (
      e.parent.inlineContent ||
                (i == 0
                  ? (e = n)
                  : ((e = (ue.findFrom(e, -r, !0) || ue.findFrom(e, r, !0))
                      .$anchor),
                    e.pos < n.pos != i < 0 && (e = n))),
      new t(e, n)
    )
  }
}
ue.jsonID('text', le)
var Ll = class t {
  constructor (e, n) {
    (this.anchor = e), (this.head = n)
  }

  map (e) {
    return new t(e.map(this.anchor), e.map(this.head))
  }

  resolve (e) {
    return le.between(e.resolve(this.anchor), e.resolve(this.head))
  }
}
const he = class t extends ue {
  constructor (e) {
    const n = e.nodeAfter
    const r = e.node(0).resolve(e.pos + n.nodeSize)
    super(e, r), (this.node = n)
  }

  map (e, n) {
    const { deleted: r, pos: i } = n.mapResult(this.anchor)
    const o = e.resolve(i)
    return r ? ue.near(o) : new t(o)
  }

  content () {
    return new Z(K.from(this.node), 0, 0)
  }

  eq (e) {
    return e instanceof t && e.anchor == this.anchor
  }

  toJSON () {
    return { type: 'node', anchor: this.anchor }
  }

  getBookmark () {
    return new vf(this.anchor)
  }

  static fromJSON (e, n) {
    if (typeof n.anchor !== 'number') {
      throw new RangeError('Invalid input for NodeSelection.fromJSON')
    }
    return new t(e.resolve(n.anchor))
  }

  static create (e, n) {
    return new t(e.resolve(n))
  }

  static isSelectable (e) {
    return !e.isText && e.type.spec.selectable !== !1
  }
}
he.prototype.visible = !1
ue.jsonID('node', he)
var vf = class t {
  constructor (e) {
    this.anchor = e
  }

  map (e) {
    const { deleted: n, pos: r } = e.mapResult(this.anchor)
    return n ? new Ll(r, r) : new t(r)
  }

  resolve (e) {
    const n = e.resolve(this.anchor)
    const r = n.nodeAfter
    return r && he.isSelectable(r) ? new he(n) : ue.near(n)
  }
}
var fn = class t extends ue {
  constructor (e) {
    super(e.resolve(0), e.resolve(e.content.size))
  }

  replace (e, n = Z.empty) {
    if (n == Z.empty) {
      e.delete(0, e.doc.content.size)
      const r = ue.atStart(e.doc)
      r.eq(e.selection) || e.setSelection(r)
    } else super.replace(e, n)
  }

  toJSON () {
    return { type: 'all' }
  }

  static fromJSON (e) {
    return new t(e)
  }

  map (e) {
    return new t(e)
  }

  eq (e) {
    return e instanceof t
  }

  getBookmark () {
    return rR
  }
}
ue.jsonID('all', fn)
var rR = {
  map () {
    return this
  },
  resolve (t) {
    return new fn(t)
  }
}
function Ho (t, e, n, r, i, o = !1) {
  if (e.inlineContent) return le.create(t, n)
  for (
    let s = r - (i > 0 ? 0 : 1);
    i > 0 ? s < e.childCount : s >= 0;
    s += i
  ) {
    const l = e.child(s)
    if (l.isAtom) {
      if (!o && he.isSelectable(l)) {
        return he.create(t, n - (i < 0 ? l.nodeSize : 0))
      }
    } else {
      const u = Ho(t, l, n + i, i < 0 ? l.childCount : 0, i, o)
      if (u) return u
    }
    n += l.nodeSize * i
  }
  return null
}
function s0 (t, e, n) {
  const r = t.steps.length - 1
  if (r < e) return
  const i = t.steps[r]
  if (!(i instanceof tn || i instanceof Ct)) return
  const o = t.mapping.maps[r]
  let s
  o.forEach((l, u, d, f) => {
    s == null && (s = f)
  }),
  t.setSelection(ue.near(t.doc.resolve(s), n))
}
const a0 = 1
const Dl = 2
const l0 = 4
const wf = class extends ui {
  constructor (e) {
    super(e.doc),
    (this.curSelectionFor = 0),
    (this.updated = 0),
    (this.meta = Object.create(null)),
    (this.time = Date.now()),
    (this.curSelection = e.selection),
    (this.storedMarks = e.storedMarks)
  }

  get selection () {
    return (
      this.curSelectionFor < this.steps.length &&
                ((this.curSelection = this.curSelection.map(
                  this.doc,
                  this.mapping.slice(this.curSelectionFor)
                )),
                (this.curSelectionFor = this.steps.length)),
      this.curSelection
    )
  }

  setSelection (e) {
    if (e.$from.doc != this.doc) {
      throw new RangeError(
        'Selection passed to setSelection must point at the current document'
      )
    }
    return (
      (this.curSelection = e),
      (this.curSelectionFor = this.steps.length),
      (this.updated = (this.updated | a0) & ~Dl),
      (this.storedMarks = null),
      this
    )
  }

  get selectionSet () {
    return (this.updated & a0) > 0
  }

  setStoredMarks (e) {
    return (this.storedMarks = e), (this.updated |= Dl), this
  }

  ensureMarks (e) {
    return (
      Ge.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
                this.setStoredMarks(e),
      this
    )
  }

  addStoredMark (e) {
    return this.ensureMarks(
      e.addToSet(this.storedMarks || this.selection.$head.marks())
    )
  }

  removeStoredMark (e) {
    return this.ensureMarks(
      e.removeFromSet(this.storedMarks || this.selection.$head.marks())
    )
  }

  get storedMarksSet () {
    return (this.updated & Dl) > 0
  }

  addStep (e, n) {
    super.addStep(e, n),
    (this.updated = this.updated & ~Dl),
    (this.storedMarks = null)
  }

  setTime (e) {
    return (this.time = e), this
  }

  replaceSelection (e) {
    return this.selection.replace(this, e), this
  }

  replaceSelectionWith (e, n = !0) {
    const r = this.selection
    return (
      n &&
                (e = e.mark(
                  this.storedMarks ||
                        (r.empty
                          ? r.$from.marks()
                          : r.$from.marksAcross(r.$to) || Ge.none)
                )),
      r.replaceWith(this, e),
      this
    )
  }

  deleteSelection () {
    return this.selection.replace(this), this
  }

  insertText (e, n, r) {
    const i = this.doc.type.schema
    if (n == null) {
      return e
        ? this.replaceSelectionWith(i.text(e), !0)
        : this.deleteSelection()
    }
    {
      if ((r == null && (r = n), (r = r ?? n), !e)) {
        return this.deleteRange(n, r)
      }
      let o = this.storedMarks
      if (!o) {
        const s = this.doc.resolve(n)
        o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r))
      }
      return (
        this.replaceRangeWith(n, r, i.text(e, o)),
        this.selection.empty ||
                    this.setSelection(ue.near(this.selection.$to)),
        this
      )
    }
  }

  setMeta (e, n) {
    return (this.meta[typeof e === 'string' ? e : e.key] = n), this
  }

  getMeta (e) {
    return this.meta[typeof e === 'string' ? e : e.key]
  }

  get isGeneric () {
    for (const e in this.meta) return !1
    return !0
  }

  scrollIntoView () {
    return (this.updated |= l0), this
  }

  get scrolledIntoView () {
    return (this.updated & l0) > 0
  }
}
function c0 (t, e) {
  return !e || !t ? t : t.bind(e)
}
const Vi = class {
  constructor (e, n, r) {
    (this.name = e),
    (this.init = c0(n.init, r)),
    (this.apply = c0(n.apply, r))
  }
}
const iR = [
  new Vi('doc', {
    init (t) {
      return t.doc || t.schema.topNodeType.createAndFill()
    },
    apply (t) {
      return t.doc
    }
  }),
  new Vi('selection', {
    init (t, e) {
      return t.selection || ue.atStart(e.doc)
    },
    apply (t) {
      return t.selection
    }
  }),
  new Vi('storedMarks', {
    init (t) {
      return t.storedMarks || null
    },
    apply (t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null
    }
  }),
  new Vi('scrollToSelection', {
    init () {
      return 0
    },
    apply (t, e) {
      return t.scrolledIntoView ? e + 1 : e
    }
  })
]
const qs = class {
  constructor (e, n) {
    (this.schema = e),
    (this.plugins = []),
    (this.pluginsByKey = Object.create(null)),
    (this.fields = iR.slice()),
    n &&
                n.forEach((r) => {
                  if (this.pluginsByKey[r.key]) {
                    throw new RangeError(
                      'Adding different instances of a keyed plugin (' +
                                r.key +
                                ')'
                    )
                  }
                  this.plugins.push(r),
                  (this.pluginsByKey[r.key] = r),
                  r.spec.state &&
                            this.fields.push(new Vi(r.key, r.spec.state, r))
                })
  }
}
const Pl = class t {
  constructor (e) {
    this.config = e
  }

  get schema () {
    return this.config.schema
  }

  get plugins () {
    return this.config.plugins
  }

  apply (e) {
    return this.applyTransaction(e).state
  }

  filterTransaction (e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++) {
      if (r != n) {
        const i = this.config.plugins[r]
        if (
          i.spec.filterTransaction &&
                    !i.spec.filterTransaction.call(i, e, this)
        ) {
          return !1
        }
      }
    }
    return !0
  }

  applyTransaction (e) {
    if (!this.filterTransaction(e)) {
      return { state: this, transactions: [] }
    }
    const n = [e]
    let r = this.applyInner(e)
    let i = null
    for (;;) {
      let o = !1
      for (let s = 0; s < this.config.plugins.length; s++) {
        const l = this.config.plugins[s]
        if (l.spec.appendTransaction) {
          const u = i ? i[s].n : 0
          const d = i ? i[s].state : this
          const f =
                        u < n.length &&
                        l.spec.appendTransaction.call(
                          l,
                          u ? n.slice(u) : n,
                          d,
                          r
                        )
          if (f && r.filterTransaction(f, s)) {
            if ((f.setMeta('appendedTransaction', e), !i)) {
              i = []
              for (
                let h = 0;
                h < this.config.plugins.length;
                h++
              ) {
                i.push(
                  h < s
                    ? { state: r, n: n.length }
                    : { state: this, n: 0 }
                )
              }
            }
            n.push(f), (r = r.applyInner(f)), (o = !0)
          }
          i && (i[s] = { state: r, n: n.length })
        }
      }
      if (!o) return { state: r, transactions: n }
    }
  }

  applyInner (e) {
    if (!e.before.eq(this.doc)) {
      throw new RangeError('Applying a mismatched transaction')
    }
    const n = new t(this.config)
    const r = this.config.fields
    for (let i = 0; i < r.length; i++) {
      const o = r[i]
      n[o.name] = o.apply(e, this[o.name], this, n)
    }
    return n
  }

  get tr () {
    return new wf(this)
  }

  static create (e) {
    const n = new qs(e.doc ? e.doc.type.schema : e.schema, e.plugins)
    const r = new t(n)
    for (let i = 0; i < n.fields.length; i++) {
      r[n.fields[i].name] = n.fields[i].init(e, r)
    }
    return r
  }

  reconfigure (e) {
    const n = new qs(this.schema, e.plugins)
    const r = n.fields
    const i = new t(n)
    for (let o = 0; o < r.length; o++) {
      const s = r[o].name
      i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(e, i)
    }
    return i
  }

  toJSON (e) {
    const n = {
      doc: this.doc.toJSON(),
      selection: this.selection.toJSON()
    }
    if (
      (this.storedMarks &&
                (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
      e && typeof e === 'object')
    ) {
      for (const r in e) {
        if (r == 'doc' || r == 'selection') {
          throw new RangeError(
            'The JSON fields `doc` and `selection` are reserved'
          )
        }
        const i = e[r]
        const o = i.spec.state
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]))
      }
    }
    return n
  }

  static fromJSON (e, n, r) {
    if (!n) {
      throw new RangeError('Invalid input for EditorState.fromJSON')
    }
    if (!e.schema) {
      throw new RangeError("Required config field 'schema' missing")
    }
    const i = new qs(e.schema, e.plugins)
    const o = new t(i)
    return (
      i.fields.forEach((s) => {
        if (s.name == 'doc') o.doc = $n.fromJSON(e.schema, n.doc)
        else if (s.name == 'selection') {
          o.selection = ue.fromJSON(o.doc, n.selection)
        } else if (s.name == 'storedMarks') {
          n.storedMarks &&
                        (o.storedMarks = n.storedMarks.map(
                          e.schema.markFromJSON
                        ))
        } else {
          if (r) {
            for (const l in r) {
              const u = r[l]
              const d = u.spec.state
              if (
                u.key == s.name &&
                                d &&
                                d.fromJSON &&
                                Object.prototype.hasOwnProperty.call(n, l)
              ) {
                o[s.name] = d.fromJSON.call(u, e, n[l], o)
                return
              }
            }
          }
          o[s.name] = s.init(e, o)
        }
      }),
      o
    )
  }
}
function u0 (t, e, n) {
  for (const r in t) {
    let i = t[r]
    i instanceof Function
      ? (i = i.bind(e))
      : r == 'handleDOMEvents' && (i = u0(i, e, {})),
    (n[r] = i)
  }
  return n
}
const Oe = class {
  constructor (e) {
    (this.spec = e),
    (this.props = {}),
    e.props && u0(e.props, this, this.props),
    (this.key = e.key ? e.key.key : d0('plugin'))
  }

  getState (e) {
    return e[this.key]
  }
}
const Ef = Object.create(null)
function d0 (t) {
  return t in Ef ? t + '$' + ++Ef[t] : ((Ef[t] = 0), t + '$')
}
const ze = class {
  constructor (e = 'key') {
    this.key = d0(e)
  }

  get (e) {
    return e.config.pluginsByKey[this.key]
  }

  getState (e) {
    return e[this.key]
  }
}
const qt = function (t) {
  for (let e = 0; ; e++) if (((t = t.previousSibling), !t)) return e
}
const Zs = function (t) {
  const e = t.assignedSlot || t.parentNode
  return e && e.nodeType == 11 ? e.host : e
}
let Af = null
const Br = function (t, e, n) {
  const r = Af || (Af = document.createRange())
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r
}
const oR = function () {
  Af = null
}
const ji = function (t, e, n, r) {
  return n && (f0(t, e, n, r, -1) || f0(t, e, n, r, 1))
}
const sR = /^(img|br|input|textarea|hr)$/i
function f0 (t, e, n, r, i) {
  for (;;) {
    if (t == n && e == r) return !0
    if (e == (i < 0 ? 0 : Wn(t))) {
      const o = t.parentNode
      if (
        !o ||
                o.nodeType != 1 ||
                ta(t) ||
                sR.test(t.nodeName) ||
                t.contentEditable == 'false'
      ) {
        return !1
      }
      (e = qt(t) + (i < 0 ? 0 : 1)), (t = o)
    } else if (t.nodeType == 1) {
      if (
        ((t = t.childNodes[e + (i < 0 ? -1 : 0)]),
        t.contentEditable == 'false')
      ) {
        return !1
      }
      e = i < 0 ? Wn(t) : 0
    } else return !1
  }
}
function Wn (t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function aR (t, e) {
  for (;;) {
    if (t.nodeType == 3 && e) return t
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == 'false') return null;
      (t = t.childNodes[e - 1]), (e = Wn(t))
    } else if (t.parentNode && !ta(t)) (e = qt(t)), (t = t.parentNode)
    else return null
  }
}
function lR (t, e) {
  for (;;) {
    if (t.nodeType == 3 && e < t.nodeValue.length) return t
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == 'false') return null;
      (t = t.childNodes[e]), (e = 0)
    } else if (t.parentNode && !ta(t)) (e = qt(t) + 1), (t = t.parentNode)
    else return null
  }
}
function cR (t, e, n) {
  for (let r = e == 0, i = e == Wn(t); r || i;) {
    if (t == n) return !0
    const o = qt(t)
    if (((t = t.parentNode), !t)) return !1;
    (r = r && o == 0), (i = i && o == Wn(t))
  }
}
function ta (t) {
  let e
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t)
}
const Yl = function (t) {
  return (
    t.focusNode &&
        ji(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
  )
}
function Gi (t, e) {
  const n = document.createEvent('Event')
  return (
    n.initEvent('keydown', !0, !0), (n.keyCode = t), (n.key = n.code = e), n
  )
}
function uR (t) {
  let e = t.activeElement
  for (; e && e.shadowRoot;) e = e.shadowRoot.activeElement
  return e
}
function dR (t, e, n) {
  if (t.caretPositionFromPoint) {
    try {
      const r = t.caretPositionFromPoint(e, n)
      if (r) {
        return {
          node: r.offsetNode,
          offset: Math.min(Wn(r.offsetNode), r.offset)
        }
      }
    } catch {}
  }
  if (t.caretRangeFromPoint) {
    const r = t.caretRangeFromPoint(e, n)
    if (r) {
      return {
        node: r.startContainer,
        offset: Math.min(Wn(r.startContainer), r.startOffset)
      }
    }
  }
}
const pr = typeof navigator < 'u' ? navigator : null
const p0 = typeof document < 'u' ? document : null
const gi = (pr && pr.userAgent) || ''
const Mf = /Edge\/(\d+)/.exec(gi)
const V0 = /MSIE \d/.exec(gi)
const Nf = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(gi)
const wn = !!(V0 || Nf || Mf)
const hi = V0 ? document.documentMode : Nf ? +Nf[1] : Mf ? +Mf[1] : 0
const ir = !wn && /gecko\/(\d+)/i.test(gi)
ir && +(/Firefox\/(\d+)/.exec(gi) || [0, 0])[1]
const kf = !wn && /Chrome\/(\d+)/.exec(gi)
const rn = !!kf
const G0 = kf ? +kf[1] : 0
const pn = !wn && !!pr && /Apple Computer/.test(pr.vendor)
const Vo = pn && (/Mobile\/\w+/.test(gi) || (!!pr && pr.maxTouchPoints > 2))
const Un = Vo || (pr ? /Mac/.test(pr.platform) : !1)
const fR = pr ? /Win/.test(pr.platform) : !1
const Fr = /Android \d/.test(gi)
const na = !!p0 && 'webkitFontSmoothing' in p0.documentElement.style
const pR = na
  ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
  : 0
function hR (t) {
  const e = t.defaultView && t.defaultView.visualViewport
  return e
    ? { left: 0, right: e.width, top: 0, bottom: e.height }
    : {
        left: 0,
        right: t.documentElement.clientWidth,
        top: 0,
        bottom: t.documentElement.clientHeight
      }
}
function Pr (t, e) {
  return typeof t === 'number' ? t : t[e]
}
function mR (t) {
  const e = t.getBoundingClientRect()
  const n = e.width / t.offsetWidth || 1
  const r = e.height / t.offsetHeight || 1
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  }
}
function h0 (t, e, n) {
  const r = t.someProp('scrollThreshold') || 0
  const i = t.someProp('scrollMargin') || 5
  const o = t.dom.ownerDocument
  for (let s = n || t.dom; s; s = Zs(s)) {
    if (s.nodeType != 1) continue
    const l = s
    const u = l == o.body
    const d = u ? hR(o) : mR(l)
    let f = 0
    let h = 0
    if (
      (e.top < d.top + Pr(r, 'top')
        ? (h = -(d.top - e.top + Pr(i, 'top')))
        : e.bottom > d.bottom - Pr(r, 'bottom') &&
                  (h =
                      e.bottom - e.top > d.bottom - d.top
                        ? e.top + Pr(i, 'top') - d.top
                        : e.bottom - d.bottom + Pr(i, 'bottom')),
      e.left < d.left + Pr(r, 'left')
        ? (f = -(d.left - e.left + Pr(i, 'left')))
        : e.right > d.right - Pr(r, 'right') &&
                  (f = e.right - d.right + Pr(i, 'right')),
      f || h)
    ) {
      if (u) o.defaultView.scrollBy(f, h)
      else {
        const m = l.scrollLeft
        const b = l.scrollTop
        h && (l.scrollTop += h), f && (l.scrollLeft += f)
        const g = l.scrollLeft - m
        const E = l.scrollTop - b
        e = {
          left: e.left - g,
          top: e.top - E,
          right: e.right - g,
          bottom: e.bottom - E
        }
      }
    }
    if (u || /^(fixed|sticky)$/.test(getComputedStyle(s).position)) break
  }
}
function gR (t) {
  const e = t.dom.getBoundingClientRect()
  const n = Math.max(0, e.top)
  let r
  let i
  for (
    let o = (e.left + e.right) / 2, s = n + 1;
    s < Math.min(innerHeight, e.bottom);
    s += 5
  ) {
    const l = t.root.elementFromPoint(o, s)
    if (!l || l == t.dom || !t.dom.contains(l)) continue
    const u = l.getBoundingClientRect()
    if (u.top >= n - 20) {
      (r = l), (i = u.top)
      break
    }
  }
  return { refDOM: r, refTop: i, stack: q0(t.dom) }
}
function q0 (t) {
  const e = []
  const n = t.ownerDocument
  for (
    let r = t;
    r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
    r = Zs(r)
  );
  return e
}
function bR ({ refDOM: t, refTop: e, stack: n }) {
  const r = t ? t.getBoundingClientRect().top : 0
  Y0(n, r == 0 ? 0 : r - e)
}
function Y0 (t, e) {
  for (let n = 0; n < t.length; n++) {
    const { dom: r, top: i, left: o } = t[n]
    r.scrollTop != i + e && (r.scrollTop = i + e),
    r.scrollLeft != o && (r.scrollLeft = o)
  }
}
let zo = null
function yR (t) {
  if (t.setActive) return t.setActive()
  if (zo) return t.focus(zo)
  const e = q0(t)
  t.focus(
    zo == null
      ? {
          get preventScroll () {
            return (zo = { preventScroll: !0 }), !0
          }
        }
      : void 0
  ),
  zo || ((zo = !1), Y0(e, 0))
}
function J0 (t, e) {
  let n
  let r = 2e8
  let i
  let o = 0
  let s = e.top
  let l = e.top
  let u
  let d
  for (let f = t.firstChild, h = 0; f; f = f.nextSibling, h++) {
    let m
    if (f.nodeType == 1) m = f.getClientRects()
    else if (f.nodeType == 3) m = Br(f).getClientRects()
    else continue
    for (let b = 0; b < m.length; b++) {
      const g = m[b]
      if (g.top <= s && g.bottom >= l) {
        (s = Math.max(g.bottom, s)), (l = Math.min(g.top, l))
        const E =
                    g.left > e.left
                      ? g.left - e.left
                      : g.right < e.left
                        ? e.left - g.right
                        : 0
        if (E < r) {
          (n = f),
          (r = E),
          (i =
                            E && n.nodeType == 3
                              ? {
                                  left: g.right < e.left ? g.right : g.left,
                                  top: e.top
                                }
                              : e),
          f.nodeType == 1 &&
                            E &&
                            (o =
                                h + (e.left >= (g.left + g.right) / 2 ? 1 : 0))
          continue
        }
      } else {
        g.top > e.top &&
                    !u &&
                    g.left <= e.left &&
                    g.right >= e.left &&
                    ((u = f),
                    (d = {
                      left: Math.max(g.left, Math.min(g.right, e.left)),
                      top: g.top
                    }))
      }
      !n &&
                ((e.left >= g.right && e.top >= g.top) ||
                    (e.left >= g.left && e.top >= g.bottom)) &&
                (o = h + 1)
    }
  }
  return (
    !n && u && ((n = u), (i = d), (r = 0)),
    n && n.nodeType == 3
      ? ER(n, i)
      : !n || (r && n.nodeType == 1)
          ? { node: t, offset: o }
          : J0(n, i)
  )
}
function ER (t, e) {
  const n = t.nodeValue.length
  const r = document.createRange()
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i)
    const o = di(r, 1)
    if (o.top != o.bottom && Vf(e, o)) {
      return {
        node: t,
        offset: i + (e.left >= (o.left + o.right) / 2 ? 1 : 0)
      }
    }
  }
  return { node: t, offset: 0 }
}
function Vf (t, e) {
  return (
    t.left >= e.left - 1 &&
        t.left <= e.right + 1 &&
        t.top >= e.top - 1 &&
        t.top <= e.bottom + 1
  )
}
function vR (t, e) {
  const n = t.parentNode
  return n &&
        /^li$/i.test(n.nodeName) &&
        e.left < t.getBoundingClientRect().left
    ? n
    : t
}
function wR (t, e, n) {
  const { node: r, offset: i } = J0(e, n)
  let o = -1
  if (r.nodeType == 1 && !r.firstChild) {
    const s = r.getBoundingClientRect()
    o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1
  }
  return t.docView.posFromDOM(r, i, o)
}
function xR (t, e, n, r) {
  let i = -1
  for (let o = e, s = !1; o != t.dom;) {
    const l = t.docView.nearestDesc(o, !0)
    let u
    if (!l) return null
    if (
      l.dom.nodeType == 1 &&
            ((l.node.isBlock && l.parent) || !l.contentDOM) &&
            ((u = l.dom.getBoundingClientRect()).width || u.height) &&
            (l.node.isBlock &&
                l.parent &&
                ((!s && u.left > r.left) || u.top > r.top
                  ? (i = l.posBefore)
                  : ((!s && u.right < r.left) || u.bottom < r.top) &&
                      (i = l.posAfter),
                (s = !0)),
            !l.contentDOM && i < 0 && !l.node.isText)
    ) {
      return (
        l.node.isBlock
          ? r.top < (u.top + u.bottom) / 2
          : r.left < (u.left + u.right) / 2
      )
        ? l.posBefore
        : l.posAfter
    }
    o = l.dom.parentNode
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1)
}
function X0 (t, e, n) {
  const r = t.childNodes.length
  if (r && n.top < n.bottom) {
    for (
      let i = Math.max(
          0,
          Math.min(
            r - 1,
            Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) -
                            2
          )
        ),
        o = i;
      ;

    ) {
      const s = t.childNodes[o]
      if (s.nodeType == 1) {
        const l = s.getClientRects()
        for (let u = 0; u < l.length; u++) {
          const d = l[u]
          if (Vf(e, d)) return X0(s, e, d)
        }
      }
      if ((o = (o + 1) % r) == i) break
    }
  }
  return t
}
function _R (t, e) {
  const n = t.dom.ownerDocument
  let r
  let i = 0
  const o = dR(n, e.left, e.top)
  o && ({ node: r, offset: i } = o)
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(
    e.left,
    e.top
  )
  let l
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    const d = t.dom.getBoundingClientRect()
    if (!Vf(e, d) || ((s = X0(t.dom, e, d)), !s)) return null
  }
  if (pn) for (let d = s; r && d; d = Zs(d)) d.draggable && (r = void 0)
  if (((s = vR(s, e)), r)) {
    if (
      ir &&
            r.nodeType == 1 &&
            ((i = Math.min(i, r.childNodes.length)), i < r.childNodes.length)
    ) {
      const f = r.childNodes[i]
      let h
      f.nodeName == 'IMG' &&
                (h = f.getBoundingClientRect()).right <= e.left &&
                h.bottom > e.top &&
                i++
    }
    let d
    na &&
            i &&
            r.nodeType == 1 &&
            (d = r.childNodes[i - 1]).nodeType == 1 &&
            d.contentEditable == 'false' &&
            d.getBoundingClientRect().top >= e.top &&
            i--,
    r == t.dom &&
            i == r.childNodes.length - 1 &&
            r.lastChild.nodeType == 1 &&
            e.top > r.lastChild.getBoundingClientRect().bottom
      ? (l = t.state.doc.content.size)
      : (i == 0 ||
                      r.nodeType != 1 ||
                      r.childNodes[i - 1].nodeName != 'BR') &&
                  (l = xR(t, r, i, e))
  }
  l == null && (l = wR(t, s, e))
  const u = t.docView.nearestDesc(s, !0)
  return { pos: l, inside: u ? u.posAtStart - u.border : -1 }
}
function m0 (t) {
  return t.top < t.bottom || t.left < t.right
}
function di (t, e) {
  const n = t.getClientRects()
  if (n.length) {
    const r = n[e < 0 ? 0 : n.length - 1]
    if (m0(r)) return r
  }
  return Array.prototype.find.call(n, m0) || t.getBoundingClientRect()
}
const SR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
function Z0 (t, e, n) {
  const {
    node: r,
    offset: i,
    atom: o
  } = t.docView.domFromPos(e, n < 0 ? -1 : 1)
  const s = na || ir
  if (r.nodeType == 3) {
    if (
      s &&
            (SR.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))
    ) {
      const u = di(Br(r, i, i), n)
      if (
        ir &&
                i &&
                /\s/.test(r.nodeValue[i - 1]) &&
                i < r.nodeValue.length
      ) {
        const d = di(Br(r, i - 1, i - 1), -1)
        if (d.top == u.top) {
          const f = di(Br(r, i, i + 1), -1)
          if (f.top != u.top) return Ys(f, f.left < d.left)
        }
      }
      return u
    } else {
      let u = i
      let d = i
      let f = n < 0 ? 1 : -1
      return (
        n < 0 && !i
          ? (d++, (f = -1))
          : n >= 0 && i == r.nodeValue.length
            ? (u--, (f = 1))
            : n < 0
              ? u--
              : d++,
        Ys(di(Br(r, u, d), f), f < 0)
      )
    }
  }
  if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == Wn(r))) {
      const u = r.childNodes[i - 1]
      if (u.nodeType == 1) return xf(u.getBoundingClientRect(), !1)
    }
    if (o == null && i < Wn(r)) {
      const u = r.childNodes[i]
      if (u.nodeType == 1) return xf(u.getBoundingClientRect(), !0)
    }
    return xf(r.getBoundingClientRect(), n >= 0)
  }
  if (o == null && i && (n < 0 || i == Wn(r))) {
    const u = r.childNodes[i - 1]
    const d =
            u.nodeType == 3
              ? Br(u, Wn(u) - (s ? 0 : 1))
              : u.nodeType == 1 && (u.nodeName != 'BR' || !u.nextSibling)
                ? u
                : null
    if (d) return Ys(di(d, 1), !1)
  }
  if (o == null && i < Wn(r)) {
    let u = r.childNodes[i]
    for (; u.pmViewDesc && u.pmViewDesc.ignoreForCoords;) {
      u = u.nextSibling
    }
    const d = u
      ? u.nodeType == 3
        ? Br(u, 0, s ? 0 : 1)
        : u.nodeType == 1
          ? u
          : null
      : null
    if (d) return Ys(di(d, -1), !0)
  }
  return Ys(di(r.nodeType == 3 ? Br(r) : r, -n), n >= 0)
}
function Ys (t, e) {
  if (t.width == 0) return t
  const n = e ? t.left : t.right
  return { top: t.top, bottom: t.bottom, left: n, right: n }
}
function xf (t, e) {
  if (t.height == 0) return t
  const n = e ? t.top : t.bottom
  return { top: n, bottom: n, left: t.left, right: t.right }
}
function j0 (t, e, n) {
  const r = t.state
  const i = t.root.activeElement
  r != e && t.updateState(e), i != t.dom && t.focus()
  try {
    return n()
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus()
  }
}
function TR (t, e, n) {
  const r = e.selection
  const i = n == 'up' ? r.$from : r.$to
  return j0(t, e, () => {
    let { node: o } = t.docView.domFromPos(i.pos, n == 'up' ? -1 : 1)
    for (;;) {
      const l = t.docView.nearestDesc(o, !0)
      if (!l) break
      if (l.node.isBlock) {
        o = l.contentDOM || l.dom
        break
      }
      o = l.dom.parentNode
    }
    const s = Z0(t, i.pos, 1)
    for (let l = o.firstChild; l; l = l.nextSibling) {
      let u
      if (l.nodeType == 1) u = l.getClientRects()
      else if (l.nodeType == 3) {
        u = Br(l, 0, l.nodeValue.length).getClientRects()
      } else continue
      for (let d = 0; d < u.length; d++) {
        const f = u[d]
        if (
          f.bottom > f.top + 1 &&
                    (n == 'up'
                      ? s.top - f.top > (f.bottom - s.top) * 2
                      : f.bottom - s.bottom > (s.bottom - f.top) * 2)
        ) {
          return !1
        }
      }
    }
    return !0
  })
}
const CR = /[\u0590-\u08ac]/
function AR (t, e, n) {
  const { $head: r } = e.selection
  if (!r.parent.isTextblock) return !1
  const i = r.parentOffset
  const o = !i
  const s = i == r.parent.content.size
  const l = t.domSelection()
  return l
    ? !CR.test(r.parent.textContent) || !l.modify
        ? n == 'left' || n == 'backward'
          ? o
          : s
        : j0(t, e, () => {
          const {
            focusNode: u,
            focusOffset: d,
            anchorNode: f,
            anchorOffset: h
          } = t.domSelectionRange()
          const m = l.caretBidiLevel
          l.modify('move', n, 'character')
          const b = r.depth ? t.docView.domAfterPos(r.before()) : t.dom
          const { focusNode: g, focusOffset: E } =
                      t.domSelectionRange()
          const w =
                      (g && !b.contains(g.nodeType == 1 ? g : g.parentNode)) ||
                      (u == g && d == E)
          try {
            l.collapse(f, h),
            u && (u != f || d != h) && l.extend && l.extend(u, d)
          } catch {}
          return m != null && (l.caretBidiLevel = m), w
        })
    : r.pos == r.start() || r.pos == r.end()
}
let g0 = null
let b0 = null
let y0 = !1
function MR (t, e, n) {
  return g0 == e && b0 == n
    ? y0
    : ((g0 = e),
      (b0 = n),
      (y0 = n == 'up' || n == 'down' ? TR(t, e, n) : AR(t, e, n)))
}
const Kn = 0
const E0 = 1
const qi = 2
const hr = 3
const Qi = class {
  constructor (e, n, r, i) {
    (this.parent = e),
    (this.children = n),
    (this.dom = r),
    (this.contentDOM = i),
    (this.dirty = Kn),
    (r.pmViewDesc = this)
  }

  matchesWidget (e) {
    return !1
  }

  matchesMark (e) {
    return !1
  }

  matchesNode (e, n, r) {
    return !1
  }

  matchesHack (e) {
    return !1
  }

  parseRule () {
    return null
  }

  stopEvent (e) {
    return !1
  }

  get size () {
    let e = 0
    for (let n = 0; n < this.children.length; n++) {
      e += this.children[n].size
    }
    return e
  }

  get border () {
    return 0
  }

  destroy () {
    (this.parent = void 0),
    this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0)
    for (let e = 0; e < this.children.length; e++) {
      this.children[e].destroy()
    }
  }

  posBeforeChild (e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      const i = this.children[n]
      if (i == e) return r
      r += i.size
    }
  }

  get posBefore () {
    return this.parent.posBeforeChild(this)
  }

  get posAtStart () {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
  }

  get posAfter () {
    return this.posBefore + this.size
  }

  get posAtEnd () {
    return this.posAtStart + this.size - 2 * this.border
  }

  localPosFromDOM (e, n, r) {
    if (
      this.contentDOM &&
            this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)
    ) {
      if (r < 0) {
        let o, s
        if (e == this.contentDOM) o = e.childNodes[n - 1]
        else {
          for (; e.parentNode != this.contentDOM;) {
            e = e.parentNode
          }
          o = e.previousSibling
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this);) {
          o = o.previousSibling
        }
        return o ? this.posBeforeChild(s) + s.size : this.posAtStart
      } else {
        let o, s
        if (e == this.contentDOM) o = e.childNodes[n]
        else {
          for (; e.parentNode != this.contentDOM;) {
            e = e.parentNode
          }
          o = e.nextSibling
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this);) {
          o = o.nextSibling
        }
        return o ? this.posBeforeChild(s) : this.posAtEnd
      }
    }
    let i
    if (e == this.dom && this.contentDOM) i = n > qt(this.contentDOM)
    else if (
      this.contentDOM &&
            this.contentDOM != this.dom &&
            this.dom.contains(this.contentDOM)
    ) {
      i = e.compareDocumentPosition(this.contentDOM) & 2
    } else if (this.dom.firstChild) {
      if (n == 0) {
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1
            break
          }
          if (o.previousSibling) break
        }
      }
      if (i == null && n == e.childNodes.length) {
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0
            break
          }
          if (o.nextSibling) break
        }
      }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart
  }

  nearestDesc (e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      const o = this.getDesc(i)
      let s
      if (o && (!n || o.node)) {
        if (
          r &&
                    (s = o.nodeDOM) &&
                    !(s.nodeType == 1
                      ? s.contains(e.nodeType == 1 ? e : e.parentNode)
                      : s == e)
        ) {
          r = !1
        } else return o
      }
    }
  }

  getDesc (e) {
    const n = e.pmViewDesc
    for (let r = n; r; r = r.parent) if (r == this) return n
  }

  posFromDOM (e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      const o = this.getDesc(i)
      if (o) return o.localPosFromDOM(e, n, r)
    }
    return -1
  }

  descAt (e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n]
      const o = r + i.size
      if (r == e && o != r) {
        for (; !i.border && i.children.length;) i = i.children[0]
        return i
      }
      if (e < o) return i.descAt(e - r - i.border)
      r = o
    }
  }

  domFromPos (e, n) {
    if (!this.contentDOM) {
      return { node: this.dom, offset: 0, atom: e + 1 }
    }
    let r = 0
    let i = 0
    for (let o = 0; r < this.children.length; r++) {
      const s = this.children[r]
      const l = o + s.size
      if (l > e || s instanceof Hl) {
        i = e - o
        break
      }
      o = l
    }
    if (i) {
      return this.children[r].domFromPos(i - this.children[r].border, n)
    }
    for (
      let o;
      r &&
            !(o = this.children[r - 1]).size &&
            o instanceof Bl &&
            o.side >= 0;
      r--
    );
    if (n <= 0) {
      let o
      let s = !0
      for (
        ;
        (o = r ? this.children[r - 1] : null),
        !(!o || o.dom.parentNode == this.contentDOM);
        r--, s = !1
      );
      return o && n && s && !o.border && !o.domAtom
        ? o.domFromPos(o.size, n)
        : { node: this.contentDOM, offset: o ? qt(o.dom) + 1 : 0 }
    } else {
      let o
      let s = !0
      for (
        ;
        (o = r < this.children.length ? this.children[r] : null),
        !(!o || o.dom.parentNode == this.contentDOM);
        r++, s = !1
      );
      return o && s && !o.border && !o.domAtom
        ? o.domFromPos(0, n)
        : {
            node: this.contentDOM,
            offset: o ? qt(o.dom) : this.contentDOM.childNodes.length
          }
    }
  }

  parseRange (e, n, r = 0) {
    if (this.children.length == 0) {
      return {
        node: this.contentDOM,
        from: e,
        to: n,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      }
    }
    let i = -1
    let o = -1
    for (let s = r, l = 0; ; l++) {
      const u = this.children[l]
      const d = s + u.size
      if (i == -1 && e <= d) {
        const f = s + u.border
        if (
          e >= f &&
                    n <= d - u.border &&
                    u.node &&
                    u.contentDOM &&
                    this.contentDOM.contains(u.contentDOM)
        ) {
          return u.parseRange(e, n, f)
        }
        e = s
        for (let h = l; h > 0; h--) {
          const m = this.children[h - 1]
          if (
            m.size &&
                        m.dom.parentNode == this.contentDOM &&
                        !m.emptyChildAt(1)
          ) {
            i = qt(m.dom) + 1
            break
          }
          e -= m.size
        }
        i == -1 && (i = 0)
      }
      if (i > -1 && (d > n || l == this.children.length - 1)) {
        n = d
        for (let f = l + 1; f < this.children.length; f++) {
          const h = this.children[f]
          if (
            h.size &&
                        h.dom.parentNode == this.contentDOM &&
                        !h.emptyChildAt(-1)
          ) {
            o = qt(h.dom)
            break
          }
          n += h.size
        }
        o == -1 && (o = this.contentDOM.childNodes.length)
        break
      }
      s = d
    }
    return {
      node: this.contentDOM,
      from: e,
      to: n,
      fromOffset: i,
      toOffset: o
    }
  }

  emptyChildAt (e) {
    if (this.border || !this.contentDOM || !this.children.length) {
      return !1
    }
    const n = this.children[e < 0 ? 0 : this.children.length - 1]
    return n.size == 0 || n.emptyChildAt(e)
  }

  domAfterPos (e) {
    const { node: n, offset: r } = this.domFromPos(e, 0)
    if (n.nodeType != 1 || r == n.childNodes.length) {
      throw new RangeError('No node after pos ' + e)
    }
    return n.childNodes[r]
  }

  setSelection (e, n, r, i = !1) {
    const o = Math.min(e, n)
    const s = Math.max(e, n)
    for (let b = 0, g = 0; b < this.children.length; b++) {
      const E = this.children[b]
      const w = g + E.size
      if (o > g && s < w) {
        return E.setSelection(e - g - E.border, n - g - E.border, r, i)
      }
      g = w
    }
    let l = this.domFromPos(e, e ? -1 : 1)
    let u = n == e ? l : this.domFromPos(n, n ? -1 : 1)
    const d = r.root.getSelection()
    const f = r.domSelectionRange()
    let h = !1
    if ((ir || pn) && e == n) {
      const { node: b, offset: g } = l
      if (b.nodeType == 3) {
        if (
          ((h = !!(
            g &&
                        b.nodeValue[g - 1] ==
                            `
`
          )),
          h && g == b.nodeValue.length)
        ) {
          for (let E = b, w; E; E = E.parentNode) {
            if ((w = E.nextSibling)) {
              w.nodeName == 'BR' &&
                                (l = u =
                                    {
                                      node: w.parentNode,
                                      offset: qt(w) + 1
                                    })
              break
            }
            const S = E.pmViewDesc
            if (S && S.node && S.node.isBlock) break
          }
        }
      } else {
        const E = b.childNodes[g - 1]
        h = E && (E.nodeName == 'BR' || E.contentEditable == 'false')
      }
    }
    if (
      ir &&
            f.focusNode &&
            f.focusNode != u.node &&
            f.focusNode.nodeType == 1
    ) {
      const b = f.focusNode.childNodes[f.focusOffset]
      b && b.contentEditable == 'false' && (i = !0)
    }
    if (
      !(i || (h && pn)) &&
            ji(l.node, l.offset, f.anchorNode, f.anchorOffset) &&
            ji(u.node, u.offset, f.focusNode, f.focusOffset)
    ) {
      return
    }
    let m = !1
    if ((d.extend || e == n) && !h) {
      d.collapse(l.node, l.offset)
      try {
        e != n && d.extend(u.node, u.offset), (m = !0)
      } catch {}
    }
    if (!m) {
      if (e > n) {
        const g = l;
        (l = u), (u = g)
      }
      const b = document.createRange()
      b.setEnd(u.node, u.offset),
      b.setStart(l.node, l.offset),
      d.removeAllRanges(),
      d.addRange(b)
    }
  }

  ignoreMutation (e) {
    return !this.contentDOM && e.type != 'selection'
  }

  get contentLost () {
    return (
      this.contentDOM &&
            this.contentDOM != this.dom &&
            !this.dom.contains(this.contentDOM)
    )
  }

  markDirty (e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      const o = this.children[i]
      const s = r + o.size
      if (r == s ? e <= s && n >= r : e < s && n > r) {
        const l = r + o.border
        const u = s - o.border
        if (e >= l && n <= u) {
          (this.dirty = e == r || n == s ? qi : E0),
          e == l &&
                        n == u &&
                        (o.contentLost || o.dom.parentNode != this.contentDOM)
            ? (o.dirty = hr)
            : o.markDirty(e - l, n - l)
          return
        } else {
          o.dirty =
                        o.dom == o.contentDOM &&
                        o.dom.parentNode == this.contentDOM &&
                        !o.children.length
                          ? qi
                          : hr
        }
      }
      r = s
    }
    this.dirty = qi
  }

  markParentsDirty () {
    let e = 1
    for (let n = this.parent; n; n = n.parent, e++) {
      const r = e == 1 ? qi : E0
      n.dirty < r && (n.dirty = r)
    }
  }

  get domAtom () {
    return !1
  }

  get ignoreForCoords () {
    return !1
  }

  isText (e) {
    return !1
  }
}
var Bl = class extends Qi {
  constructor (e, n, r, i) {
    let o
    let s = n.type.toDOM
    if (
      (typeof s === 'function' &&
                (s = s(r, () => {
                  if (!o) return i
                  if (o.parent) return o.parent.posBeforeChild(o)
                })),
      !n.type.spec.raw)
    ) {
      if (s.nodeType != 1) {
        const l = document.createElement('span')
        l.appendChild(s), (s = l)
      }
      (s.contentEditable = 'false'),
      s.classList.add('ProseMirror-widget')
    }
    super(e, [], s, null), (this.widget = n), (this.widget = n), (o = this)
  }

  matchesWidget (e) {
    return this.dirty == Kn && e.type.eq(this.widget.type)
  }

  parseRule () {
    return { ignore: !0 }
  }

  stopEvent (e) {
    const n = this.widget.spec.stopEvent
    return n ? n(e) : !1
  }

  ignoreMutation (e) {
    return e.type != 'selection' || this.widget.spec.ignoreSelection
  }

  destroy () {
    this.widget.type.destroy(this.dom), super.destroy()
  }

  get domAtom () {
    return !0
  }

  get side () {
    return this.widget.type.side
  }
}
const Of = class extends Qi {
  constructor (e, n, r, i) {
    super(e, [], n, null), (this.textDOM = r), (this.text = i)
  }

  get size () {
    return this.text.length
  }

  localPosFromDOM (e, n) {
    return e != this.textDOM
      ? this.posAtStart + (n ? this.size : 0)
      : this.posAtStart + n
  }

  domFromPos (e) {
    return { node: this.textDOM, offset: e }
  }

  ignoreMutation (e) {
    return e.type === 'characterData' && e.target.nodeValue == e.oldValue
  }
}
const Go = class t extends Qi {
  constructor (e, n, r, i, o) {
    super(e, [], r, i), (this.mark = n), (this.spec = o)
  }

  static create (e, n, r, i) {
    const o = i.nodeViews[n.type.name]
    let s = o && o(n, i, r)
    return (
      (!s || !s.dom) &&
                (s = Ir.renderSpec(
                  document,
                  n.type.spec.toDOM(n, r),
                  null,
                  n.attrs
                )),
      new t(e, n, s.dom, s.contentDOM || s.dom, s)
    )
  }

  parseRule () {
    return this.dirty & hr || this.mark.type.spec.reparseInView
      ? null
      : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM
        }
  }

  matchesMark (e) {
    return this.dirty != hr && this.mark.eq(e)
  }

  markDirty (e, n) {
    if ((super.markDirty(e, n), this.dirty != Kn)) {
      let r = this.parent
      for (; !r.node;) r = r.parent
      r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = Kn)
    }
  }

  slice (e, n, r) {
    const i = t.create(this.parent, this.mark, !0, r)
    let o = this.children
    const s = this.size
    n < s && (o = Lf(o, n, s, r)), e > 0 && (o = Lf(o, 0, e, r))
    for (let l = 0; l < o.length; l++) o[l].parent = i
    return (i.children = o), i
  }

  ignoreMutation (e) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(e)
      : super.ignoreMutation(e)
  }

  destroy () {
    this.spec.destroy && this.spec.destroy(), super.destroy()
  }
}
const mi = class t extends Qi {
  constructor (e, n, r, i, o, s, l, u, d) {
    super(e, [], o, s),
    (this.node = n),
    (this.outerDeco = r),
    (this.innerDeco = i),
    (this.nodeDOM = l)
  }

  static create (e, n, r, i, o, s) {
    const l = o.nodeViews[n.type.name]
    let u
    const d =
            l &&
            l(
              n,
              o,
              () => {
                if (!u) return s
                if (u.parent) return u.parent.posBeforeChild(u)
              },
              r,
              i
            )
    let f = d && d.dom
    let h = d && d.contentDOM
    if (n.isText) {
      if (!f) f = document.createTextNode(n.text)
      else if (f.nodeType != 3) {
        throw new RangeError(
          'Text must be rendered as a DOM text node'
        )
      }
    } else {
      f ||
                ({ dom: f, contentDOM: h } = Ir.renderSpec(
                  document,
                  n.type.spec.toDOM(n),
                  null,
                  n.attrs
                ))
    }
    !h &&
            !n.isText &&
            f.nodeName != 'BR' &&
            (f.hasAttribute('contenteditable') || (f.contentEditable = 'false'),
            n.type.spec.draggable && (f.draggable = !0))
    const m = f
    return (
      (f = tE(f, r, n)),
      d
        ? (u = new Rf(e, n, r, i, f, h || null, m, d, o, s + 1))
        : n.isText
          ? new Fl(e, n, r, i, f, m, o)
          : new t(e, n, r, i, f, h || null, m, o, s + 1)
    )
  }

  parseRule () {
    if (this.node.type.spec.reparseInView) return null
    const e = { node: this.node.type.name, attrs: this.node.attrs }
    if (
      (this.node.type.whitespace == 'pre' &&
                (e.preserveWhitespace = 'full'),
      !this.contentDOM)
    ) {
      e.getContent = () => this.node.content
    } else if (!this.contentLost) e.contentElement = this.contentDOM
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        const r = this.children[n]
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode
          break
        }
      }
      e.contentElement || (e.getContent = () => K.empty)
    }
    return e
  }

  matchesNode (e, n, r) {
    return (
      this.dirty == Kn &&
            e.eq(this.node) &&
            $l(n, this.outerDeco) &&
            r.eq(this.innerDeco)
    )
  }

  get size () {
    return this.node.nodeSize
  }

  get border () {
    return this.node.isLeaf ? 0 : 1
  }

  updateChildren (e, n) {
    const r = this.node.inlineContent
    let i = n
    const o = e.composing ? this.localCompositionInfo(e, n) : null
    const s = o && o.pos > -1 ? o : null
    const l = o && o.pos < 0
    const u = new Df(this, s && s.node, e)
    RR(
      this.node,
      this.innerDeco,
      (d, f, h) => {
        d.spec.marks
          ? u.syncToMarks(d.spec.marks, r, e)
          : d.type.side >= 0 &&
                      !h &&
                      u.syncToMarks(
                        f == this.node.childCount
                          ? Ge.none
                          : this.node.child(f).marks,
                        r,
                        e
                      ),
        u.placeWidget(d, e, i)
      },
      (d, f, h, m) => {
        u.syncToMarks(d.marks, r, e)
        let b
        u.findNodeMatch(d, f, h, m) ||
                    (l &&
                        e.state.selection.from > i &&
                        e.state.selection.to < i + d.nodeSize &&
                        (b = u.findIndexWithChild(o.node)) > -1 &&
                        u.updateNodeAt(d, f, h, b, e)) ||
                    u.updateNextNode(d, f, h, e, m, i) ||
                    u.addNode(d, f, h, e, i),
        (i += d.nodeSize)
      }
    ),
    u.syncToMarks([], r, e),
    this.node.isTextblock && u.addTextblockHacks(),
    u.destroyRest(),
    (u.changed || this.dirty == qi) &&
                (s && this.protectLocalComposition(e, s),
                Q0(this.contentDOM, this.children, e),
                Vo && IR(this.dom))
  }

  localCompositionInfo (e, n) {
    const { from: r, to: i } = e.state.selection
    if (
      !(e.state.selection instanceof le) ||
            r < n ||
            i > n + this.node.content.size
    ) {
      return null
    }
    const o = e.input.compositionNode
    if (!o || !this.dom.contains(o.parentNode)) return null
    if (this.node.inlineContent) {
      const s = o.nodeValue
      const l = DR(this.node.content, s, r - n, i - n)
      return l < 0 ? null : { node: o, pos: l, text: s }
    } else return { node: o, pos: -1, text: '' }
  }

  protectLocalComposition (e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n)) return
    let o = n
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling;) {
        o.parentNode.removeChild(o.previousSibling)
      }
      for (; o.nextSibling;) o.parentNode.removeChild(o.nextSibling)
      o.pmViewDesc && (o.pmViewDesc = void 0)
    }
    const s = new Of(this, o, n, i)
    e.input.compositionNodes.push(s),
    (this.children = Lf(this.children, r, r + i.length, e, s))
  }

  update (e, n, r, i) {
    return this.dirty == hr || !e.sameMarkup(this.node)
      ? !1
      : (this.updateInner(e, n, r, i), !0)
  }

  updateInner (e, n, r, i) {
    this.updateOuterDeco(n),
    (this.node = e),
    (this.innerDeco = r),
    this.contentDOM && this.updateChildren(i, this.posAtStart),
    (this.dirty = Kn)
  }

  updateOuterDeco (e) {
    if ($l(e, this.outerDeco)) return
    const n = this.nodeDOM.nodeType != 1
    const r = this.dom;
    (this.dom = eE(
      this.dom,
      this.nodeDOM,
      If(this.outerDeco, this.node, n),
      If(e, this.node, n)
    )),
    this.dom != r &&
                ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
    (this.outerDeco = e)
  }

  selectNode () {
    this.nodeDOM.nodeType == 1 &&
            this.nodeDOM.classList.add('ProseMirror-selectednode'),
    (this.contentDOM || !this.node.type.spec.draggable) &&
                (this.dom.draggable = !0)
  }

  deselectNode () {
    this.nodeDOM.nodeType == 1 &&
            (this.nodeDOM.classList.remove('ProseMirror-selectednode'),
            (this.contentDOM || !this.node.type.spec.draggable) &&
                this.dom.removeAttribute('draggable'))
  }

  get domAtom () {
    return this.node.isAtom
  }
}
function v0 (t, e, n, r, i) {
  tE(r, e, t)
  const o = new mi(void 0, t, e, n, r, r, r, i, 0)
  return o.contentDOM && o.updateChildren(i, 0), o
}
var Fl = class t extends mi {
  constructor (e, n, r, i, o, s, l) {
    super(e, n, r, i, o, null, s, l, 0)
  }

  parseRule () {
    let e = this.nodeDOM.parentNode
    for (; e && e != this.dom && !e.pmIsDeco;) e = e.parentNode
    return { skip: e || !0 }
  }

  update (e, n, r, i) {
    return this.dirty == hr ||
            (this.dirty != Kn && !this.inParent()) ||
            !e.sameMarkup(this.node)
      ? !1
      : (this.updateOuterDeco(n),
        (this.dirty != Kn || e.text != this.node.text) &&
                  e.text != this.nodeDOM.nodeValue &&
                  ((this.nodeDOM.nodeValue = e.text),
                  i.trackWrites == this.nodeDOM && (i.trackWrites = null)),
        (this.node = e),
        (this.dirty = Kn),
        !0)
  }

  inParent () {
    const e = this.parent.contentDOM
    for (let n = this.nodeDOM; n; n = n.parentNode) {
      if (n == e) return !0
    }
    return !1
  }

  domFromPos (e) {
    return { node: this.nodeDOM, offset: e }
  }

  localPosFromDOM (e, n, r) {
    return e == this.nodeDOM
      ? this.posAtStart + Math.min(n, this.node.text.length)
      : super.localPosFromDOM(e, n, r)
  }

  ignoreMutation (e) {
    return e.type != 'characterData' && e.type != 'selection'
  }

  slice (e, n, r) {
    const i = this.node.cut(e, n)
    const o = document.createTextNode(i.text)
    return new t(this.parent, i, this.outerDeco, this.innerDeco, o, o, r)
  }

  markDirty (e, n) {
    super.markDirty(e, n),
    this.dom != this.nodeDOM &&
                (e == 0 || n == this.nodeDOM.nodeValue.length) &&
                (this.dirty = hr)
  }

  get domAtom () {
    return !1
  }

  isText (e) {
    return this.node.text == e
  }
}
var Hl = class extends Qi {
  parseRule () {
    return { ignore: !0 }
  }

  matchesHack (e) {
    return this.dirty == Kn && this.dom.nodeName == e
  }

  get domAtom () {
    return !0
  }

  get ignoreForCoords () {
    return this.dom.nodeName == 'IMG'
  }
}
var Rf = class extends mi {
  constructor (e, n, r, i, o, s, l, u, d, f) {
    super(e, n, r, i, o, s, l, d, f), (this.spec = u)
  }

  update (e, n, r, i) {
    if (this.dirty == hr) return !1
    if (
      this.spec.update &&
            (this.node.type == e.type || this.spec.multiType)
    ) {
      const o = this.spec.update(e, n, r)
      return o && this.updateInner(e, n, r, i), o
    } else {
      return !this.contentDOM && !e.isLeaf
        ? !1
        : super.update(e, n, r, i)
    }
  }

  selectNode () {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
  }

  deselectNode () {
    this.spec.deselectNode
      ? this.spec.deselectNode()
      : super.deselectNode()
  }

  setSelection (e, n, r, i) {
    this.spec.setSelection
      ? this.spec.setSelection(e, n, r.root)
      : super.setSelection(e, n, r, i)
  }

  destroy () {
    this.spec.destroy && this.spec.destroy(), super.destroy()
  }

  stopEvent (e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1
  }

  ignoreMutation (e) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(e)
      : super.ignoreMutation(e)
  }
}
function Q0 (t, e, n) {
  let r = t.firstChild
  let i = !1
  for (let o = 0; o < e.length; o++) {
    const s = e[o]
    const l = s.dom
    if (l.parentNode == t) {
      for (; l != r;) (r = w0(r)), (i = !0)
      r = r.nextSibling
    } else (i = !0), t.insertBefore(l, r)
    if (s instanceof Go) {
      const u = r ? r.previousSibling : t.lastChild
      Q0(s.contentDOM, s.children, n),
      (r = u ? u.nextSibling : t.firstChild)
    }
  }
  for (; r;) (r = w0(r)), (i = !0)
  i && n.trackWrites == t && (n.trackWrites = null)
}
const Js = function (t) {
  t && (this.nodeName = t)
}
Js.prototype = Object.create(null)
const Yi = [new Js()]
function If (t, e, n) {
  if (t.length == 0) return Yi
  let r = n ? Yi[0] : new Js()
  const i = [r]
  for (let o = 0; o < t.length; o++) {
    const s = t[o].type.attrs
    if (s) {
      s.nodeName && i.push((r = new Js(s.nodeName)))
      for (const l in s) {
        const u = s[l]
        u != null &&
                    (n &&
                        i.length == 1 &&
                        i.push((r = new Js(e.isInline ? 'span' : 'div'))),
                    l == 'class'
                      ? (r.class = (r.class ? r.class + ' ' : '') + u)
                      : l == 'style'
                        ? (r.style = (r.style ? r.style + ';' : '') + u)
                        : l != 'nodeName' && (r[l] = u))
      }
    }
  }
  return i
}
function eE (t, e, n, r) {
  if (n == Yi && r == Yi) return e
  let i = e
  for (let o = 0; o < r.length; o++) {
    const s = r[o]
    let l = n[o]
    if (o) {
      let u;
      (l &&
                l.nodeName == s.nodeName &&
                i != t &&
                (u = i.parentNode) &&
                u.nodeName.toLowerCase() == s.nodeName) ||
                ((u = document.createElement(s.nodeName)),
                (u.pmIsDeco = !0),
                u.appendChild(i),
                (l = Yi[0])),
      (i = u)
    }
    NR(i, l || Yi[0], s)
  }
  return i
}
function NR (t, e, n) {
  for (const r in e) {
    r != 'class' &&
            r != 'style' &&
            r != 'nodeName' &&
            !(r in n) &&
            t.removeAttribute(r)
  }
  for (const r in n) {
    r != 'class' &&
            r != 'style' &&
            r != 'nodeName' &&
            n[r] != e[r] &&
            t.setAttribute(r, n[r])
  }
  if (e.class != n.class) {
    const r = e.class ? e.class.split(' ').filter(Boolean) : []
    const i = n.class ? n.class.split(' ').filter(Boolean) : []
    for (let o = 0; o < r.length; o++) {
      i.indexOf(r[o]) == -1 && t.classList.remove(r[o])
    }
    for (let o = 0; o < i.length; o++) {
      r.indexOf(i[o]) == -1 && t.classList.add(i[o])
    }
    t.classList.length == 0 && t.removeAttribute('class')
  }
  if (e.style != n.style) {
    if (e.style) {
      const r =
                /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g
      let i
      for (; (i = r.exec(e.style));) t.style.removeProperty(i[1])
    }
    n.style && (t.style.cssText += n.style)
  }
}
function tE (t, e, n) {
  return eE(t, t, Yi, If(e, n, t.nodeType != 1))
}
function $l (t, e) {
  if (t.length != e.length) return !1
  for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1
  return !0
}
function w0 (t) {
  const e = t.nextSibling
  return t.parentNode.removeChild(t), e
}
var Df = class {
  constructor (e, n, r) {
    (this.lock = n),
    (this.view = r),
    (this.index = 0),
    (this.stack = []),
    (this.changed = !1),
    (this.top = e),
    (this.preMatch = kR(e.node.content, e))
  }

  destroyBetween (e, n) {
    if (e != n) {
      for (let r = e; r < n; r++) this.top.children[r].destroy()
      this.top.children.splice(e, n - e), (this.changed = !0)
    }
  }

  destroyRest () {
    this.destroyBetween(this.index, this.top.children.length)
  }

  syncToMarks (e, n, r) {
    let i = 0
    let o = this.stack.length >> 1
    const s = Math.min(o, e.length)
    for (
      ;
      i < s &&
            (i == o - 1 ? this.top : this.stack[(i + 1) << 1]).matchesMark(
              e[i]
            ) &&
            e[i].type.spec.spanning !== !1;

    ) {
      i++
    }
    for (; i < o;) {
      this.destroyRest(),
      (this.top.dirty = Kn),
      (this.index = this.stack.pop()),
      (this.top = this.stack.pop()),
      o--
    }
    for (; o < e.length;) {
      this.stack.push(this.top, this.index + 1)
      let l = -1
      for (
        let u = this.index;
        u < Math.min(this.index + 3, this.top.children.length);
        u++
      ) {
        const d = this.top.children[u]
        if (d.matchesMark(e[o]) && !this.isLocked(d.dom)) {
          l = u
          break
        }
      }
      if (l > -1) {
        l > this.index &&
                    ((this.changed = !0), this.destroyBetween(this.index, l)),
        (this.top = this.top.children[this.index])
      } else {
        const u = Go.create(this.top, e[o], n, r)
        this.top.children.splice(this.index, 0, u),
        (this.top = u),
        (this.changed = !0)
      }
      (this.index = 0), o++
    }
  }

  findNodeMatch (e, n, r, i) {
    let o = -1
    let s
    if (
      i >= this.preMatch.index &&
            (s = this.preMatch.matches[i - this.preMatch.index]).parent ==
                this.top &&
            s.matchesNode(e, n, r)
    ) {
      o = this.top.children.indexOf(s, this.index)
    } else {
      for (
        let l = this.index,
          u = Math.min(this.top.children.length, l + 5);
        l < u;
        l++
      ) {
        const d = this.top.children[l]
        if (d.matchesNode(e, n, r) && !this.preMatch.matched.has(d)) {
          o = l
          break
        }
      }
    }
    return o < 0
      ? !1
      : (this.destroyBetween(this.index, o), this.index++, !0)
  }

  updateNodeAt (e, n, r, i, o) {
    const s = this.top.children[i]
    return (
      s.dirty == hr && s.dom == s.contentDOM && (s.dirty = qi),
      s.update(e, n, r, o)
        ? (this.destroyBetween(this.index, i), this.index++, !0)
        : !1
    )
  }

  findIndexWithChild (e) {
    for (;;) {
      const n = e.parentNode
      if (!n) return -1
      if (n == this.top.contentDOM) {
        const r = e.pmViewDesc
        if (r) {
          for (
            let i = this.index;
            i < this.top.children.length;
            i++
          ) {
            if (this.top.children[i] == r) return i
          }
        }
        return -1
      }
      e = n
    }
  }

  updateNextNode (e, n, r, i, o, s) {
    for (let l = this.index; l < this.top.children.length; l++) {
      const u = this.top.children[l]
      if (u instanceof mi) {
        const d = this.preMatch.matched.get(u)
        if (d != null && d != o) return !1
        const f = u.dom
        let h
        const m =
                    this.isLocked(f) &&
                    !(
                      e.isText &&
                        u.node &&
                        u.node.isText &&
                        u.nodeDOM.nodeValue == e.text &&
                        u.dirty != hr &&
                        $l(n, u.outerDeco)
                    )
        if (!m && u.update(e, n, r, i)) {
          return (
            this.destroyBetween(this.index, l),
            u.dom != f && (this.changed = !0),
            this.index++,
            !0
          )
        }
        if (!m && (h = this.recreateWrapper(u, e, n, r, i, s))) {
          return (
            this.destroyBetween(this.index, l),
            (this.top.children[this.index] = h),
            h.contentDOM &&
                            ((h.dirty = qi),
                            h.updateChildren(i, s + 1),
                            (h.dirty = Kn)),
            (this.changed = !0),
            this.index++,
            !0
          )
        }
        break
      }
    }
    return !1
  }

  recreateWrapper (e, n, r, i, o, s) {
    if (
      e.dirty ||
            n.isAtom ||
            !e.children.length ||
            !e.node.content.eq(n.content) ||
            !$l(r, e.outerDeco) ||
            !i.eq(e.innerDeco)
    ) {
      return null
    }
    const l = mi.create(this.top, n, r, i, o, s)
    if (l.contentDOM) {
      (l.children = e.children), (e.children = [])
      for (const u of l.children) u.parent = l
    }
    return e.destroy(), l
  }

  addNode (e, n, r, i, o) {
    const s = mi.create(this.top, e, n, r, i, o)
    s.contentDOM && s.updateChildren(i, o + 1),
    this.top.children.splice(this.index++, 0, s),
    (this.changed = !0)
  }

  placeWidget (e, n, r) {
    const i =
            this.index < this.top.children.length
              ? this.top.children[this.index]
              : null
    if (
      i &&
            i.matchesWidget(e) &&
            (e == i.widget || !i.widget.type.toDOM.parentNode)
    ) {
      this.index++
    } else {
      const o = new Bl(this.top, e, n, r)
      this.top.children.splice(this.index++, 0, o), (this.changed = !0)
    }
  }

  addTextblockHacks () {
    let e = this.top.children[this.index - 1]
    let n = this.top
    for (; e instanceof Go;) {
      (n = e), (e = n.children[n.children.length - 1])
    }
    (!e ||
            !(e instanceof Fl) ||
            /\n$/.test(e.node.text) ||
            (this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
            ((pn || rn) &&
                e &&
                e.dom.contentEditable == 'false' &&
                this.addHackNode('IMG', n),
            this.addHackNode('BR', this.top))
  }

  addHackNode (e, n) {
    if (
      n == this.top &&
            this.index < n.children.length &&
            n.children[this.index].matchesHack(e)
    ) {
      this.index++
    } else {
      const r = document.createElement(e)
      e == 'IMG' &&
                ((r.className = 'ProseMirror-separator'), (r.alt = '')),
      e == 'BR' && (r.className = 'ProseMirror-trailingBreak')
      const i = new Hl(this.top, [], r, null)
      n != this.top
        ? n.children.push(i)
        : n.children.splice(this.index++, 0, i),
      (this.changed = !0)
    }
  }

  isLocked (e) {
    return (
      this.lock &&
            (e == this.lock ||
                (e.nodeType == 1 && e.contains(this.lock.parentNode)))
    )
  }
}
function kR (t, e) {
  let n = e
  let r = n.children.length
  let i = t.childCount
  const o = new Map()
  const s = []
  e: for (; i > 0;) {
    let l
    for (;;) {
      if (r) {
        const d = n.children[r - 1]
        if (d instanceof Go) (n = d), (r = d.children.length)
        else {
          (l = d), r--
          break
        }
      } else {
        if (n == e) break e;
        (r = n.parent.children.indexOf(n)), (n = n.parent)
      }
    }
    const u = l.node
    if (u) {
      if (u != t.child(i - 1)) break
      --i, o.set(l, i), s.push(l)
    }
  }
  return { index: i, matched: o, matches: s.reverse() }
}
function OR (t, e) {
  return t.type.side - e.type.side
}
function RR (t, e, n, r) {
  const i = e.locals(t)
  let o = 0
  if (i.length == 0) {
    for (let d = 0; d < t.childCount; d++) {
      const f = t.child(d)
      r(f, i, e.forChild(o, f), d), (o += f.nodeSize)
    }
    return
  }
  let s = 0
  const l = []
  let u = null
  for (let d = 0; ;) {
    let f, h
    for (; s < i.length && i[s].to == o;) {
      const w = i[s++]
      w.widget && (f ? (h || (h = [f])).push(w) : (f = w))
    }
    if (f) {
      if (h) {
        h.sort(OR)
        for (let w = 0; w < h.length; w++) n(h[w], d, !!u)
      } else n(f, d, !!u)
    }
    let m, b
    if (u) (b = -1), (m = u), (u = null)
    else if (d < t.childCount) (b = d), (m = t.child(d++))
    else break
    for (let w = 0; w < l.length; w++) l[w].to <= o && l.splice(w--, 1)
    for (; s < i.length && i[s].from <= o && i[s].to > o;) l.push(i[s++])
    let g = o + m.nodeSize
    if (m.isText) {
      let w = g
      s < i.length && i[s].from < w && (w = i[s].from)
      for (let S = 0; S < l.length; S++) l[S].to < w && (w = l[S].to)
      w < g &&
                ((u = m.cut(w - o)), (m = m.cut(0, w - o)), (g = w), (b = -1))
    } else for (; s < i.length && i[s].to < g;) s++
    const E =
            m.isInline && !m.isLeaf ? l.filter((w) => !w.inline) : l.slice()
    r(m, E, e.forChild(o, m), b), (o = g)
  }
}
function IR (t) {
  if (t.nodeName == 'UL' || t.nodeName == 'OL') {
    const e = t.style.cssText;
    (t.style.cssText = e + '; list-style: square !important'),
    window.getComputedStyle(t).listStyle,
    (t.style.cssText = e)
  }
}
function DR (t, e, n, r) {
  for (let i = 0, o = 0; i < t.childCount && o <= r;) {
    const s = t.child(i++)
    const l = o
    if (((o += s.nodeSize), !s.isText)) continue
    let u = s.text
    for (; i < t.childCount;) {
      const d = t.child(i++)
      if (((o += d.nodeSize), !d.isText)) break
      u += d.text
    }
    if (o >= n) {
      if (o >= r && u.slice(r - e.length - l, r - l) == e) {
        return r - e.length
      }
      const d = l < r ? u.lastIndexOf(e, r - l - 1) : -1
      if (d >= 0 && d + e.length + l >= n) return l + d
      if (
        n == r &&
                u.length >= r + e.length - l &&
                u.slice(r - l, r - l + e.length) == e
      ) {
        return r
      }
    }
  }
  return -1
}
function Lf (t, e, n, r, i) {
  const o = []
  for (let s = 0, l = 0; s < t.length; s++) {
    const u = t[s]
    const d = l
    const f = (l += u.size)
    d >= n || f <= e
      ? o.push(u)
      : (d < e && o.push(u.slice(0, e - d, r)),
        i && (o.push(i), (i = void 0)),
        f > n && o.push(u.slice(n - d, u.size, r)))
  }
  return o
}
function Gf (t, e = null) {
  const n = t.domSelectionRange()
  const r = t.state.doc
  if (!n.focusNode) return null
  let i = t.docView.nearestDesc(n.focusNode)
  const o = i && i.size == 0
  let s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1)
  if (s < 0) return null
  let l = r.resolve(s)
  let u
  let d
  if (Yl(n)) {
    for (u = s; i && !i.node;) i = i.parent
    const h = i.node
    if (
      i &&
            h.isAtom &&
            he.isSelectable(h) &&
            i.parent &&
            !(h.isInline && cR(n.focusNode, n.focusOffset, i.dom))
    ) {
      const m = i.posBefore
      d = new he(s == m ? l : r.resolve(m))
    }
  } else {
    if (
      n instanceof t.dom.ownerDocument.defaultView.Selection &&
            n.rangeCount > 1
    ) {
      let h = s
      let m = s
      for (let b = 0; b < n.rangeCount; b++) {
        const g = n.getRangeAt(b);
        (h = Math.min(
          h,
          t.docView.posFromDOM(g.startContainer, g.startOffset, 1)
        )),
        (m = Math.max(
          m,
          t.docView.posFromDOM(g.endContainer, g.endOffset, -1)
        ))
      }
      if (h < 0) return null;
      ([u, s] = m == t.state.selection.anchor ? [m, h] : [h, m]),
      (l = r.resolve(s))
    } else u = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1)
    if (u < 0) return null
  }
  const f = r.resolve(u)
  if (!d) {
    const h =
            e == 'pointer' || (t.state.selection.head < l.pos && !o) ? 1 : -1
    d = qf(t, f, l, h)
  }
  return d
}
function nE (t) {
  return t.editable
    ? t.hasFocus()
    : iE(t) &&
              document.activeElement &&
              document.activeElement.contains(t.dom)
}
function Hr (t, e = !1) {
  const n = t.state.selection
  if ((rE(t, n), !!nE(t))) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && rn) {
      const r = t.domSelectionRange()
      const i = t.domObserver.currentSelection
      if (
        r.anchorNode &&
                i.anchorNode &&
                ji(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)
      ) {
        (t.input.mouseDown.delayedSelectionSync = !0),
        t.domObserver.setCurSelection()
        return
      }
    }
    if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) PR(t)
    else {
      const { anchor: r, head: i } = n
      let o
      let s
      x0 &&
                !(n instanceof le) &&
                (n.$from.parent.inlineContent || (o = _0(t, n.from)),
                !n.empty && !n.$from.parent.inlineContent && (s = _0(t, n.to))),
      t.docView.setSelection(r, i, t, e),
      x0 && (o && S0(o), s && S0(s)),
      n.visible
        ? t.dom.classList.remove('ProseMirror-hideselection')
        : (t.dom.classList.add('ProseMirror-hideselection'),
          'onselectionchange' in document && LR(t))
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection()
  }
}
var x0 = pn || (rn && G0 < 63)
function _0 (t, e) {
  const { node: n, offset: r } = t.docView.domFromPos(e, 0)
  const i = r < n.childNodes.length ? n.childNodes[r] : null
  const o = r ? n.childNodes[r - 1] : null
  if (pn && i && i.contentEditable == 'false') return _f(i)
  if (
    (!i || i.contentEditable == 'false') &&
        (!o || o.contentEditable == 'false')
  ) {
    if (i) return _f(i)
    if (o) return _f(o)
  }
}
function _f (t) {
  return (
    (t.contentEditable = 'true'),
    pn && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
    t
  )
}
function S0 (t) {
  (t.contentEditable = 'false'),
  t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null))
}
function LR (t) {
  const e = t.dom.ownerDocument
  e.removeEventListener('selectionchange', t.input.hideSelectionGuard)
  const n = t.domSelectionRange()
  const r = n.anchorNode
  const i = n.anchorOffset
  e.addEventListener(
    'selectionchange',
    (t.input.hideSelectionGuard = () => {
      (n.anchorNode != r || n.anchorOffset != i) &&
                (e.removeEventListener(
                  'selectionchange',
                  t.input.hideSelectionGuard
                ),
                setTimeout(() => {
                  (!nE(t) || t.state.selection.visible) &&
                        t.dom.classList.remove('ProseMirror-hideselection')
                }, 20))
    })
  )
}
function PR (t) {
  const e = t.domSelection()
  const n = document.createRange()
  if (!e) return
  const r = t.cursorWrapper.dom
  const i = r.nodeName == 'IMG'
  i ? n.setStart(r.parentNode, qt(r) + 1) : n.setStart(r, 0),
  n.collapse(!0),
  e.removeAllRanges(),
  e.addRange(n),
  !i &&
            !t.state.selection.visible &&
            wn &&
            hi <= 11 &&
            ((r.disabled = !0), (r.disabled = !1))
}
function rE (t, e) {
  if (e instanceof he) {
    const n = t.docView.descAt(e.from)
    n != t.lastSelectedViewDesc &&
            (T0(t), n && n.selectNode(), (t.lastSelectedViewDesc = n))
  } else T0(t)
}
function T0 (t) {
  t.lastSelectedViewDesc &&
        (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
        (t.lastSelectedViewDesc = void 0))
}
function qf (t, e, n, r) {
  return (
    t.someProp('createSelectionBetween', (i) => i(t, e, n)) ||
        le.between(e, n, r)
  )
}
function C0 (t) {
  return t.editable && !t.hasFocus() ? !1 : iE(t)
}
function iE (t) {
  const e = t.domSelectionRange()
  if (!e.anchorNode) return !1
  try {
    return (
      t.dom.contains(
        e.anchorNode.nodeType == 3
          ? e.anchorNode.parentNode
          : e.anchorNode
      ) &&
            (t.editable ||
                t.dom.contains(
                  e.focusNode.nodeType == 3
                    ? e.focusNode.parentNode
                    : e.focusNode
                ))
    )
  } catch {
    return !1
  }
}
function BR (t) {
  const e = t.docView.domFromPos(t.state.selection.anchor, 0)
  const n = t.domSelectionRange()
  return ji(e.node, e.offset, n.anchorNode, n.anchorOffset)
}
function Pf (t, e) {
  const { $anchor: n, $head: r } = t.selection
  const i = e > 0 ? n.max(r) : n.min(r)
  const o = i.parent.inlineContent
    ? i.depth
      ? t.doc.resolve(e > 0 ? i.after() : i.before())
      : null
    : i
  return o && ue.findFrom(o, e)
}
function fi (t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0
}
function A0 (t, e, n) {
  const r = t.state.selection
  if (r instanceof le) {
    if (n.indexOf('s') > -1) {
      const { $head: i } = r
      const o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter
      if (!o || o.isText || !o.isLeaf) return !1
      const s = t.state.doc.resolve(
        i.pos + o.nodeSize * (e < 0 ? -1 : 1)
      )
      return fi(t, new le(r.$anchor, s))
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) {
        const i = Pf(t.state, e)
        return i && i instanceof he ? fi(t, i) : !1
      } else if (!(Un && n.indexOf('m') > -1)) {
        const i = r.$head
        const o = i.textOffset
          ? null
          : e < 0
            ? i.nodeBefore
            : i.nodeAfter
        let s
        if (!o || o.isText) return !1
        const l = e < 0 ? i.pos - o.nodeSize : i.pos
        return o.isAtom || ((s = t.docView.descAt(l)) && !s.contentDOM)
          ? he.isSelectable(o)
            ? fi(
              t,
              new he(
                e < 0
                  ? t.state.doc.resolve(i.pos - o.nodeSize)
                  : i
              )
            )
            : na
              ? fi(
                t,
                new le(
                  t.state.doc.resolve(
                    e < 0 ? l : l + o.nodeSize
                  )
                )
              )
              : !1
          : !1
      }
    } else return !1
  } else {
    if (r instanceof he && r.node.isInline) {
      return fi(t, new le(e > 0 ? r.$to : r.$from))
    }
    {
      const i = Pf(t.state, e)
      return i ? fi(t, i) : !1
    }
  }
}
function zl (t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function Xs (t, e) {
  const n = t.pmViewDesc
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != 'BR')
}
function Uo (t, e) {
  return e < 0 ? FR(t) : HR(t)
}
function FR (t) {
  const e = t.domSelectionRange()
  let n = e.focusNode
  let r = e.focusOffset
  if (!n) return
  let i
  let o
  let s = !1
  for (
    ir &&
        n.nodeType == 1 &&
        r < zl(n) &&
        Xs(n.childNodes[r], -1) &&
        (s = !0);
    ;

  ) {
    if (r > 0) {
      if (n.nodeType != 1) break
      {
        const l = n.childNodes[r - 1]
        if (Xs(l, -1)) (i = n), (o = --r)
        else if (l.nodeType == 3) (n = l), (r = n.nodeValue.length)
        else break
      }
    } else {
      if (oE(n)) break
      {
        let l = n.previousSibling
        for (; l && Xs(l, -1);) {
          (i = n.parentNode), (o = qt(l)), (l = l.previousSibling)
        }
        if (l) (n = l), (r = zl(n))
        else {
          if (((n = n.parentNode), n == t.dom)) break
          r = 0
        }
      }
    }
  }
  s ? Bf(t, n, r) : i && Bf(t, i, o)
}
function HR (t) {
  const e = t.domSelectionRange()
  let n = e.focusNode
  let r = e.focusOffset
  if (!n) return
  let i = zl(n)
  let o
  let s
  for (;;) {
    if (r < i) {
      if (n.nodeType != 1) break
      const l = n.childNodes[r]
      if (Xs(l, 1)) (o = n), (s = ++r)
      else break
    } else {
      if (oE(n)) break
      {
        let l = n.nextSibling
        for (; l && Xs(l, 1);) {
          (o = l.parentNode), (s = qt(l) + 1), (l = l.nextSibling)
        }
        if (l) (n = l), (r = 0), (i = zl(n))
        else {
          if (((n = n.parentNode), n == t.dom)) break
          r = i = 0
        }
      }
    }
  }
  o && Bf(t, o, s)
}
function oE (t) {
  const e = t.pmViewDesc
  return e && e.node && e.node.isBlock
}
function $R (t, e) {
  for (; t && e == t.childNodes.length && !ta(t);) {
    (e = qt(t) + 1), (t = t.parentNode)
  }
  for (; t && e < t.childNodes.length;) {
    const n = t.childNodes[e]
    if (n.nodeType == 3) return n
    if (n.nodeType == 1 && n.contentEditable == 'false') break;
    (t = n), (e = 0)
  }
}
function zR (t, e) {
  for (; t && !e && !ta(t);) (e = qt(t)), (t = t.parentNode)
  for (; t && e;) {
    const n = t.childNodes[e - 1]
    if (n.nodeType == 3) return n
    if (n.nodeType == 1 && n.contentEditable == 'false') break;
    (t = n), (e = t.childNodes.length)
  }
}
function Bf (t, e, n) {
  if (e.nodeType != 3) {
    let o, s;
    (s = $R(e, n))
      ? ((e = s), (n = 0))
      : (o = zR(e, n)) && ((e = o), (n = o.nodeValue.length))
  }
  const r = t.domSelection()
  if (!r) return
  if (Yl(r)) {
    const o = document.createRange()
    o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o)
  } else r.extend && r.extend(e, n)
  t.domObserver.setCurSelection()
  const { state: i } = t
  setTimeout(() => {
    t.state == i && Hr(t)
  }, 50)
}
function M0 (t, e) {
  const n = t.state.doc.resolve(e)
  if (!(rn || fR) && n.parent.inlineContent) {
    const i = t.coordsAtPos(e)
    if (e > n.start()) {
      const o = t.coordsAtPos(e - 1)
      const s = (o.top + o.bottom) / 2
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1) {
        return o.left < i.left ? 'ltr' : 'rtl'
      }
    }
    if (e < n.end()) {
      const o = t.coordsAtPos(e + 1)
      const s = (o.top + o.bottom) / 2
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1) {
        return o.left > i.left ? 'ltr' : 'rtl'
      }
    }
  }
  return getComputedStyle(t.dom).direction == 'rtl' ? 'rtl' : 'ltr'
}
function N0 (t, e, n) {
  const r = t.state.selection
  if (
    (r instanceof le && !r.empty) ||
        n.indexOf('s') > -1 ||
        (Un && n.indexOf('m') > -1)
  ) {
    return !1
  }
  const { $from: i, $to: o } = r
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? 'up' : 'down')) {
    const s = Pf(t.state, e)
    if (s && s instanceof he) return fi(t, s)
  }
  if (!i.parent.inlineContent) {
    const s = e < 0 ? i : o
    const l = r instanceof fn ? ue.near(s, e) : ue.findFrom(s, e)
    return l ? fi(t, l) : !1
  }
  return !1
}
function k0 (t, e) {
  if (!(t.state.selection instanceof le)) return !0
  const { $head: n, $anchor: r, empty: i } = t.state.selection
  if (!n.sameParent(r)) return !0
  if (!i) return !1
  if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) return !0
  const o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter)
  if (o && !o.isText) {
    const s = t.state.tr
    return (
      e < 0
        ? s.delete(n.pos - o.nodeSize, n.pos)
        : s.delete(n.pos, n.pos + o.nodeSize),
      t.dispatch(s),
      !0
    )
  }
  return !1
}
function O0 (t, e, n) {
  t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start()
}
function UR (t) {
  if (!pn || t.state.selection.$head.parentOffset > 0) return !1
  const { focusNode: e, focusOffset: n } = t.domSelectionRange()
  if (
    e &&
        e.nodeType == 1 &&
        n == 0 &&
        e.firstChild &&
        e.firstChild.contentEditable == 'false'
  ) {
    const r = e.firstChild
    O0(t, r, 'true'), setTimeout(() => O0(t, r, 'false'), 20)
  }
  return !1
}
function WR (t) {
  let e = ''
  return (
    t.ctrlKey && (e += 'c'),
    t.metaKey && (e += 'm'),
    t.altKey && (e += 'a'),
    t.shiftKey && (e += 's'),
    e
  )
}
function KR (t, e) {
  const n = e.keyCode
  const r = WR(e)
  if (n == 8 || (Un && n == 72 && r == 'c')) return k0(t, -1) || Uo(t, -1)
  if ((n == 46 && !e.shiftKey) || (Un && n == 68 && r == 'c')) {
    return k0(t, 1) || Uo(t, 1)
  }
  if (n == 13 || n == 27) return !0
  if (n == 37 || (Un && n == 66 && r == 'c')) {
    const i =
            n == 37 ? (M0(t, t.state.selection.from) == 'ltr' ? -1 : 1) : -1
    return A0(t, i, r) || Uo(t, i)
  } else if (n == 39 || (Un && n == 70 && r == 'c')) {
    const i =
            n == 39 ? (M0(t, t.state.selection.from) == 'ltr' ? 1 : -1) : 1
    return A0(t, i, r) || Uo(t, i)
  } else {
    if (n == 38 || (Un && n == 80 && r == 'c')) {
      return N0(t, -1, r) || Uo(t, -1)
    }
    if (n == 40 || (Un && n == 78 && r == 'c')) {
      return UR(t) || N0(t, 1, r) || Uo(t, 1)
    }
    if (
      r == (Un ? 'm' : 'c') &&
            (n == 66 || n == 73 || n == 89 || n == 90)
    ) {
      return !0
    }
  }
  return !1
}
function sE (t, e) {
  t.someProp('transformCopied', (b) => {
    e = b(e, t)
  })
  const n = []
  let { content: r, openStart: i, openEnd: o } = e
  for (
    ;
    i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

  ) {
    i--, o--
    const b = r.firstChild
    n.push(b.type.name, b.attrs != b.type.defaultAttrs ? b.attrs : null),
    (r = b.content)
  }
  const s =
        t.someProp('clipboardSerializer') || Ir.fromSchema(t.state.schema)
  const l = fE()
  const u = l.createElement('div')
  u.appendChild(s.serializeFragment(r, { document: l }))
  let d = u.firstChild
  let f
  let h = 0
  for (; d && d.nodeType == 1 && (f = dE[d.nodeName.toLowerCase()]);) {
    for (let b = f.length - 1; b >= 0; b--) {
      const g = l.createElement(f[b])
      for (; u.firstChild;) g.appendChild(u.firstChild)
      u.appendChild(g), h++
    }
    d = u.firstChild
  }
  d &&
        d.nodeType == 1 &&
        d.setAttribute(
          'data-pm-slice',
            `${i} ${o}${h ? ` -${h}` : ''} ${JSON.stringify(n)}`
        )
  const m =
        t.someProp('clipboardTextSerializer', (b) => b(e, t)) ||
        e.content.textBetween(
          0,
          e.content.size,
            `

`
        )
  return { dom: u, text: m, slice: e }
}
function aE (t, e, n, r, i) {
  const o = i.parent.type.spec.code
  let s
  let l
  if (!n && !e) return null
  const u = e && (r || o || !n)
  if (u) {
    if (
      (t.someProp('transformPastedText', (m) => {
        e = m(e, o || r, t)
      }),
      o)
    ) {
      return e
        ? new Z(
          K.from(
            t.state.schema.text(
              e.replace(
                /\r\n?/g,
                                  `
`
              )
            )
          ),
          0,
          0
        )
        : Z.empty
    }
    const h = t.someProp('clipboardTextParser', (m) => m(e, i, r, t))
    if (h) l = h
    else {
      const m = i.marks()
      const { schema: b } = t.state
      const g = Ir.fromSchema(b);
      (s = document.createElement('div')),
      e.split(/(?:\r\n?|\n)+/).forEach((E) => {
        const w = s.appendChild(document.createElement('p'))
        E && w.appendChild(g.serializeNode(b.text(E, m)))
      })
    }
  } else {
    t.someProp('transformPastedHTML', (h) => {
      n = h(n, t)
    }),
    (s = YR(n)),
    na && JR(s)
  }
  const d = s && s.querySelector('[data-pm-slice]')
  const f =
        d &&
        /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
          d.getAttribute('data-pm-slice') || ''
        )
  if (f && f[3]) {
    for (let h = +f[3]; h > 0; h--) {
      let m = s.firstChild
      for (; m && m.nodeType != 1;) m = m.nextSibling
      if (!m) break
      s = m
    }
  }
  if (
    (l ||
            (l = (
              t.someProp('clipboardParser') ||
                t.someProp('domParser') ||
                Rr.fromSchema(t.state.schema)
            ).parseSlice(s, {
              preserveWhitespace: !!(u || f),
              context: i,
              ruleFromNode (m) {
                return m.nodeName == 'BR' &&
                        !m.nextSibling &&
                        m.parentNode &&
                        !VR.test(m.parentNode.nodeName)
                  ? { ignore: !0 }
                  : null
              }
            })),
    f)
  ) {
    l = XR(R0(l, +f[1], +f[2]), f[4])
  } else if (
    ((l = Z.maxOpen(GR(l.content, i), !0)), l.openStart || l.openEnd)
  ) {
    let h = 0
    let m = 0
    for (
      let b = l.content.firstChild;
      h < l.openStart && !b.type.spec.isolating;
      h++, b = b.firstChild
    );
    for (
      let b = l.content.lastChild;
      m < l.openEnd && !b.type.spec.isolating;
      m++, b = b.lastChild
    );
    l = R0(l, h, m)
  }
  return (
    t.someProp('transformPasted', (h) => {
      l = h(l, t)
    }),
    l
  )
}
var VR =
    /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i
function GR (t, e) {
  if (t.childCount < 2) return t
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n))
    let o
    let s = []
    if (
      (t.forEach((l) => {
        if (!s) return
        const u = i.findWrapping(l.type)
        let d
        if (!u) return (s = null)
        if (
          (d =
                        s.length && o.length && cE(u, o, l, s[s.length - 1], 0))
        ) {
          s[s.length - 1] = d
        } else {
          s.length &&
                        (s[s.length - 1] = uE(s[s.length - 1], o.length))
          const f = lE(l, u)
          s.push(f), (i = i.matchType(f.type)), (o = u)
        }
      }),
      s)
    ) {
      return K.from(s)
    }
  }
  return t
}
function lE (t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, K.from(t))
  return t
}
function cE (t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    const o = cE(t, e, n, r.lastChild, i + 1)
    if (o) return r.copy(r.content.replaceChild(r.childCount - 1, o))
    if (
      r
        .contentMatchAt(r.childCount)
        .matchType(i == t.length - 1 ? n.type : t[i + 1])
    ) {
      return r.copy(r.content.append(K.from(lE(n, t, i + 1))))
    }
  }
}
function uE (t, e) {
  if (e == 0) return t
  const n = t.content.replaceChild(t.childCount - 1, uE(t.lastChild, e - 1))
  const r = t.contentMatchAt(t.childCount).fillBefore(K.empty, !0)
  return t.copy(n.append(r))
}
function Ff (t, e, n, r, i, o) {
  const s = e < 0 ? t.firstChild : t.lastChild
  let l = s.content
  return (
    t.childCount > 1 && (o = 0),
    i < r - 1 && (l = Ff(l, e, n, r, i + 1, o)),
    i >= n &&
            (l =
                e < 0
                  ? s
                    .contentMatchAt(0)
                    .fillBefore(l, o <= i)
                    .append(l)
                  : l.append(
                    s
                      .contentMatchAt(s.childCount)
                      .fillBefore(K.empty, !0)
                  )),
    t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(l))
  )
}
function R0 (t, e, n) {
  return (
    e < t.openStart &&
            (t = new Z(
              Ff(t.content, -1, e, t.openStart, 0, t.openEnd),
              e,
              t.openEnd
            )),
    n < t.openEnd &&
            (t = new Z(Ff(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
    t
  )
}
var dE = {
  thead: ['table'],
  tbody: ['table'],
  tfoot: ['table'],
  caption: ['table'],
  colgroup: ['table'],
  col: ['table', 'colgroup'],
  tr: ['table', 'tbody'],
  td: ['table', 'tbody', 'tr'],
  th: ['table', 'tbody', 'tr']
}
let I0 = null
function fE () {
  return I0 || (I0 = document.implementation.createHTMLDocument('title'))
}
let Sf = null
function qR (t) {
  const e = window.trustedTypes
  return e
    ? (Sf ||
              (Sf = e.createPolicy('ProseMirrorClipboard', {
                createHTML: (n) => n
              })),
      Sf.createHTML(t))
    : t
}
function YR (t) {
  const e = /^(\s*<meta [^>]*>)*/.exec(t)
  e && (t = t.slice(e[0].length))
  let n = fE().createElement('div')
  const r = /<([a-z][^>\s]+)/i.exec(t)
  let i
  if (
    ((i = r && dE[r[1].toLowerCase()]) &&
            (t =
                i.map((o) => '<' + o + '>').join('') +
                t +
                i
                  .map((o) => '</' + o + '>')
                  .reverse()
                  .join('')),
    (n.innerHTML = qR(t)),
    i)
  ) {
    for (let o = 0; o < i.length; o++) n = n.querySelector(i[o]) || n
  }
  return n
}
function JR (t) {
  const e = t.querySelectorAll(
    rn ? 'span:not([class]):not([style])' : 'span.Apple-converted-space'
  )
  for (let n = 0; n < e.length; n++) {
    const r = e[n]
    r.childNodes.length == 1 &&
            r.textContent == '\xA0' &&
            r.parentNode &&
            r.parentNode.replaceChild(t.ownerDocument.createTextNode(' '), r)
  }
}
function XR (t, e) {
  if (!t.size) return t
  const n = t.content.firstChild.type.schema
  let r
  try {
    r = JSON.parse(e)
  } catch {
    return t
  }
  let { content: i, openStart: o, openEnd: s } = t
  for (let l = r.length - 2; l >= 0; l -= 2) {
    const u = n.nodes[r[l]]
    if (!u || u.hasRequiredAttrs()) break;
    (i = K.from(u.create(r[l + 1], i))), o++, s++
  }
  return new Z(i, o, s)
}
const hn = {}
const mn = {}
const ZR = { touchstart: !0, touchmove: !0 }
const Hf = class {
  constructor () {
    (this.shiftKey = !1),
    (this.mouseDown = null),
    (this.lastKeyCode = null),
    (this.lastKeyCodeTime = 0),
    (this.lastClick = { time: 0, x: 0, y: 0, type: '' }),
    (this.lastSelectionOrigin = null),
    (this.lastSelectionTime = 0),
    (this.lastIOSEnter = 0),
    (this.lastIOSEnterFallbackTimeout = -1),
    (this.lastFocus = 0),
    (this.lastTouch = 0),
    (this.lastChromeDelete = 0),
    (this.composing = !1),
    (this.compositionNode = null),
    (this.composingTimeout = -1),
    (this.compositionNodes = []),
    (this.compositionEndedAt = -2e8),
    (this.compositionID = 1),
    (this.compositionPendingChanges = 0),
    (this.domChangeCount = 0),
    (this.eventHandlers = Object.create(null)),
    (this.hideSelectionGuard = null)
  }
}
function jR (t) {
  for (const e in hn) {
    const n = hn[e]
    t.dom.addEventListener(
      e,
      (t.input.eventHandlers[e] = (r) => {
        eI(t, r) &&
                    !Yf(t, r) &&
                    (t.editable || !(r.type in mn)) &&
                    n(t, r)
      }),
      ZR[e] ? { passive: !0 } : void 0
    )
  }
  pn && t.dom.addEventListener('input', () => null), $f(t)
}
function pi (t, e) {
  (t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now())
}
function QR (t) {
  t.domObserver.stop()
  for (const e in t.input.eventHandlers) {
    t.dom.removeEventListener(e, t.input.eventHandlers[e])
  }
  clearTimeout(t.input.composingTimeout),
  clearTimeout(t.input.lastIOSEnterFallbackTimeout)
}
function $f (t) {
  t.someProp('handleDOMEvents', (e) => {
    for (const n in e) {
      t.input.eventHandlers[n] ||
                t.dom.addEventListener(
                  n,
                  (t.input.eventHandlers[n] = (r) => Yf(t, r))
                )
    }
  })
}
function Yf (t, e) {
  return t.someProp('handleDOMEvents', (n) => {
    const r = n[e.type]
    return r ? r(t, e) || e.defaultPrevented : !1
  })
}
function eI (t, e) {
  if (!e.bubbles) return !0
  if (e.defaultPrevented) return !1
  for (let n = e.target; n != t.dom; n = n.parentNode) {
    if (
      !n ||
            n.nodeType == 11 ||
            (n.pmViewDesc && n.pmViewDesc.stopEvent(e))
    ) {
      return !1
    }
  }
  return !0
}
function tI (t, e) {
  !Yf(t, e) &&
        hn[e.type] &&
        (t.editable || !(e.type in mn)) &&
        hn[e.type](t, e)
}
mn.keydown = (t, e) => {
  const n = e
  if (
    ((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
    !hE(t, n) &&
            ((t.input.lastKeyCode = n.keyCode),
            (t.input.lastKeyCodeTime = Date.now()),
            !(Fr && rn && n.keyCode == 13)))
  ) {
    if (
      (n.keyCode != 229 && t.domObserver.forceFlush(),
      Vo && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
    ) {
      const r = Date.now();
      (t.input.lastIOSEnter = r),
      (t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r &&
                        (t.someProp('handleKeyDown', (i) =>
                          i(t, Gi(13, 'Enter'))
                        ),
                        (t.input.lastIOSEnter = 0))
      }, 200))
    } else {
      t.someProp('handleKeyDown', (r) => r(t, n)) || KR(t, n)
        ? n.preventDefault()
        : pi(t, 'key')
    }
  }
}
mn.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1)
}
mn.keypress = (t, e) => {
  const n = e
  if (
    hE(t, n) ||
        !n.charCode ||
        (n.ctrlKey && !n.altKey) ||
        (Un && n.metaKey)
  ) {
    return
  }
  if (t.someProp('handleKeyPress', (i) => i(t, n))) {
    n.preventDefault()
    return
  }
  const r = t.state.selection
  if (!(r instanceof le) || !r.$from.sameParent(r.$to)) {
    const i = String.fromCharCode(n.charCode)
    !/[\r\n]/.test(i) &&
            !t.someProp('handleTextInput', (o) =>
              o(t, r.$from.pos, r.$to.pos, i)
            ) &&
            t.dispatch(t.state.tr.insertText(i).scrollIntoView()),
    n.preventDefault()
  }
}
function Jl (t) {
  return { left: t.clientX, top: t.clientY }
}
function nI (t, e) {
  const n = e.x - t.clientX
  const r = e.y - t.clientY
  return n * n + r * r < 100
}
function Jf (t, e, n, r, i) {
  if (r == -1) return !1
  const o = t.state.doc.resolve(r)
  for (let s = o.depth + 1; s > 0; s--) {
    if (
      t.someProp(e, (l) =>
        s > o.depth
          ? l(t, n, o.nodeAfter, o.before(s), i, !0)
          : l(t, n, o.node(s), o.before(s), i, !1)
      )
    ) {
      return !0
    }
  }
  return !1
}
function Ko (t, e, n) {
  if ((t.focused || t.focus(), t.state.selection.eq(e))) return
  const r = t.state.tr.setSelection(e)
  n == 'pointer' && r.setMeta('pointer', !0), t.dispatch(r)
}
function rI (t, e) {
  if (e == -1) return !1
  const n = t.state.doc.resolve(e)
  const r = n.nodeAfter
  return r && r.isAtom && he.isSelectable(r)
    ? (Ko(t, new he(n), 'pointer'), !0)
    : !1
}
function iI (t, e) {
  if (e == -1) return !1
  const n = t.state.selection
  let r
  let i
  n instanceof he && (r = n.node)
  const o = t.state.doc.resolve(e)
  for (let s = o.depth + 1; s > 0; s--) {
    const l = s > o.depth ? o.nodeAfter : o.node(s)
    if (he.isSelectable(l)) {
      r &&
            n.$from.depth > 0 &&
            s >= n.$from.depth &&
            o.before(n.$from.depth + 1) == n.$from.pos
        ? (i = o.before(n.$from.depth))
        : (i = o.before(s))
      break
    }
  }
  return i != null ? (Ko(t, he.create(t.state.doc, i), 'pointer'), !0) : !1
}
function oI (t, e, n, r, i) {
  return (
    Jf(t, 'handleClickOn', e, n, r) ||
        t.someProp('handleClick', (o) => o(t, e, r)) ||
        (i ? iI(t, n) : rI(t, n))
  )
}
function sI (t, e, n, r) {
  return (
    Jf(t, 'handleDoubleClickOn', e, n, r) ||
        t.someProp('handleDoubleClick', (i) => i(t, e, r))
  )
}
function aI (t, e, n, r) {
  return (
    Jf(t, 'handleTripleClickOn', e, n, r) ||
        t.someProp('handleTripleClick', (i) => i(t, e, r)) ||
        lI(t, n, r)
  )
}
function lI (t, e, n) {
  if (n.button != 0) return !1
  const r = t.state.doc
  if (e == -1) {
    return r.inlineContent
      ? (Ko(t, le.create(r, 0, r.content.size), 'pointer'), !0)
      : !1
  }
  const i = r.resolve(e)
  for (let o = i.depth + 1; o > 0; o--) {
    const s = o > i.depth ? i.nodeAfter : i.node(o)
    const l = i.before(o)
    if (s.inlineContent) {
      Ko(t, le.create(r, l + 1, l + 1 + s.content.size), 'pointer')
    } else if (he.isSelectable(s)) Ko(t, he.create(r, l), 'pointer')
    else continue
    return !0
  }
}
function Xf (t) {
  return Ul(t)
}
const pE = Un ? 'metaKey' : 'ctrlKey'
hn.mousedown = (t, e) => {
  const n = e
  t.input.shiftKey = n.shiftKey
  const r = Xf(t)
  const i = Date.now()
  let o = 'singleClick'
  i - t.input.lastClick.time < 500 &&
        nI(n, t.input.lastClick) &&
        !n[pE] &&
        (t.input.lastClick.type == 'singleClick'
          ? (o = 'doubleClick')
          : t.input.lastClick.type == 'doubleClick' && (o = 'tripleClick')),
  (t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o })
  const s = t.posAtCoords(Jl(n))
  s &&
        (o == 'singleClick'
          ? (t.input.mouseDown && t.input.mouseDown.done(),
            (t.input.mouseDown = new zf(t, s, n, !!r)))
          : (o == 'doubleClick' ? sI : aI)(t, s.pos, s.inside, n)
              ? n.preventDefault()
              : pi(t, 'pointer'))
}
var zf = class {
  constructor (e, n, r, i) {
    (this.view = e),
    (this.pos = n),
    (this.event = r),
    (this.flushed = i),
    (this.delayedSelectionSync = !1),
    (this.mightDrag = null),
    (this.startDoc = e.state.doc),
    (this.selectNode = !!r[pE]),
    (this.allowDefault = r.shiftKey)
    let o, s
    if (n.inside > -1) (o = e.state.doc.nodeAt(n.inside)), (s = n.inside)
    else {
      const f = e.state.doc.resolve(n.pos);
      (o = f.parent), (s = f.depth ? f.before() : 0)
    }
    const l = i ? null : r.target
    const u = l ? e.docView.nearestDesc(l, !0) : null
    this.target = u && u.dom.nodeType == 1 ? u.dom : null
    const { selection: d } = e.state;
    ((r.button == 0 &&
            o.type.spec.draggable &&
            o.type.spec.selectable !== !1) ||
            (d instanceof he && d.from <= s && d.to > s)) &&
            (this.mightDrag = {
              node: o,
              pos: s,
              addAttr: !!(this.target && !this.target.draggable),
              setUneditable: !!(
                this.target &&
                    ir &&
                    !this.target.hasAttribute('contentEditable')
              )
            }),
    this.target &&
                this.mightDrag &&
                (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
                (this.view.domObserver.stop(),
                this.mightDrag.addAttr && (this.target.draggable = !0),
                this.mightDrag.setUneditable &&
                    setTimeout(() => {
                      this.view.input.mouseDown == this &&
                            this.target.setAttribute(
                              'contentEditable',
                              'false'
                            )
                    }, 20),
                this.view.domObserver.start()),
    e.root.addEventListener('mouseup', (this.up = this.up.bind(this))),
    e.root.addEventListener(
      'mousemove',
      (this.move = this.move.bind(this))
    ),
    pi(e, 'pointer')
  }

  done () {
    this.view.root.removeEventListener('mouseup', this.up),
    this.view.root.removeEventListener('mousemove', this.move),
    this.mightDrag &&
                this.target &&
                (this.view.domObserver.stop(),
                this.mightDrag.addAttr &&
                    this.target.removeAttribute('draggable'),
                this.mightDrag.setUneditable &&
                    this.target.removeAttribute('contentEditable'),
                this.view.domObserver.start()),
    this.delayedSelectionSync && setTimeout(() => Hr(this.view)),
    (this.view.input.mouseDown = null)
  }

  up (e) {
    if ((this.done(), !this.view.dom.contains(e.target))) return
    let n = this.pos
    this.view.state.doc != this.startDoc &&
            (n = this.view.posAtCoords(Jl(e))),
    this.updateAllowDefault(e),
    this.allowDefault || !n
      ? pi(this.view, 'pointer')
      : oI(this.view, n.pos, n.inside, e, this.selectNode)
        ? e.preventDefault()
        : e.button == 0 &&
                      (this.flushed ||
                          (pn &&
                              this.mightDrag &&
                              !this.mightDrag.node.isAtom) ||
                          (rn &&
                              !this.view.state.selection.visible &&
                              Math.min(
                                Math.abs(
                                  n.pos - this.view.state.selection.from
                                ),
                                Math.abs(
                                  n.pos - this.view.state.selection.to
                                )
                              ) <= 2))
          ? (Ko(
              this.view,
              ue.near(this.view.state.doc.resolve(n.pos)),
              'pointer'
            ),
            e.preventDefault())
          : pi(this.view, 'pointer')
  }

  move (e) {
    this.updateAllowDefault(e),
    pi(this.view, 'pointer'),
    e.buttons == 0 && this.done()
  }

  updateAllowDefault (e) {
    !this.allowDefault &&
            (Math.abs(this.event.x - e.clientX) > 4 ||
                Math.abs(this.event.y - e.clientY) > 4) &&
            (this.allowDefault = !0)
  }
}
hn.touchstart = (t) => {
  (t.input.lastTouch = Date.now()), Xf(t), pi(t, 'pointer')
}
hn.touchmove = (t) => {
  (t.input.lastTouch = Date.now()), pi(t, 'pointer')
}
hn.contextmenu = (t) => Xf(t)
function hE (t, e) {
  return t.composing
    ? !0
    : pn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
      ? ((t.input.compositionEndedAt = -2e8), !0)
      : !1
}
const cI = Fr ? 5e3 : -1
mn.compositionstart = mn.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush()
    const { state: e } = t
    const n = e.selection.$to
    if (
      e.selection instanceof le &&
            (e.storedMarks ||
                (!n.textOffset &&
                    n.parentOffset &&
                    n.nodeBefore.marks.some(
                      (r) => r.type.spec.inclusive === !1
                    )))
    ) {
      (t.markCursor = t.state.storedMarks || n.marks()),
      Ul(t, !0),
      (t.markCursor = null)
    } else if (
      (Ul(t, !e.selection.empty),
      ir &&
                e.selection.empty &&
                n.parentOffset &&
                !n.textOffset &&
                n.nodeBefore.marks.length)
    ) {
      const r = t.domSelectionRange()
      for (
        let i = r.focusNode, o = r.focusOffset;
        i && i.nodeType == 1 && o != 0;

      ) {
        const s = o < 0 ? i.lastChild : i.childNodes[o - 1]
        if (!s) break
        if (s.nodeType == 3) {
          const l = t.domSelection()
          l && l.collapse(s, s.nodeValue.length)
          break
        } else (i = s), (o = -1)
      }
    }
    t.input.composing = !0
  }
  mE(t, cI)
}
mn.compositionend = (t, e) => {
  t.composing &&
        ((t.input.composing = !1),
        (t.input.compositionEndedAt = e.timeStamp),
        (t.input.compositionPendingChanges = t.domObserver.pendingRecords()
          .length
          ? t.input.compositionID
          : 0),
        (t.input.compositionNode = null),
        t.input.compositionPendingChanges &&
            Promise.resolve().then(() => t.domObserver.flush()),
        t.input.compositionID++,
        mE(t, 20))
}
function mE (t, e) {
  clearTimeout(t.input.composingTimeout),
  e > -1 && (t.input.composingTimeout = setTimeout(() => Ul(t), e))
}
function gE (t) {
  for (
    t.composing &&
        ((t.input.composing = !1), (t.input.compositionEndedAt = dI()));
    t.input.compositionNodes.length > 0;

  ) {
    t.input.compositionNodes.pop().markParentsDirty()
  }
}
function uI (t) {
  const e = t.domSelectionRange()
  if (!e.focusNode) return null
  const n = aR(e.focusNode, e.focusOffset)
  const r = lR(e.focusNode, e.focusOffset)
  if (n && r && n != r) {
    const i = r.pmViewDesc
    const o = t.domObserver.lastChangedTextNode
    if (n == o || r == o) return o
    if (!i || !i.isText(r.nodeValue)) return r
    if (t.input.compositionNode == r) {
      const s = n.pmViewDesc
      if (!(!s || !s.isText(n.nodeValue))) return r
    }
  }
  return n || r
}
function dI () {
  const t = document.createEvent('Event')
  return t.initEvent('event', !0, !0), t.timeStamp
}
function Ul (t, e = !1) {
  if (!(Fr && t.domObserver.flushingSoon >= 0)) {
    if (
      (t.domObserver.forceFlush(),
      gE(t),
      e || (t.docView && t.docView.dirty))
    ) {
      const n = Gf(t)
      return (
        n && !n.eq(t.state.selection)
          ? t.dispatch(t.state.tr.setSelection(n))
          : (t.markCursor || e) && !t.state.selection.empty
              ? t.dispatch(t.state.tr.deleteSelection())
              : t.updateState(t.state),
        !0
      )
    }
    return !1
  }
}
function fI (t, e) {
  if (!t.dom.parentNode) return
  const n = t.dom.parentNode.appendChild(document.createElement('div'))
  n.appendChild(e),
  (n.style.cssText = 'position: fixed; left: -10000px; top: 10px')
  const r = getSelection()
  const i = document.createRange()
  i.selectNodeContents(e),
  t.dom.blur(),
  r.removeAllRanges(),
  r.addRange(i),
  setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus()
  }, 50)
}
const js = (wn && hi < 15) || (Vo && pR < 604)
hn.copy = mn.cut = (t, e) => {
  const n = e
  const r = t.state.selection
  const i = n.type == 'cut'
  if (r.empty) return
  const o = js ? null : n.clipboardData
  const s = r.content()
  const { dom: l, text: u } = sE(t, s)
  o
    ? (n.preventDefault(),
      o.clearData(),
      o.setData('text/html', l.innerHTML),
      o.setData('text/plain', u))
    : fI(t, l),
  i &&
            t.dispatch(
              t.state.tr
                .deleteSelection()
                .scrollIntoView()
                .setMeta('uiEvent', 'cut')
            )
}
function pI (t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
    ? t.content.firstChild
    : null
}
function hI (t, e) {
  if (!t.dom.parentNode) return
  const n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code
  const r = t.dom.parentNode.appendChild(
    document.createElement(n ? 'textarea' : 'div')
  )
  n || (r.contentEditable = 'true'),
  (r.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
  r.focus()
  const i = t.input.shiftKey && t.input.lastKeyCode != 45
  setTimeout(() => {
    t.focus(),
    r.parentNode && r.parentNode.removeChild(r),
    n
      ? Qs(t, r.value, null, i, e)
      : Qs(t, r.textContent, r.innerHTML, i, e)
  }, 50)
}
function Qs (t, e, n, r, i) {
  const o = aE(t, e, n, r, t.state.selection.$from)
  if (t.someProp('handlePaste', (u) => u(t, i, o || Z.empty))) return !0
  if (!o) return !1
  const s = pI(o)
  const l = s
    ? t.state.tr.replaceSelectionWith(s, r)
    : t.state.tr.replaceSelection(o)
  return (
    t.dispatch(
      l.scrollIntoView().setMeta('paste', !0).setMeta('uiEvent', 'paste')
    ),
    !0
  )
}
function bE (t) {
  const e = t.getData('text/plain') || t.getData('Text')
  if (e) return e
  const n = t.getData('text/uri-list')
  return n ? n.replace(/\r?\n/g, ' ') : ''
}
mn.paste = (t, e) => {
  const n = e
  if (t.composing && !Fr) return
  const r = js ? null : n.clipboardData
  const i = t.input.shiftKey && t.input.lastKeyCode != 45
  r && Qs(t, bE(r), r.getData('text/html'), i, n)
    ? n.preventDefault()
    : hI(t, n)
}
const Wl = class {
  constructor (e, n, r) {
    (this.slice = e), (this.move = n), (this.node = r)
  }
}
const yE = Un ? 'altKey' : 'ctrlKey'
hn.dragstart = (t, e) => {
  const n = e
  const r = t.input.mouseDown
  if ((r && r.done(), !n.dataTransfer)) return
  const i = t.state.selection
  const o = i.empty ? null : t.posAtCoords(Jl(n))
  let s
  if (
    !(o && o.pos >= i.from && o.pos <= (i instanceof he ? i.to - 1 : i.to))
  ) {
    if (r && r.mightDrag) s = he.create(t.state.doc, r.mightDrag.pos)
    else if (n.target && n.target.nodeType == 1) {
      const h = t.docView.nearestDesc(n.target, !0)
      h &&
                h.node.type.spec.draggable &&
                h != t.docView &&
                (s = he.create(t.state.doc, h.posBefore))
    }
  }
  const l = (s || t.state.selection).content()
  const { dom: u, text: d, slice: f } = sE(t, l);
  (!n.dataTransfer.files.length || !rn || G0 > 120) &&
        n.dataTransfer.clearData(),
  n.dataTransfer.setData(js ? 'Text' : 'text/html', u.innerHTML),
  (n.dataTransfer.effectAllowed = 'copyMove'),
  js || n.dataTransfer.setData('text/plain', d),
  (t.dragging = new Wl(f, !n[yE], s))
}
hn.dragend = (t) => {
  const e = t.dragging
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null)
  }, 50)
}
mn.dragover = mn.dragenter = (t, e) => e.preventDefault()
mn.drop = (t, e) => {
  const n = e
  const r = t.dragging
  if (((t.dragging = null), !n.dataTransfer)) return
  const i = t.posAtCoords(Jl(n))
  if (!i) return
  const o = t.state.doc.resolve(i.pos)
  let s = r && r.slice
  s
    ? t.someProp('transformPasted', (g) => {
      s = g(s, t)
    })
    : (s = aE(
        t,
        bE(n.dataTransfer),
        js ? null : n.dataTransfer.getData('text/html'),
        !1,
        o
      ))
  const l = !!(r && !n[yE])
  if (t.someProp('handleDrop', (g) => g(t, n, s || Z.empty, l))) {
    n.preventDefault()
    return
  }
  if (!s) return
  n.preventDefault()
  let u = s ? Il(t.state.doc, o.pos, s) : o.pos
  u == null && (u = o.pos)
  const d = t.state.tr
  if (l) {
    const { node: g } = r
    g ? g.replace(d) : d.deleteSelection()
  }
  const f = d.mapping.map(u)
  const h = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1
  const m = d.doc
  if (
    (h
      ? d.replaceRangeWith(f, f, s.content.firstChild)
      : d.replaceRange(f, f, s),
    d.doc.eq(m))
  ) {
    return
  }
  const b = d.doc.resolve(f)
  if (
    h &&
        he.isSelectable(s.content.firstChild) &&
        b.nodeAfter &&
        b.nodeAfter.sameMarkup(s.content.firstChild)
  ) {
    d.setSelection(new he(b))
  } else {
    let g = d.mapping.map(u)
    d.mapping.maps[d.mapping.maps.length - 1].forEach(
      (E, w, S, O) => (g = O)
    ),
    d.setSelection(qf(t, b, d.doc.resolve(g)))
  }
  t.focus(), t.dispatch(d.setMeta('uiEvent', 'drop'))
}
hn.focus = (t) => {
  (t.input.lastFocus = Date.now()),
  t.focused ||
            (t.domObserver.stop(),
            t.dom.classList.add('ProseMirror-focused'),
            t.domObserver.start(),
            (t.focused = !0),
            setTimeout(() => {
              t.docView &&
                    t.hasFocus() &&
                    !t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
                    Hr(t)
            }, 20))
}
hn.blur = (t, e) => {
  const n = e
  t.focused &&
        (t.domObserver.stop(),
        t.dom.classList.remove('ProseMirror-focused'),
        t.domObserver.start(),
        n.relatedTarget &&
            t.dom.contains(n.relatedTarget) &&
            t.domObserver.currentSelection.clear(),
        (t.focused = !1))
}
hn.beforeinput = (t, e) => {
  if (rn && Fr && e.inputType == 'deleteContentBackward') {
    t.domObserver.flushSoon()
    const { domChangeCount: r } = t.input
    setTimeout(() => {
      if (
        t.input.domChangeCount != r ||
                (t.dom.blur(),
                t.focus(),
                t.someProp('handleKeyDown', (o) => o(t, Gi(8, 'Backspace'))))
      ) {
        return
      }
      const { $cursor: i } = t.state.selection
      i &&
                i.pos > 0 &&
                t.dispatch(
                  t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView()
                )
    }, 50)
  }
}
for (const t in mn) hn[t] = mn[t]
function ea (t, e) {
  if (t == e) return !0
  for (const n in t) if (t[n] !== e[n]) return !1
  for (const n in e) if (!(n in t)) return !1
  return !0
}
const Kl = class t {
  constructor (e, n) {
    (this.toDOM = e),
    (this.spec = n || Xi),
    (this.side = this.spec.side || 0)
  }

  map (e, n, r, i) {
    const { pos: o, deleted: s } = e.mapResult(
      n.from + i,
      this.side < 0 ? -1 : 1
    )
    return s ? null : new wt(o - r, o - r, this)
  }

  valid () {
    return !0
  }

  eq (e) {
    return (
      this == e ||
            (e instanceof t &&
                ((this.spec.key && this.spec.key == e.spec.key) ||
                    (this.toDOM == e.toDOM && ea(this.spec, e.spec))))
    )
  }

  destroy (e) {
    this.spec.destroy && this.spec.destroy(e)
  }
}
const Ji = class t {
  constructor (e, n) {
    (this.attrs = e), (this.spec = n || Xi)
  }

  map (e, n, r, i) {
    const o = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r
    const s = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r
    return o >= s ? null : new wt(o, s, this)
  }

  valid (e, n) {
    return n.from < n.to
  }

  eq (e) {
    return (
      this == e ||
            (e instanceof t && ea(this.attrs, e.attrs) && ea(this.spec, e.spec))
    )
  }

  static is (e) {
    return e.type instanceof t
  }

  destroy () {}
}
const Uf = class t {
  constructor (e, n) {
    (this.attrs = e), (this.spec = n || Xi)
  }

  map (e, n, r, i) {
    const o = e.mapResult(n.from + i, 1)
    if (o.deleted) return null
    const s = e.mapResult(n.to + i, -1)
    return s.deleted || s.pos <= o.pos
      ? null
      : new wt(o.pos - r, s.pos - r, this)
  }

  valid (e, n) {
    const { index: r, offset: i } = e.content.findIndex(n.from)
    let o
    return (
      i == n.from && !(o = e.child(r)).isText && i + o.nodeSize == n.to
    )
  }

  eq (e) {
    return (
      this == e ||
            (e instanceof t && ea(this.attrs, e.attrs) && ea(this.spec, e.spec))
    )
  }

  destroy () {}
}
var wt = class t {
  constructor (e, n, r) {
    (this.from = e), (this.to = n), (this.type = r)
  }

  copy (e, n) {
    return new t(e, n, this.type)
  }

  eq (e, n = 0) {
    return (
      this.type.eq(e.type) &&
            this.from + n == e.from &&
            this.to + n == e.to
    )
  }

  map (e, n, r) {
    return this.type.map(e, this, n, r)
  }

  static widget (e, n, r) {
    return new t(e, e, new Kl(n, r))
  }

  static inline (e, n, r, i) {
    return new t(e, n, new Ji(r, i))
  }

  static node (e, n, r, i) {
    return new t(e, n, new Uf(r, i))
  }

  get spec () {
    return this.type.spec
  }

  get inline () {
    return this.type instanceof Ji
  }

  get widget () {
    return this.type instanceof Kl
  }
}
const Wo = []
var Xi = {}
const ot = class t {
  constructor (e, n) {
    (this.local = e.length ? e : Wo), (this.children = n.length ? n : Wo)
  }

  static create (e, n) {
    return n.length ? Gl(n, e, 0, Xi) : nn
  }

  find (e, n, r) {
    const i = []
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i
  }

  findInner (e, n, r, i, o) {
    for (let s = 0; s < this.local.length; s++) {
      const l = this.local[s]
      l.from <= n &&
                l.to >= e &&
                (!o || o(l.spec)) &&
                r.push(l.copy(l.from + i, l.to + i))
    }
    for (let s = 0; s < this.children.length; s += 3) {
      if (this.children[s] < n && this.children[s + 1] > e) {
        const l = this.children[s] + 1
        this.children[s + 2].findInner(e - l, n - l, r, i + l, o)
      }
    }
  }

  map (e, n, r) {
    return this == nn || e.maps.length == 0
      ? this
      : this.mapInner(e, n, 0, 0, r || Xi)
  }

  mapInner (e, n, r, i, o) {
    let s
    for (let l = 0; l < this.local.length; l++) {
      const u = this.local[l].map(e, r, i)
      u && u.type.valid(n, u)
        ? (s || (s = [])).push(u)
        : o.onRemove && o.onRemove(this.local[l].spec)
    }
    return this.children.length
      ? mI(this.children, s || [], e, n, r, i, o)
      : s
        ? new t(s.sort(Zi), Wo)
        : nn
  }

  add (e, n) {
    return n.length
      ? this == nn
        ? t.create(e, n)
        : this.addInner(e, n, 0)
      : this
  }

  addInner (e, n, r) {
    let i
    let o = 0
    e.forEach((l, u) => {
      const d = u + r
      let f
      if ((f = vE(n, l, d))) {
        for (
          i || (i = this.children.slice());
          o < i.length && i[o] < u;

        ) {
          o += 3
        }
        i[o] == u
          ? (i[o + 2] = i[o + 2].addInner(l, f, d + 1))
          : i.splice(o, 0, u, u + l.nodeSize, Gl(f, l, d + 1, Xi)),
        (o += 3)
      }
    })
    const s = EE(o ? wE(n) : n, -r)
    for (let l = 0; l < s.length; l++) {
      s[l].type.valid(e, s[l]) || s.splice(l--, 1)
    }
    return new t(
      s.length ? this.local.concat(s).sort(Zi) : this.local,
      i || this.children
    )
  }

  remove (e) {
    return e.length == 0 || this == nn ? this : this.removeInner(e, 0)
  }

  removeInner (e, n) {
    let r = this.children
    let i = this.local
    for (let o = 0; o < r.length; o += 3) {
      let s
      const l = r[o] + n
      const u = r[o + 1] + n
      for (let f = 0, h; f < e.length; f++) {
        (h = e[f]) &&
                    h.from > l &&
                    h.to < u &&
                    ((e[f] = null), (s || (s = [])).push(h))
      }
      if (!s) continue
      r == this.children && (r = this.children.slice())
      const d = r[o + 2].removeInner(s, l + 1)
      d != nn ? (r[o + 2] = d) : (r.splice(o, 3), (o -= 3))
    }
    if (i.length) {
      for (let o = 0, s; o < e.length; o++) {
        if ((s = e[o])) {
          for (let l = 0; l < i.length; l++) {
            i[l].eq(s, n) &&
                            (i == this.local && (i = this.local.slice()),
                            i.splice(l--, 1))
          }
        }
      }
    }
    return r == this.children && i == this.local
      ? this
      : i.length || r.length
        ? new t(i, r)
        : nn
  }

  forChild (e, n) {
    if (this == nn) return this
    if (n.isLeaf) return t.empty
    let r, i
    for (let l = 0; l < this.children.length; l += 3) {
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2])
        break
      }
    }
    const o = e + 1
    const s = o + n.content.size
    for (let l = 0; l < this.local.length; l++) {
      const u = this.local[l]
      if (u.from < s && u.to > o && u.type instanceof Ji) {
        const d = Math.max(o, u.from) - o
        const f = Math.min(s, u.to) - o
        d < f && (i || (i = [])).push(u.copy(d, f))
      }
    }
    if (i) {
      const l = new t(i.sort(Zi), Wo)
      return r ? new Vl([l, r]) : l
    }
    return r || nn
  }

  eq (e) {
    if (this == e) return !0
    if (
      !(e instanceof t) ||
            this.local.length != e.local.length ||
            this.children.length != e.children.length
    ) {
      return !1
    }
    for (let n = 0; n < this.local.length; n++) {
      if (!this.local[n].eq(e.local[n])) return !1
    }
    for (let n = 0; n < this.children.length; n += 3) {
      if (
        this.children[n] != e.children[n] ||
                this.children[n + 1] != e.children[n + 1] ||
                !this.children[n + 2].eq(e.children[n + 2])
      ) {
        return !1
      }
    }
    return !0
  }

  locals (e) {
    return Zf(this.localsInner(e))
  }

  localsInner (e) {
    if (this == nn) return Wo
    if (e.inlineContent || !this.local.some(Ji.is)) return this.local
    const n = []
    for (let r = 0; r < this.local.length; r++) {
      this.local[r].type instanceof Ji || n.push(this.local[r])
    }
    return n
  }

  forEachSet (e) {
    e(this)
  }
}
ot.empty = new ot([], [])
ot.removeOverlap = Zf
var nn = ot.empty
var Vl = class t {
  constructor (e) {
    this.members = e
  }

  map (e, n) {
    const r = this.members.map((i) => i.map(e, n, Xi))
    return t.from(r)
  }

  forChild (e, n) {
    if (n.isLeaf) return ot.empty
    let r = []
    for (let i = 0; i < this.members.length; i++) {
      const o = this.members[i].forChild(e, n)
      o != nn && (o instanceof t ? (r = r.concat(o.members)) : r.push(o))
    }
    return t.from(r)
  }

  eq (e) {
    if (!(e instanceof t) || e.members.length != this.members.length) {
      return !1
    }
    for (let n = 0; n < this.members.length; n++) {
      if (!this.members[n].eq(e.members[n])) return !1
    }
    return !0
  }

  locals (e) {
    let n
    let r = !0
    for (let i = 0; i < this.members.length; i++) {
      const o = this.members[i].localsInner(e)
      if (o.length) {
        if (!n) n = o
        else {
          r && ((n = n.slice()), (r = !1))
          for (let s = 0; s < o.length; s++) n.push(o[s])
        }
      }
    }
    return n ? Zf(r ? n : n.sort(Zi)) : Wo
  }

  static from (e) {
    switch (e.length) {
      case 0:
        return nn
      case 1:
        return e[0]
      default:
        return new t(
          e.every((n) => n instanceof ot)
            ? e
            : e.reduce(
              (n, r) =>
                n.concat(r instanceof ot ? r : r.members),
              []
            )
        )
    }
  }

  forEachSet (e) {
    for (let n = 0; n < this.members.length; n++) {
      this.members[n].forEachSet(e)
    }
  }
}
function mI (t, e, n, r, i, o, s) {
  const l = t.slice()
  for (let d = 0, f = o; d < n.maps.length; d++) {
    let h = 0
    n.maps[d].forEach((m, b, g, E) => {
      const w = E - g - (b - m)
      for (let S = 0; S < l.length; S += 3) {
        const O = l[S + 1]
        if (O < 0 || m > O + f - h) continue
        const k = l[S] + f - h
        b >= k
          ? (l[S + 1] = m <= k ? -2 : -1)
          : m >= f && w && ((l[S] += w), (l[S + 1] += w))
      }
      h += w
    }),
    (f = n.maps[d].map(f, -1))
  }
  let u = !1
  for (let d = 0; d < l.length; d += 3) {
    if (l[d + 1] < 0) {
      if (l[d + 1] == -2) {
        (u = !0), (l[d + 1] = -1)
        continue
      }
      const f = n.map(t[d] + o)
      const h = f - i
      if (h < 0 || h >= r.content.size) {
        u = !0
        continue
      }
      const m = n.map(t[d + 1] + o, -1)
      const b = m - i
      const { index: g, offset: E } = r.content.findIndex(h)
      const w = r.maybeChild(g)
      if (w && E == h && E + w.nodeSize == b) {
        const S = l[d + 2].mapInner(n, w, f + 1, t[d] + o + 1, s)
        S != nn
          ? ((l[d] = h), (l[d + 1] = b), (l[d + 2] = S))
          : ((l[d + 1] = -2), (u = !0))
      } else u = !0
    }
  }
  if (u) {
    const d = gI(l, t, e, n, i, o, s)
    const f = Gl(d, r, 0, s)
    e = f.local
    for (let h = 0; h < l.length; h += 3) {
      l[h + 1] < 0 && (l.splice(h, 3), (h -= 3))
    }
    for (let h = 0, m = 0; h < f.children.length; h += 3) {
      const b = f.children[h]
      for (; m < l.length && l[m] < b;) m += 3
      l.splice(m, 0, f.children[h], f.children[h + 1], f.children[h + 2])
    }
  }
  return new ot(e.sort(Zi), l)
}
function EE (t, e) {
  if (!e || !t.length) return t
  const n = []
  for (let r = 0; r < t.length; r++) {
    const i = t[r]
    n.push(new wt(i.from + e, i.to + e, i.type))
  }
  return n
}
function gI (t, e, n, r, i, o, s) {
  function l (u, d) {
    for (let f = 0; f < u.local.length; f++) {
      const h = u.local[f].map(r, i, d)
      h ? n.push(h) : s.onRemove && s.onRemove(u.local[f].spec)
    }
    for (let f = 0; f < u.children.length; f += 3) {
      l(u.children[f + 2], u.children[f] + d + 1)
    }
  }
  for (let u = 0; u < t.length; u += 3) {
    t[u + 1] == -1 && l(t[u + 2], e[u] + o + 1)
  }
  return n
}
function vE (t, e, n) {
  if (e.isLeaf) return null
  const r = n + e.nodeSize
  let i = null
  for (let o = 0, s; o < t.length; o++) {
    (s = t[o]) &&
            s.from > n &&
            s.to < r &&
            ((i || (i = [])).push(s), (t[o] = null))
  }
  return i
}
function wE (t) {
  const e = []
  for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n])
  return e
}
function Gl (t, e, n, r) {
  const i = []
  let o = !1
  e.forEach((l, u) => {
    const d = vE(t, l, u + n)
    if (d) {
      o = !0
      const f = Gl(d, l, n + u + 1, r)
      f != nn && i.push(u, u + l.nodeSize, f)
    }
  })
  const s = EE(o ? wE(t) : t, -n).sort(Zi)
  for (let l = 0; l < s.length; l++) {
    s[l].type.valid(e, s[l]) ||
            (r.onRemove && r.onRemove(s[l].spec), s.splice(l--, 1))
  }
  return s.length || i.length ? new ot(s, i) : nn
}
function Zi (t, e) {
  return t.from - e.from || t.to - e.to
}
function Zf (t) {
  let e = t
  for (let n = 0; n < e.length - 1; n++) {
    const r = e[n]
    if (r.from != r.to) {
      for (let i = n + 1; i < e.length; i++) {
        const o = e[i]
        if (o.from == r.from) {
          o.to != r.to &&
                        (e == t && (e = t.slice()),
                        (e[i] = o.copy(o.from, r.to)),
                        D0(e, i + 1, o.copy(r.to, o.to)))
          continue
        } else {
          o.from < r.to &&
                        (e == t && (e = t.slice()),
                        (e[n] = r.copy(r.from, o.from)),
                        D0(e, i, r.copy(o.from, r.to)))
          break
        }
      }
    }
  }
  return e
}
function D0 (t, e, n) {
  for (; e < t.length && Zi(n, t[e]) > 0;) e++
  t.splice(e, 0, n)
}
function Tf (t) {
  const e = []
  return (
    t.someProp('decorations', (n) => {
      const r = n(t.state)
      r && r != nn && e.push(r)
    }),
    t.cursorWrapper &&
            e.push(ot.create(t.state.doc, [t.cursorWrapper.deco])),
    Vl.from(e)
  )
}
const bI = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}
const yI = wn && hi <= 11
const Wf = class {
  constructor () {
    (this.anchorNode = null),
    (this.anchorOffset = 0),
    (this.focusNode = null),
    (this.focusOffset = 0)
  }

  set (e) {
    (this.anchorNode = e.anchorNode),
    (this.anchorOffset = e.anchorOffset),
    (this.focusNode = e.focusNode),
    (this.focusOffset = e.focusOffset)
  }

  clear () {
    this.anchorNode = this.focusNode = null
  }

  eq (e) {
    return (
      e.anchorNode == this.anchorNode &&
            e.anchorOffset == this.anchorOffset &&
            e.focusNode == this.focusNode &&
            e.focusOffset == this.focusOffset
    )
  }
}
const Kf = class {
  constructor (e, n) {
    (this.view = e),
    (this.handleDOMChange = n),
    (this.queue = []),
    (this.flushingSoon = -1),
    (this.observer = null),
    (this.currentSelection = new Wf()),
    (this.onCharData = null),
    (this.suppressingSelectionUpdates = !1),
    (this.lastChangedTextNode = null),
    (this.observer =
                window.MutationObserver &&
                new window.MutationObserver((r) => {
                  for (let i = 0; i < r.length; i++) {
                    this.queue.push(r[i])
                  }
                  wn &&
                    hi <= 11 &&
                    r.some(
                      (i) =>
                        (i.type == 'childList' && i.removedNodes.length) ||
                            (i.type == 'characterData' &&
                                i.oldValue.length > i.target.nodeValue.length)
                    )
                    ? this.flushSoon()
                    : this.flush()
                })),
    yI &&
                (this.onCharData = (r) => {
                  this.queue.push({
                    target: r.target,
                    type: 'characterData',
                    oldValue: r.prevValue
                  }),
                  this.flushSoon()
                }),
    (this.onSelectionChange = this.onSelectionChange.bind(this))
  }

  flushSoon () {
    this.flushingSoon < 0 &&
            (this.flushingSoon = window.setTimeout(() => {
              (this.flushingSoon = -1), this.flush()
            }, 20))
  }

  forceFlush () {
    this.flushingSoon > -1 &&
            (window.clearTimeout(this.flushingSoon),
            (this.flushingSoon = -1),
            this.flush())
  }

  start () {
    this.observer &&
            (this.observer.takeRecords(),
            this.observer.observe(this.view.dom, bI)),
    this.onCharData &&
                this.view.dom.addEventListener(
                  'DOMCharacterDataModified',
                  this.onCharData
                ),
    this.connectSelection()
  }

  stop () {
    if (this.observer) {
      const e = this.observer.takeRecords()
      if (e.length) {
        for (let n = 0; n < e.length; n++) this.queue.push(e[n])
        window.setTimeout(() => this.flush(), 20)
      }
      this.observer.disconnect()
    }
    this.onCharData &&
            this.view.dom.removeEventListener(
              'DOMCharacterDataModified',
              this.onCharData
            ),
    this.disconnectSelection()
  }

  connectSelection () {
    this.view.dom.ownerDocument.addEventListener(
      'selectionchange',
      this.onSelectionChange
    )
  }

  disconnectSelection () {
    this.view.dom.ownerDocument.removeEventListener(
      'selectionchange',
      this.onSelectionChange
    )
  }

  suppressSelectionUpdates () {
    (this.suppressingSelectionUpdates = !0),
    setTimeout(() => (this.suppressingSelectionUpdates = !1), 50)
  }

  onSelectionChange () {
    if (C0(this.view)) {
      if (this.suppressingSelectionUpdates) return Hr(this.view)
      if (wn && hi <= 11 && !this.view.state.selection.empty) {
        const e = this.view.domSelectionRange()
        if (
          e.focusNode &&
                    ji(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
        ) {
          return this.flushSoon()
        }
      }
      this.flush()
    }
  }

  setCurSelection () {
    this.currentSelection.set(this.view.domSelectionRange())
  }

  ignoreSelectionChange (e) {
    if (!e.focusNode) return !0
    const n = new Set()
    let r
    for (let o = e.focusNode; o; o = Zs(o)) n.add(o)
    for (let o = e.anchorNode; o; o = Zs(o)) {
      if (n.has(o)) {
        r = o
        break
      }
    }
    const i = r && this.view.docView.nearestDesc(r)
    if (
      i &&
            i.ignoreMutation({
              type: 'selection',
              target: r.nodeType == 3 ? r.parentNode : r
            })
    ) {
      return this.setCurSelection(), !0
    }
  }

  pendingRecords () {
    if (this.observer) {
      for (const e of this.observer.takeRecords()) this.queue.push(e)
    }
    return this.queue
  }

  flush () {
    const { view: e } = this
    if (!e.docView || this.flushingSoon > -1) return
    const n = this.pendingRecords()
    n.length && (this.queue = [])
    const r = e.domSelectionRange()
    const i =
            !this.suppressingSelectionUpdates &&
            !this.currentSelection.eq(r) &&
            C0(e) &&
            !this.ignoreSelectionChange(r)
    let o = -1
    let s = -1
    let l = !1
    const u = []
    if (e.editable) {
      for (let f = 0; f < n.length; f++) {
        const h = this.registerMutation(n[f], u)
        h &&
                    ((o = o < 0 ? h.from : Math.min(h.from, o)),
                    (s = s < 0 ? h.to : Math.max(h.to, s)),
                    h.typeOver && (l = !0))
      }
    }
    if (ir && u.length) {
      const f = u.filter((h) => h.nodeName == 'BR')
      if (f.length == 2) {
        const [h, m] = f
        h.parentNode && h.parentNode.parentNode == m.parentNode
          ? m.remove()
          : h.remove()
      } else {
        const { focusNode: h } = this.currentSelection
        for (const m of f) {
          const b = m.parentNode
          b &&
                        b.nodeName == 'LI' &&
                        (!h || wI(e, h) != b) &&
                        m.remove()
        }
      }
    }
    let d = null
    o < 0 &&
        i &&
        e.input.lastFocus > Date.now() - 200 &&
        Math.max(e.input.lastTouch, e.input.lastClick.time) <
            Date.now() - 300 &&
        Yl(r) &&
        (d = Gf(e)) &&
        d.eq(ue.near(e.state.doc.resolve(0), 1))
      ? ((e.input.lastFocus = 0),
        Hr(e),
        this.currentSelection.set(r),
        e.scrollToSelection())
      : (o > -1 || i) &&
              (o > -1 && (e.docView.markDirty(o, s), EI(e)),
              this.handleDOMChange(o, s, l, u),
              e.docView && e.docView.dirty
                ? e.updateState(e.state)
                : this.currentSelection.eq(r) || Hr(e),
              this.currentSelection.set(r))
  }

  registerMutation (e, n) {
    if (n.indexOf(e.target) > -1) return null
    const r = this.view.docView.nearestDesc(e.target)
    if (
      (e.type == 'attributes' &&
                (r == this.view.docView ||
                    e.attributeName == 'contenteditable' ||
                    (e.attributeName == 'style' &&
                        !e.oldValue &&
                        !e.target.getAttribute('style')))) ||
            !r ||
            r.ignoreMutation(e)
    ) {
      return null
    }
    if (e.type == 'childList') {
      for (let f = 0; f < e.addedNodes.length; f++) {
        const h = e.addedNodes[f]
        n.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h)
      }
      if (
        r.contentDOM &&
                r.contentDOM != r.dom &&
                !r.contentDOM.contains(e.target)
      ) {
        return { from: r.posBefore, to: r.posAfter }
      }
      let i = e.previousSibling
      let o = e.nextSibling
      if (wn && hi <= 11 && e.addedNodes.length) {
        for (let f = 0; f < e.addedNodes.length; f++) {
          const { previousSibling: h, nextSibling: m } =
                        e.addedNodes[f];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) &&
                        (i = h),
          (!m ||
                            Array.prototype.indexOf.call(e.addedNodes, m) <
                                0) &&
                            (o = m)
        }
      }
      const s = i && i.parentNode == e.target ? qt(i) + 1 : 0
      const l = r.localPosFromDOM(e.target, s, -1)
      const u =
                o && o.parentNode == e.target
                  ? qt(o)
                  : e.target.childNodes.length
      const d = r.localPosFromDOM(e.target, u, 1)
      return { from: l, to: d }
    } else {
      return e.type == 'attributes'
        ? {
            from: r.posAtStart - r.border,
            to: r.posAtEnd + r.border
          }
        : ((this.lastChangedTextNode = e.target),
          {
            from: r.posAtStart,
            to: r.posAtEnd,
            typeOver: e.target.nodeValue == e.oldValue
          })
    }
  }
}
const L0 = new WeakMap()
let P0 = !1
function EI (t) {
  if (
    !L0.has(t) &&
        (L0.set(t, null),
        ['normal', 'nowrap', 'pre-line'].indexOf(
          getComputedStyle(t.dom).whiteSpace
        ) !== -1)
  ) {
    if (((t.requiresGeckoHackNode = ir), P0)) return
    console.warn(
      "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
    ),
    (P0 = !0)
  }
}
function B0 (t, e) {
  let n = e.startContainer
  let r = e.startOffset
  let i = e.endContainer
  let o = e.endOffset
  const s = t.domAtPos(t.state.selection.anchor)
  return (
    ji(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]),
    { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o }
  )
}
function vI (t, e) {
  if (e.getComposedRanges) {
    const i = e.getComposedRanges(t.root)[0]
    if (i) return B0(t, i)
  }
  let n
  function r (i) {
    i.preventDefault(),
    i.stopImmediatePropagation(),
    (n = i.getTargetRanges()[0])
  }
  return (
    t.dom.addEventListener('beforeinput', r, !0),
    document.execCommand('indent'),
    t.dom.removeEventListener('beforeinput', r, !0),
    n ? B0(t, n) : null
  )
}
function wI (t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    const r = t.docView.nearestDesc(n, !0)
    if (r && r.node.isBlock) return n
  }
  return null
}
function xI (t, e, n) {
  let {
    node: r,
    fromOffset: i,
    toOffset: o,
    from: s,
    to: l
  } = t.docView.parseRange(e, n)
  const u = t.domSelectionRange()
  let d
  const f = u.anchorNode
  if (
    (f &&
            t.dom.contains(f.nodeType == 1 ? f : f.parentNode) &&
            ((d = [{ node: f, offset: u.anchorOffset }]),
            Yl(u) || d.push({ node: u.focusNode, offset: u.focusOffset })),
    rn && t.input.lastKeyCode === 8)
  ) {
    for (let w = o; w > i; w--) {
      const S = r.childNodes[w - 1]
      const O = S.pmViewDesc
      if (S.nodeName == 'BR' && !O) {
        o = w
        break
      }
      if (!O || O.size) break
    }
  }
  const h = t.state.doc
  const m = t.someProp('domParser') || Rr.fromSchema(t.state.schema)
  const b = h.resolve(s)
  let g = null
  const E = m.parse(r, {
    topNode: b.parent,
    topMatch: b.parent.contentMatchAt(b.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: b.parent.type.whitespace == 'pre' ? 'full' : !0,
    findPositions: d,
    ruleFromNode: _I,
    context: b
  })
  if (d && d[0].pos != null) {
    const w = d[0].pos
    let S = d[1] && d[1].pos
    S == null && (S = w), (g = { anchor: w + s, head: S + s })
  }
  return { doc: E, sel: g, from: s, to: l }
}
function _I (t) {
  const e = t.pmViewDesc
  if (e) return e.parseRule()
  if (t.nodeName == 'BR' && t.parentNode) {
    if (pn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      const n = document.createElement('div')
      return n.appendChild(document.createElement('li')), { skip: n }
    } else if (
      t.parentNode.lastChild == t ||
            (pn && /^(tr|table)$/i.test(t.parentNode.nodeName))
    ) {
      return { ignore: !0 }
    }
  } else if (t.nodeName == 'IMG' && t.getAttribute('mark-placeholder')) {
    return { ignore: !0 }
  }
  return null
}
const SI =
    /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i
function TI (t, e, n, r, i) {
  const o =
        t.input.compositionPendingChanges ||
        (t.composing ? t.input.compositionID : 0)
  if (((t.input.compositionPendingChanges = 0), e < 0)) {
    const q =
            t.input.lastSelectionTime > Date.now() - 50
              ? t.input.lastSelectionOrigin
              : null
    const Q = Gf(t, q)
    if (Q && !t.state.selection.eq(Q)) {
      if (
        rn &&
                Fr &&
                t.input.lastKeyCode === 13 &&
                Date.now() - 100 < t.input.lastKeyCodeTime &&
                t.someProp('handleKeyDown', (we) => we(t, Gi(13, 'Enter')))
      ) {
        return
      }
      const fe = t.state.tr.setSelection(Q)
      q == 'pointer'
        ? fe.setMeta('pointer', !0)
        : q == 'key' && fe.scrollIntoView(),
      o && fe.setMeta('composition', o),
      t.dispatch(fe)
    }
    return
  }
  const s = t.state.doc.resolve(e)
  const l = s.sharedDepth(n);
  (e = s.before(l + 1)), (n = t.state.doc.resolve(n).after(l + 1))
  const u = t.state.selection
  const d = xI(t, e, n)
  const f = t.state.doc
  const h = f.slice(d.from, d.to)
  let m
  let b
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
    ? ((m = t.state.selection.to), (b = 'end'))
    : ((m = t.state.selection.from), (b = 'start')),
  (t.input.lastKeyCode = null)
  let g = MI(h.content, d.doc.content, d.from, m, b)
  if (
    (g && t.input.domChangeCount++,
    ((Vo && t.input.lastIOSEnter > Date.now() - 225) || Fr) &&
            i.some((q) => q.nodeType == 1 && !SI.test(q.nodeName)) &&
            (!g || g.endA >= g.endB) &&
            t.someProp('handleKeyDown', (q) => q(t, Gi(13, 'Enter'))))
  ) {
    t.input.lastIOSEnter = 0
    return
  }
  if (!g) {
    if (
      r &&
            u instanceof le &&
            !u.empty &&
            u.$head.sameParent(u.$anchor) &&
            !t.composing &&
            !(d.sel && d.sel.anchor != d.sel.head)
    ) {
      g = { start: u.from, endA: u.to, endB: u.to }
    } else {
      if (d.sel) {
        const q = F0(t, t.state.doc, d.sel)
        if (q && !q.eq(t.state.selection)) {
          const Q = t.state.tr.setSelection(q)
          o && Q.setMeta('composition', o), t.dispatch(Q)
        }
      }
      return
    }
  }
  t.state.selection.from < t.state.selection.to &&
        g.start == g.endB &&
        t.state.selection instanceof le &&
        (g.start > t.state.selection.from &&
        g.start <= t.state.selection.from + 2 &&
        t.state.selection.from >= d.from
          ? (g.start = t.state.selection.from)
          : g.endA < t.state.selection.to &&
              g.endA >= t.state.selection.to - 2 &&
              t.state.selection.to <= d.to &&
              ((g.endB += t.state.selection.to - g.endA),
              (g.endA = t.state.selection.to))),
  wn &&
            hi <= 11 &&
            g.endB == g.start + 1 &&
            g.endA == g.start &&
            g.start > d.from &&
            d.doc.textBetween(g.start - d.from - 1, g.start - d.from + 1) ==
                ' \xA0' &&
            (g.start--, g.endA--, g.endB--)
  const E = d.doc.resolveNoCache(g.start - d.from)
  let w = d.doc.resolveNoCache(g.endB - d.from)
  const S = f.resolve(g.start)
  const O = E.sameParent(w) && E.parent.inlineContent && S.end() >= g.endA
  let k
  if (
    ((Vo &&
            t.input.lastIOSEnter > Date.now() - 225 &&
            (!O || i.some((q) => q.nodeName == 'DIV' || q.nodeName == 'P'))) ||
            (!O &&
                E.pos < d.doc.content.size &&
                !E.sameParent(w) &&
                (k = ue.findFrom(d.doc.resolve(E.pos + 1), 1, !0)) &&
                k.head == w.pos)) &&
        t.someProp('handleKeyDown', (q) => q(t, Gi(13, 'Enter')))
  ) {
    t.input.lastIOSEnter = 0
    return
  }
  if (
    t.state.selection.anchor > g.start &&
        AI(f, g.start, g.endA, E, w) &&
        t.someProp('handleKeyDown', (q) => q(t, Gi(8, 'Backspace')))
  ) {
    Fr && rn && t.domObserver.suppressSelectionUpdates()
    return
  }
  rn && g.endB == g.start && (t.input.lastChromeDelete = Date.now()),
  Fr &&
            !O &&
            E.start() != w.start() &&
            w.parentOffset == 0 &&
            E.depth == w.depth &&
            d.sel &&
            d.sel.anchor == d.sel.head &&
            d.sel.head == g.endA &&
            ((g.endB -= 2),
            (w = d.doc.resolveNoCache(g.endB - d.from)),
            setTimeout(() => {
              t.someProp('handleKeyDown', function (q) {
                return q(t, Gi(13, 'Enter'))
              })
            }, 20))
  const T = g.start
  const P = g.endA
  let I
  let Y
  let ne
  if (O) {
    if (E.pos == w.pos) {
      wn &&
                hi <= 11 &&
                E.parentOffset == 0 &&
                (t.domObserver.suppressSelectionUpdates(),
                setTimeout(() => Hr(t), 20)),
      (I = t.state.tr.delete(T, P)),
      (Y = f.resolve(g.start).marksAcross(f.resolve(g.endA)))
    } else if (
      g.endA == g.endB &&
            (ne = CI(
              E.parent.content.cut(E.parentOffset, w.parentOffset),
              S.parent.content.cut(S.parentOffset, g.endA - S.start())
            ))
    ) {
      (I = t.state.tr),
      ne.type == 'add'
        ? I.addMark(T, P, ne.mark)
        : I.removeMark(T, P, ne.mark)
    } else if (
      E.parent.child(E.index()).isText &&
            E.index() == w.index() - (w.textOffset ? 0 : 1)
    ) {
      const q = E.parent.textBetween(E.parentOffset, w.parentOffset)
      if (t.someProp('handleTextInput', (Q) => Q(t, T, P, q))) return
      I = t.state.tr.insertText(q, T, P)
    }
  }
  if (
    (I ||
            (I = t.state.tr.replace(
              T,
              P,
              d.doc.slice(g.start - d.from, g.endB - d.from)
            )),
    d.sel)
  ) {
    const q = F0(t, I.doc, d.sel)
    q &&
            !(
              (rn &&
                    t.composing &&
                    q.empty &&
                    (g.start != g.endB ||
                        t.input.lastChromeDelete < Date.now() - 100) &&
                    (q.head == T || q.head == I.mapping.map(P) - 1)) ||
                (wn && q.empty && q.head == T)
            ) &&
            I.setSelection(q)
  }
  Y && I.ensureMarks(Y),
  o && I.setMeta('composition', o),
  t.dispatch(I.scrollIntoView())
}
function F0 (t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size
    ? null
    : qf(t, e.resolve(n.anchor), e.resolve(n.head))
}
function CI (t, e) {
  const n = t.firstChild.marks
  const r = e.firstChild.marks
  let i = n
  let o = r
  let s
  let l
  let u
  for (let f = 0; f < r.length; f++) i = r[f].removeFromSet(i)
  for (let f = 0; f < n.length; f++) o = n[f].removeFromSet(o)
  if (i.length == 1 && o.length == 0) {
    (l = i[0]), (s = 'add'), (u = (f) => f.mark(l.addToSet(f.marks)))
  } else if (i.length == 0 && o.length == 1) {
    (l = o[0]),
    (s = 'remove'),
    (u = (f) => f.mark(l.removeFromSet(f.marks)))
  } else return null
  const d = []
  for (let f = 0; f < e.childCount; f++) d.push(u(e.child(f)))
  if (K.from(d).eq(t)) return { mark: l, type: s }
}
function AI (t, e, n, r, i) {
  if (n - e <= i.pos - r.pos || Cf(r, !0, !1) < i.pos) return !1
  const o = t.resolve(e)
  if (!r.parent.isTextblock) {
    const l = o.nodeAfter
    return l != null && n == e + l.nodeSize
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock) {
    return !1
  }
  const s = t.resolve(Cf(o, !0, !0))
  return !s.parent.isTextblock || s.pos > n || Cf(s, !0, !1) < n
    ? !1
    : r.parent.content.cut(r.parentOffset).eq(s.parent.content)
}
function Cf (t, e, n) {
  let r = t.depth
  let i = e ? t.end() : t.pos
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount);) {
    r--, i++, (e = !1)
  }
  if (n) {
    let o = t.node(r).maybeChild(t.indexAfter(r))
    for (; o && !o.isLeaf;) (o = o.firstChild), i++
  }
  return i
}
function MI (t, e, n, r, i) {
  let o = t.findDiffStart(e, n)
  if (o == null) return null
  let { a: s, b: l } = t.findDiffEnd(e, n + t.size, n + e.size)
  if (i == 'end') {
    const u = Math.max(0, o - Math.min(s, l))
    r -= s + u - o
  }
  if (s < o && t.size < e.size) {
    const u = r <= o && r >= s ? o - r : 0;
    (o -= u),
    o &&
                o < e.size &&
                H0(e.textBetween(o - 1, o + 1)) &&
                (o += u ? 1 : -1),
    (l = o + (l - s)),
    (s = o)
  } else if (l < o) {
    const u = r <= o && r >= l ? o - r : 0;
    (o -= u),
    o &&
                o < t.size &&
                H0(t.textBetween(o - 1, o + 1)) &&
                (o += u ? 1 : -1),
    (s = o + (s - l)),
    (l = o)
  }
  return { start: o, endA: s, endB: l }
}
function H0 (t) {
  if (t.length != 2) return !1
  const e = t.charCodeAt(0)
  const n = t.charCodeAt(1)
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319
}
const ql = class {
  constructor (e, n) {
    (this._root = null),
    (this.focused = !1),
    (this.trackWrites = null),
    (this.mounted = !1),
    (this.markCursor = null),
    (this.cursorWrapper = null),
    (this.lastSelectedViewDesc = void 0),
    (this.input = new Hf()),
    (this.prevDirectPlugins = []),
    (this.pluginViews = []),
    (this.requiresGeckoHackNode = !1),
    (this.dragging = null),
    (this._props = n),
    (this.state = n.state),
    (this.directPlugins = n.plugins || []),
    this.directPlugins.forEach(K0),
    (this.dispatch = this.dispatch.bind(this)),
    (this.dom = (e && e.mount) || document.createElement('div')),
    e &&
                (e.appendChild
                  ? e.appendChild(this.dom)
                  : typeof e === 'function'
                    ? e(this.dom)
                    : e.mount && (this.mounted = !0)),
    (this.editable = U0(this)),
    z0(this),
    (this.nodeViews = W0(this)),
    (this.docView = v0(
      this.state.doc,
      $0(this),
      Tf(this),
      this.dom,
      this
    )),
    (this.domObserver = new Kf(this, (r, i, o, s) =>
      TI(this, r, i, o, s)
    )),
    this.domObserver.start(),
    jR(this),
    this.updatePluginViews()
  }

  get composing () {
    return this.input.composing
  }

  get props () {
    if (this._props.state != this.state) {
      const e = this._props
      this._props = {}
      for (const n in e) this._props[n] = e[n]
      this._props.state = this.state
    }
    return this._props
  }

  update (e) {
    e.handleDOMEvents != this._props.handleDOMEvents && $f(this)
    const n = this._props;
    (this._props = e),
    e.plugins &&
                (e.plugins.forEach(K0), (this.directPlugins = e.plugins)),
    this.updateStateInner(e.state, n)
  }

  setProps (e) {
    const n = {}
    for (const r in this._props) n[r] = this._props[r]
    n.state = this.state
    for (const r in e) n[r] = e[r]
    this.update(n)
  }

  updateState (e) {
    this.updateStateInner(e, this._props)
  }

  updateStateInner (e, n) {
    let r
    const i = this.state
    let o = !1
    let s = !1
    e.storedMarks && this.composing && (gE(this), (s = !0)),
    (this.state = e)
    const l = i.plugins != e.plugins || this._props.plugins != n.plugins
    if (
      l ||
            this._props.plugins != n.plugins ||
            this._props.nodeViews != n.nodeViews
    ) {
      const b = W0(this)
      kI(b, this.nodeViews) && ((this.nodeViews = b), (o = !0))
    }
    (l || n.handleDOMEvents != this._props.handleDOMEvents) && $f(this),
    (this.editable = U0(this)),
    z0(this)
    const u = Tf(this)
    const d = $0(this)
    const f =
            i.plugins != e.plugins && !i.doc.eq(e.doc)
              ? 'reset'
              : e.scrollToSelection > i.scrollToSelection
                ? 'to selection'
                : 'preserve'
    const h = o || !this.docView.matchesNode(e.doc, d, u);
    (h || !e.selection.eq(i.selection)) && (s = !0)
    const m =
            f == 'preserve' &&
            s &&
            this.dom.style.overflowAnchor == null &&
            gR(this)
    if (s) {
      this.domObserver.stop()
      let b =
                h &&
                (wn || rn) &&
                !this.composing &&
                !i.selection.empty &&
                !e.selection.empty &&
                NI(i.selection, e.selection)
      if (h) {
        const g = rn
          ? (this.trackWrites = this.domSelectionRange().focusNode)
          : null
        this.composing && (this.input.compositionNode = uI(this)),
        (o || !this.docView.update(e.doc, d, u, this)) &&
                        (this.docView.updateOuterDeco(d),
                        this.docView.destroy(),
                        (this.docView = v0(e.doc, d, u, this.dom, this))),
        g && !this.trackWrites && (b = !0)
      }
      b ||
            !(
              this.input.mouseDown &&
                this.domObserver.currentSelection.eq(
                  this.domSelectionRange()
                ) &&
                BR(this)
            )
        ? Hr(this, b)
        : (rE(this, e.selection), this.domObserver.setCurSelection()),
      this.domObserver.start()
    }
    this.updatePluginViews(i),
    !((r = this.dragging) === null || r === void 0) &&
                r.node &&
                !i.doc.eq(e.doc) &&
                this.updateDraggedNode(this.dragging, i),
    f == 'reset'
      ? (this.dom.scrollTop = 0)
      : f == 'to selection'
        ? this.scrollToSelection()
        : m && bR(m)
  }

  scrollToSelection () {
    const e = this.domSelectionRange().focusNode
    if (!this.someProp('handleScrollToSelection', (n) => n(this))) {
      if (this.state.selection instanceof he) {
        const n = this.docView.domAfterPos(this.state.selection.from)
        n.nodeType == 1 && h0(this, n.getBoundingClientRect(), e)
      } else h0(this, this.coordsAtPos(this.state.selection.head, 1), e)
    }
  }

  destroyPluginViews () {
    let e
    for (; (e = this.pluginViews.pop());) e.destroy && e.destroy()
  }

  updatePluginViews (e) {
    if (
      !e ||
            e.plugins != this.state.plugins ||
            this.directPlugins != this.prevDirectPlugins
    ) {
      (this.prevDirectPlugins = this.directPlugins),
      this.destroyPluginViews()
      for (let n = 0; n < this.directPlugins.length; n++) {
        const r = this.directPlugins[n]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        const r = this.state.plugins[n]
        r.spec.view && this.pluginViews.push(r.spec.view(this))
      }
    } else {
      for (let n = 0; n < this.pluginViews.length; n++) {
        const r = this.pluginViews[n]
        r.update && r.update(this, e)
      }
    }
  }

  updateDraggedNode (e, n) {
    const r = e.node
    let i = -1
    if (this.state.doc.nodeAt(r.from) == r.node) i = r.from
    else {
      const o =
                r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o)
    }
    this.dragging = new Wl(
      e.slice,
      e.move,
      i < 0 ? void 0 : he.create(this.state.doc, i)
    )
  }

  someProp (e, n) {
    const r = this._props && this._props[e]
    let i
    if (r != null && (i = n ? n(r) : r)) return i
    for (let s = 0; s < this.directPlugins.length; s++) {
      const l = this.directPlugins[s].props[e]
      if (l != null && (i = n ? n(l) : l)) return i
    }
    const o = this.state.plugins
    if (o) {
      for (let s = 0; s < o.length; s++) {
        const l = o[s].props[e]
        if (l != null && (i = n ? n(l) : l)) return i
      }
    }
  }

  hasFocus () {
    if (wn) {
      let e = this.root.activeElement
      if (e == this.dom) return !0
      if (!e || !this.dom.contains(e)) return !1
      for (; e && this.dom != e && this.dom.contains(e);) {
        if (e.contentEditable == 'false') return !1
        e = e.parentElement
      }
      return !0
    }
    return this.root.activeElement == this.dom
  }

  focus () {
    this.domObserver.stop(),
    this.editable && yR(this.dom),
    Hr(this),
    this.domObserver.start()
  }

  get root () {
    const e = this._root
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode) {
        if (n.nodeType == 9 || (n.nodeType == 11 && n.host)) {
          return (
            n.getSelection ||
                            (Object.getPrototypeOf(n).getSelection = () =>
                              n.ownerDocument.getSelection()),
            (this._root = n)
          )
        }
      }
    }
    return e || document
  }

  updateRoot () {
    this._root = null
  }

  posAtCoords (e) {
    return _R(this, e)
  }

  coordsAtPos (e, n = 1) {
    return Z0(this, e, n)
  }

  domAtPos (e, n = 0) {
    return this.docView.domFromPos(e, n)
  }

  nodeDOM (e) {
    const n = this.docView.descAt(e)
    return n ? n.nodeDOM : null
  }

  posAtDOM (e, n, r = -1) {
    const i = this.docView.posFromDOM(e, n, r)
    if (i == null) {
      throw new RangeError('DOM position not inside the editor')
    }
    return i
  }

  endOfTextblock (e, n) {
    return MR(this, n || this.state, e)
  }

  pasteHTML (e, n) {
    return Qs(this, '', e, !1, n || new ClipboardEvent('paste'))
  }

  pasteText (e, n) {
    return Qs(this, e, null, !0, n || new ClipboardEvent('paste'))
  }

  destroy () {
    this.docView &&
            (QR(this),
            this.destroyPluginViews(),
            this.mounted
              ? (this.docView.update(this.state.doc, [], Tf(this), this),
                (this.dom.textContent = ''))
              : this.dom.parentNode &&
                  this.dom.parentNode.removeChild(this.dom),
            this.docView.destroy(),
            (this.docView = null),
            oR())
  }

  get isDestroyed () {
    return this.docView == null
  }

  dispatchEvent (e) {
    return tI(this, e)
  }

  dispatch (e) {
    const n = this._props.dispatchTransaction
    n ? n.call(this, e) : this.updateState(this.state.apply(e))
  }

  domSelectionRange () {
    const e = this.domSelection()
    return e
      ? (pn &&
                  this.root.nodeType === 11 &&
                  uR(this.dom.ownerDocument) == this.dom &&
                  vI(this, e)) ||
                  e
      : {
          focusNode: null,
          focusOffset: 0,
          anchorNode: null,
          anchorOffset: 0
        }
  }

  domSelection () {
    return this.root.getSelection()
  }
}
function $0 (t) {
  const e = Object.create(null)
  return (
    (e.class = 'ProseMirror'),
    (e.contenteditable = String(t.editable)),
    t.someProp('attributes', (n) => {
      if ((typeof n === 'function' && (n = n(t.state)), n)) {
        for (const r in n) {
          r == 'class'
            ? (e.class += ' ' + n[r])
            : r == 'style'
              ? (e.style = (e.style ? e.style + ';' : '') + n[r])
              : !e[r] &&
                            r != 'contenteditable' &&
                            r != 'nodeName' &&
                            (e[r] = String(n[r]))
        }
      }
    }),
    e.translate || (e.translate = 'no'),
    [wt.node(0, t.state.doc.content.size, e)]
  )
}
function z0 (t) {
  if (t.markCursor) {
    const e = document.createElement('img');
    (e.className = 'ProseMirror-separator'),
    e.setAttribute('mark-placeholder', 'true'),
    e.setAttribute('alt', ''),
    (t.cursorWrapper = {
      dom: e,
      deco: wt.widget(t.state.selection.from, e, {
        raw: !0,
        marks: t.markCursor
      })
    })
  } else t.cursorWrapper = null
}
function U0 (t) {
  return !t.someProp('editable', (e) => e(t.state) === !1)
}
function NI (t, e) {
  const n = Math.min(
    t.$anchor.sharedDepth(t.head),
    e.$anchor.sharedDepth(e.head)
  )
  return t.$anchor.start(n) != e.$anchor.start(n)
}
function W0 (t) {
  const e = Object.create(null)
  function n (r) {
    for (const i in r) {
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i])
    }
  }
  return t.someProp('nodeViews', n), t.someProp('markViews', n), e
}
function kI (t, e) {
  let n = 0
  let r = 0
  for (const i in t) {
    if (t[i] != e[i]) return !0
    n++
  }
  for (const i in e) r++
  return n != r
}
function K0 (t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction) {
    throw new RangeError(
      'Plugins passed directly to the view must not have a state component'
    )
  }
}
const $r = {
  8: 'Backspace',
  9: 'Tab',
  10: 'Enter',
  12: 'NumLock',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  44: 'PrintScreen',
  45: 'Insert',
  46: 'Delete',
  59: ';',
  61: '=',
  91: 'Meta',
  92: 'Meta',
  106: '*',
  107: '+',
  108: ',',
  109: '-',
  110: '.',
  111: '/',
  144: 'NumLock',
  145: 'ScrollLock',
  160: 'Shift',
  161: 'Shift',
  162: 'Control',
  163: 'Control',
  164: 'Alt',
  165: 'Alt',
  173: '-',
  186: ';',
  187: '=',
  188: ',',
  189: '-',
  190: '.',
  191: '/',
  192: '`',
  219: '[',
  220: '\\',
  221: ']',
  222: "'"
}
const Zl = {
  48: ')',
  49: '!',
  50: '@',
  51: '#',
  52: '$',
  53: '%',
  54: '^',
  55: '&',
  56: '*',
  57: '(',
  59: ':',
  61: '+',
  173: '_',
  186: ':',
  187: '+',
  188: '<',
  189: '_',
  190: '>',
  191: '?',
  192: '~',
  219: '{',
  220: '|',
  221: '}',
  222: '"'
}
const OI = typeof navigator < 'u' && /Mac/.test(navigator.platform)
const RI =
    typeof navigator < 'u' &&
    /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
for (At = 0; At < 10; At++) $r[48 + At] = $r[96 + At] = String(At)
var At
for (At = 1; At <= 24; At++) $r[At + 111] = 'F' + At
var At
for (At = 65; At <= 90; At++) {
  ($r[At] = String.fromCharCode(At + 32)), (Zl[At] = String.fromCharCode(At))
}
var At
for (Xl in $r) Zl.hasOwnProperty(Xl) || (Zl[Xl] = $r[Xl])
let Xl
function xE (t) {
  const e =
        (OI && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
        (RI && t.shiftKey && t.key && t.key.length == 1) ||
        t.key == 'Unidentified'
  let n =
        (!e && t.key) ||
        (t.shiftKey ? Zl : $r)[t.keyCode] ||
        t.key ||
        'Unidentified'
  return (
    n == 'Esc' && (n = 'Escape'),
    n == 'Del' && (n = 'Delete'),
    n == 'Left' && (n = 'ArrowLeft'),
    n == 'Up' && (n = 'ArrowUp'),
    n == 'Right' && (n = 'ArrowRight'),
    n == 'Down' && (n = 'ArrowDown'),
    n
  )
}
const II =
    typeof navigator < 'u' ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1
function DI (t) {
  const e = t.split(/-(?!$)/)
  let n = e[e.length - 1]
  n == 'Space' && (n = ' ')
  let r, i, o, s
  for (let l = 0; l < e.length - 1; l++) {
    const u = e[l]
    if (/^(cmd|meta|m)$/i.test(u)) s = !0
    else if (/^a(lt)?$/i.test(u)) r = !0
    else if (/^(c|ctrl|control)$/i.test(u)) i = !0
    else if (/^s(hift)?$/i.test(u)) o = !0
    else if (/^mod$/i.test(u)) II ? (s = !0) : (i = !0)
    else throw new Error('Unrecognized modifier name: ' + u)
  }
  return (
    r && (n = 'Alt-' + n),
    i && (n = 'Ctrl-' + n),
    s && (n = 'Meta-' + n),
    o && (n = 'Shift-' + n),
    n
  )
}
function LI (t) {
  const e = Object.create(null)
  for (const n in t) e[DI(n)] = t[n]
  return e
}
function jf (t, e, n = !0) {
  return (
    e.altKey && (t = 'Alt-' + t),
    e.ctrlKey && (t = 'Ctrl-' + t),
    e.metaKey && (t = 'Meta-' + t),
    n && e.shiftKey && (t = 'Shift-' + t),
    t
  )
}
function _E (t) {
  return new Oe({ props: { handleKeyDown: ra(t) } })
}
function ra (t) {
  const e = LI(t)
  return function (n, r) {
    const i = xE(r)
    let o
    const s = e[jf(i, r)]
    if (s && s(n.state, n.dispatch, n)) return !0
    if (i.length == 1 && i != ' ') {
      if (r.shiftKey) {
        const l = e[jf(i, r, !1)]
        if (l && l(n.state, n.dispatch, n)) return !0
      }
      if (
        (r.shiftKey ||
                    r.altKey ||
                    r.metaKey ||
                    i.charCodeAt(0) > 127) &&
                (o = $r[r.keyCode]) &&
                o != i
      ) {
        const l = e[jf(o, r)]
        if (l && l(n.state, n.dispatch, n)) return !0
      }
    }
    return !1
  }
}
const jl = (t, e) =>
  t.selection.empty
    ? !1
    : (e && e(t.tr.deleteSelection().scrollIntoView()), !0)
function TE (t, e) {
  const { $cursor: n } = t.selection
  return !n || (e ? !e.endOfTextblock('backward', t) : n.parentOffset > 0)
    ? null
    : n
}
const ep = (t, e, n) => {
  const r = TE(t, n)
  if (!r) return !1
  const i = np(r)
  if (!i) {
    const s = r.blockRange()
    const l = s && Lr(s)
    return l == null ? !1 : (e && e(t.tr.lift(s, l).scrollIntoView()), !0)
  }
  const o = i.nodeBefore
  if (DE(t, i, e, -1)) return !0
  if (r.parent.content.size == 0 && (qo(o, 'end') || he.isSelectable(o))) {
    for (let s = r.depth; ; s--) {
      const l = Gs(t.doc, r.before(s), r.after(s), Z.empty)
      if (l && l.slice.size < l.to - l.from) {
        if (e) {
          const u = t.tr.step(l)
          u.setSelection(
            qo(o, 'end')
              ? ue.findFrom(
                u.doc.resolve(u.mapping.map(i.pos, -1)),
                -1
              )
              : he.create(u.doc, i.pos - o.nodeSize)
          ),
          e(u.scrollIntoView())
        }
        return !0
      }
      if (s == 1 || r.node(s - 1).childCount > 1) break
    }
  }
  return o.isAtom && i.depth == r.depth - 1
    ? (e && e(t.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0)
    : !1
}
const CE = (t, e, n) => {
  const r = TE(t, n)
  if (!r) return !1
  const i = np(r)
  return i ? ME(t, i, e) : !1
}
const AE = (t, e, n) => {
  const r = NE(t, n)
  if (!r) return !1
  const i = op(r)
  return i ? ME(t, i, e) : !1
}
function ME (t, e, n) {
  const r = e.nodeBefore
  let i = r
  let o = e.pos - 1
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating) return !1
    const f = i.lastChild
    if (!f) return !1
    i = f
  }
  const s = e.nodeAfter
  let l = s
  let u = e.pos + 1
  for (; !l.isTextblock; u++) {
    if (l.type.spec.isolating) return !1
    const f = l.firstChild
    if (!f) return !1
    l = f
  }
  const d = Gs(t.doc, o, u, Z.empty)
  if (!d || d.from != o || (d instanceof tn && d.slice.size >= u - o)) {
    return !1
  }
  if (n) {
    const f = t.tr.step(d)
    f.setSelection(le.create(f.doc, o)), n(f.scrollIntoView())
  }
  return !0
}
function qo (t, e, n = !1) {
  for (let r = t; r; r = e == 'start' ? r.firstChild : r.lastChild) {
    if (r.isTextblock) return !0
    if (n && r.childCount != 1) return !1
  }
  return !1
}
const tp = (t, e, n) => {
  const { $head: r, empty: i } = t.selection
  let o = r
  if (!i) return !1
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock('backward', t) : r.parentOffset > 0) {
      return !1
    }
    o = np(r)
  }
  const s = o && o.nodeBefore
  return !s || !he.isSelectable(s)
    ? !1
    : (e &&
              e(
                t.tr
                  .setSelection(he.create(t.doc, o.pos - s.nodeSize))
                  .scrollIntoView()
              ),
      !0)
}
function np (t) {
  if (!t.parent.type.spec.isolating) {
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1))
      if (t.node(e).type.spec.isolating) break
    }
  }
  return null
}
function NE (t, e) {
  const { $cursor: n } = t.selection
  return !n ||
        (e
          ? !e.endOfTextblock('forward', t)
          : n.parentOffset < n.parent.content.size)
    ? null
    : n
}
const rp = (t, e, n) => {
  const r = NE(t, n)
  if (!r) return !1
  const i = op(r)
  if (!i) return !1
  const o = i.nodeAfter
  if (DE(t, i, e, 1)) return !0
  if (r.parent.content.size == 0 && (qo(o, 'start') || he.isSelectable(o))) {
    const s = Gs(t.doc, r.before(), r.after(), Z.empty)
    if (s && s.slice.size < s.to - s.from) {
      if (e) {
        const l = t.tr.step(s)
        l.setSelection(
          qo(o, 'start')
            ? ue.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1)
            : he.create(l.doc, l.mapping.map(i.pos))
        ),
        e(l.scrollIntoView())
      }
      return !0
    }
  }
  return o.isAtom && i.depth == r.depth - 1
    ? (e && e(t.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0)
    : !1
}
const ip = (t, e, n) => {
  const { $head: r, empty: i } = t.selection
  let o = r
  if (!i) return !1
  if (r.parent.isTextblock) {
    if (
      n
        ? !n.endOfTextblock('forward', t)
        : r.parentOffset < r.parent.content.size
    ) {
      return !1
    }
    o = op(r)
  }
  const s = o && o.nodeAfter
  return !s || !he.isSelectable(s)
    ? !1
    : (e && e(t.tr.setSelection(he.create(t.doc, o.pos)).scrollIntoView()),
      !0)
}
function op (t) {
  if (!t.parent.type.spec.isolating) {
    for (let e = t.depth - 1; e >= 0; e--) {
      const n = t.node(e)
      if (t.index(e) + 1 < n.childCount) {
        return t.doc.resolve(t.after(e + 1))
      }
      if (n.type.spec.isolating) break
    }
  }
  return null
}
const kE = (t, e) => {
  const n = t.selection
  const r = n instanceof he
  let i
  if (r) {
    if (n.node.isTextblock || !rr(t.doc, n.from)) return !1
    i = n.from
  } else if (((i = Fo(t.doc, n.from, -1)), i == null)) return !1
  if (e) {
    const o = t.tr.join(i)
    r &&
            o.setSelection(
              he.create(o.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)
            ),
    e(o.scrollIntoView())
  }
  return !0
}
const OE = (t, e) => {
  const n = t.selection
  let r
  if (n instanceof he) {
    if (n.node.isTextblock || !rr(t.doc, n.to)) return !1
    r = n.to
  } else if (((r = Fo(t.doc, n.to, 1)), r == null)) return !1
  return e && e(t.tr.join(r).scrollIntoView()), !0
}
const RE = (t, e) => {
  const { $from: n, $to: r } = t.selection
  const i = n.blockRange(r)
  const o = i && Lr(i)
  return o == null ? !1 : (e && e(t.tr.lift(i, o).scrollIntoView()), !0)
}
const sp = (t, e) => {
  const { $head: n, $anchor: r } = t.selection
  return !n.parent.type.spec.code || !n.sameParent(r)
    ? !1
    : (e &&
              e(
                t.tr
                  .insertText(
                          `
`
                  )
                  .scrollIntoView()
              ),
      !0)
}
function ap (t) {
  for (let e = 0; e < t.edgeCount; e++) {
    const { type: n } = t.edge(e)
    if (n.isTextblock && !n.hasRequiredAttrs()) return n
  }
  return null
}
const lp = (t, e) => {
  const { $head: n, $anchor: r } = t.selection
  if (!n.parent.type.spec.code || !n.sameParent(r)) return !1
  const i = n.node(-1)
  const o = n.indexAfter(-1)
  const s = ap(i.contentMatchAt(o))
  if (!s || !i.canReplaceWith(o, o, s)) return !1
  if (e) {
    const l = n.after()
    const u = t.tr.replaceWith(l, l, s.createAndFill())
    u.setSelection(ue.near(u.doc.resolve(l), 1)), e(u.scrollIntoView())
  }
  return !0
}
const cp = (t, e) => {
  const n = t.selection
  const { $from: r, $to: i } = n
  if (n instanceof fn || r.parent.inlineContent || i.parent.inlineContent) {
    return !1
  }
  const o = ap(i.parent.contentMatchAt(i.indexAfter()))
  if (!o || !o.isTextblock) return !1
  if (e) {
    const s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i)
      .pos
    const l = t.tr.insert(s, o.createAndFill())
    l.setSelection(le.create(l.doc, s + 1)), e(l.scrollIntoView())
  }
  return !0
}
const up = (t, e) => {
  const { $cursor: n } = t.selection
  if (!n || n.parent.content.size) return !1
  if (n.depth > 1 && n.after() != n.end(-1)) {
    const o = n.before()
    if (zn(t.doc, o)) return e && e(t.tr.split(o).scrollIntoView()), !0
  }
  const r = n.blockRange()
  const i = r && Lr(r)
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0)
}
function PI (t) {
  return (e, n) => {
    const { $from: r, $to: i } = e.selection
    if (e.selection instanceof he && e.selection.node.isBlock) {
      return !r.parentOffset || !zn(e.doc, r.pos)
        ? !1
        : (n && n(e.tr.split(r.pos).scrollIntoView()), !0)
    }
    if (!r.depth) return !1
    const o = []
    let s
    let l
    let u = !1
    let d = !1
    for (let b = r.depth; ; b--) {
      if (r.node(b).isBlock) {
        (u = r.end(b) == r.pos + (r.depth - b)),
        (d = r.start(b) == r.pos - (r.depth - b)),
        (l = ap(r.node(b - 1).contentMatchAt(r.indexAfter(b - 1))))
        const E = t && t(i.parent, u, r)
        o.unshift(E || (u && l ? { type: l } : null)), (s = b)
        break
      } else {
        if (b == 1) return !1
        o.unshift(null)
      }
    }
    const f = e.tr;
    (e.selection instanceof le || e.selection instanceof fn) &&
            f.deleteSelection()
    const h = f.mapping.map(r.pos)
    let m = zn(f.doc, h, o.length, o)
    if (
      (m ||
                ((o[0] = l ? { type: l } : null),
                (m = zn(f.doc, h, o.length, o))),
      f.split(h, o.length, o),
      !u && d && r.node(s).type != l)
    ) {
      const b = f.mapping.map(r.before(s))
      const g = f.doc.resolve(b)
      l &&
                r.node(s - 1).canReplaceWith(g.index(), g.index() + 1, l) &&
                f.setNodeMarkup(f.mapping.map(r.before(s)), l)
    }
    return n && n(f.scrollIntoView()), !0
  }
}
const BI = PI()
const IE = (t, e) => {
  const { $from: n, to: r } = t.selection
  let i
  const o = n.sharedDepth(r)
  return o == 0
    ? !1
    : ((i = n.before(o)),
      e && e(t.tr.setSelection(he.create(t.doc, i))),
      !0)
}
const FI = (t, e) => (e && e(t.tr.setSelection(new fn(t.doc))), !0)
function HI (t, e, n) {
  const r = e.nodeBefore
  const i = e.nodeAfter
  const o = e.index()
  return !r || !i || !r.type.compatibleContent(i.type)
    ? !1
    : !r.content.size && e.parent.canReplace(o - 1, o)
        ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()),
          !0)
        : !e.parent.canReplace(o, o + 1) ||
              !(i.isTextblock || rr(t.doc, e.pos))
            ? !1
            : (n && n(t.tr.join(e.pos).scrollIntoView()), !0)
}
function DE (t, e, n, r) {
  const i = e.nodeBefore
  const o = e.nodeAfter
  let s
  let l
  const u = i.type.spec.isolating || o.type.spec.isolating
  if (!u && HI(t, e, n)) return !0
  const d = !u && e.parent.canReplace(e.index(), e.index() + 1)
  if (
    d &&
        (s = (l = i.contentMatchAt(i.childCount)).findWrapping(o.type)) &&
        l.matchType(s[0] || o.type).validEnd
  ) {
    if (n) {
      const b = e.pos + o.nodeSize
      let g = K.empty
      for (let S = s.length - 1; S >= 0; S--) {
        g = K.from(s[S].create(null, g))
      }
      g = K.from(i.copy(g))
      const E = t.tr.step(
        new Ct(e.pos - 1, b, e.pos, b, new Z(g, 1, 0), s.length, !0)
      )
      const w = E.doc.resolve(b + 2 * s.length)
      w.nodeAfter &&
                w.nodeAfter.type == i.type &&
                rr(E.doc, w.pos) &&
                E.join(w.pos),
      n(E.scrollIntoView())
    }
    return !0
  }
  const f = o.type.spec.isolating || (r > 0 && u) ? null : ue.findFrom(e, 1)
  const h = f && f.$from.blockRange(f.$to)
  const m = h && Lr(h)
  if (m != null && m >= e.depth) {
    return n && n(t.tr.lift(h, m).scrollIntoView()), !0
  }
  if (d && qo(o, 'start', !0) && qo(i, 'end')) {
    let b = i
    const g = []
    for (; g.push(b), !b.isTextblock;) b = b.lastChild
    let E = o
    let w = 1
    for (; !E.isTextblock; E = E.firstChild) w++
    if (b.canReplace(b.childCount, b.childCount, E.content)) {
      if (n) {
        let S = K.empty
        for (let k = g.length - 1; k >= 0; k--) {
          S = K.from(g[k].copy(S))
        }
        const O = t.tr.step(
          new Ct(
            e.pos - g.length,
            e.pos + o.nodeSize,
            e.pos + w,
            e.pos + o.nodeSize - w,
            new Z(S, g.length, 0),
            0,
            !0
          )
        )
        n(O.scrollIntoView())
      }
      return !0
    }
  }
  return !1
}
function LE (t) {
  return function (e, n) {
    const r = e.selection
    const i = t < 0 ? r.$from : r.$to
    let o = i.depth
    for (; i.node(o).isInline;) {
      if (!o) return !1
      o--
    }
    return i.node(o).isTextblock
      ? (n &&
                  n(
                    e.tr.setSelection(
                      le.create(e.doc, t < 0 ? i.start(o) : i.end(o))
                    )
                  ),
        !0)
      : !1
  }
}
const dp = LE(-1)
const fp = LE(1)
function PE (t, e = null) {
  return function (n, r) {
    const { $from: i, $to: o } = n.selection
    const s = i.blockRange(o)
    const l = s && Bo(s, t, e)
    return l ? (r && r(n.tr.wrap(s, l).scrollIntoView()), !0) : !1
  }
}
function pp (t, e = null) {
  return function (n, r) {
    let i = !1
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      const {
        $from: { pos: s },
        $to: { pos: l }
      } = n.selection.ranges[o]
      n.doc.nodesBetween(s, l, (u, d) => {
        if (i) return !1
        if (!(!u.isTextblock || u.hasMarkup(t, e))) {
          if (u.type == t) i = !0
          else {
            const f = n.doc.resolve(d)
            const h = f.index()
            i = f.parent.canReplaceWith(h, h + 1, t)
          }
        }
      })
    }
    if (!i) return !1
    if (r) {
      const o = n.tr
      for (let s = 0; s < n.selection.ranges.length; s++) {
        const {
          $from: { pos: l },
          $to: { pos: u }
        } = n.selection.ranges[s]
        o.setBlockType(l, u, t, e)
      }
      r(o.scrollIntoView())
    }
    return !0
  }
}
function hp (...t) {
  return function (e, n, r) {
    for (let i = 0; i < t.length; i++) if (t[i](e, n, r)) return !0
    return !1
  }
}
const Qf = hp(jl, ep, tp)
const SE = hp(jl, rp, ip)
const bi = {
  Enter: hp(sp, cp, up, BI),
  'Mod-Enter': lp,
  Backspace: Qf,
  'Mod-Backspace': Qf,
  'Shift-Backspace': Qf,
  Delete: SE,
  'Mod-Delete': SE,
  'Mod-a': FI
}
const $I = {
  'Ctrl-h': bi.Backspace,
  'Alt-Backspace': bi['Mod-Backspace'],
  'Ctrl-d': bi.Delete,
  'Ctrl-Alt-Backspace': bi['Mod-Delete'],
  'Alt-Delete': bi['Mod-Delete'],
  'Alt-d': bi['Mod-Delete'],
  'Ctrl-a': dp,
  'Ctrl-e': fp
}
for (const t in bi) $I[t] = bi[t]
const P$ =
    typeof navigator < 'u'
      ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
      : typeof os < 'u' && os.platform
        ? os.platform() == 'darwin'
        : !1
function BE (t, e = null) {
  return function (n, r) {
    const { $from: i, $to: o } = n.selection
    const s = i.blockRange(o)
    if (!s) return !1
    const l = r ? n.tr : null
    return zI(l, s, t, e) ? (r && r(l.scrollIntoView()), !0) : !1
  }
}
function zI (t, e, n, r = null) {
  let i = !1
  let o = e
  const s = e.$from.doc
  if (
    e.depth >= 2 &&
        e.$from.node(e.depth - 1).type.compatibleContent(n) &&
        e.startIndex == 0
  ) {
    if (e.$from.index(e.depth - 1) == 0) return !1
    const u = s.resolve(e.start - 2);
    (o = new Ui(u, u, e.depth)),
    e.endIndex < e.parent.childCount &&
                (e = new Ui(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)),
    (i = !0)
  }
  const l = Bo(o, n, r, e)
  return l ? (t && UI(t, e, l, i, n), !0) : !1
}
function UI (t, e, n, r, i) {
  let o = K.empty
  for (let f = n.length - 1; f >= 0; f--) {
    o = K.from(n[f].type.create(n[f].attrs, o))
  }
  t.step(
    new Ct(
      e.start - (r ? 2 : 0),
      e.end,
      e.start,
      e.end,
      new Z(o, 0, 0),
      n.length,
      !0
    )
  )
  let s = 0
  for (let f = 0; f < n.length; f++) n[f].type == i && (s = f + 1)
  const l = n.length - s
  let u = e.start + n.length - (r ? 2 : 0)
  const d = e.parent
  for (let f = e.startIndex, h = e.endIndex, m = !0; f < h; f++, m = !1) {
    !m && zn(t.doc, u, l) && (t.split(u, l), (u += 2 * l)),
    (u += d.child(f).nodeSize)
  }
  return t
}
function FE (t) {
  return function (e, n) {
    const { $from: r, $to: i } = e.selection
    const o = r.blockRange(
      i,
      (s) => s.childCount > 0 && s.firstChild.type == t
    )
    return o
      ? n
        ? r.node(o.depth - 1).type == t
          ? WI(e, n, t, o)
          : KI(e, n, o)
        : !0
      : !1
  }
}
function WI (t, e, n, r) {
  const i = t.tr
  const o = r.end
  const s = r.$to.end(r.depth)
  o < s &&
        (i.step(
          new Ct(
            o - 1,
            s,
            o,
            s,
            new Z(K.from(n.create(null, r.parent.copy())), 1, 0),
            1,
            !0
          )
        ),
        (r = new Ui(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth)))
  const l = Lr(r)
  if (l == null) return !1
  i.lift(r, l)
  const u = i.mapping.map(o, -1) - 1
  return rr(i.doc, u) && i.join(u), e(i.scrollIntoView()), !0
}
function KI (t, e, n) {
  const r = t.tr
  const i = n.parent
  for (let b = n.end, g = n.endIndex - 1, E = n.startIndex; g > E; g--) {
    (b -= i.child(g).nodeSize), r.delete(b - 1, b + 1)
  }
  const o = r.doc.resolve(n.start)
  const s = o.nodeAfter
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize) return !1
  const l = n.startIndex == 0
  const u = n.endIndex == i.childCount
  const d = o.node(-1)
  const f = o.index(-1)
  if (
    !d.canReplace(
      f + (l ? 0 : 1),
      f + 1,
      s.content.append(u ? K.empty : K.from(i))
    )
  ) {
    return !1
  }
  const h = o.pos
  const m = h + s.nodeSize
  return (
    r.step(
      new Ct(
        h - (l ? 1 : 0),
        m + (u ? 1 : 0),
        h + 1,
        m - 1,
        new Z(
          (l ? K.empty : K.from(i.copy(K.empty))).append(
            u ? K.empty : K.from(i.copy(K.empty))
          ),
          l ? 0 : 1,
          u ? 0 : 1
        ),
        l ? 0 : 1
      )
    ),
    e(r.scrollIntoView()),
    !0
  )
}
function HE (t) {
  return function (e, n) {
    const { $from: r, $to: i } = e.selection
    const o = r.blockRange(
      i,
      (d) => d.childCount > 0 && d.firstChild.type == t
    )
    if (!o) return !1
    const s = o.startIndex
    if (s == 0) return !1
    const l = o.parent
    const u = l.child(s - 1)
    if (u.type != t) return !1
    if (n) {
      const d = u.lastChild && u.lastChild.type == l.type
      const f = K.from(d ? t.create() : null)
      const h = new Z(
        K.from(t.create(null, K.from(l.type.create(null, f)))),
        d ? 3 : 1,
        0
      )
      const m = o.start
      const b = o.end
      n(
        e.tr
          .step(new Ct(m - (d ? 3 : 1), b, m, b, h, 1, !0))
          .scrollIntoView()
      )
    }
    return !0
  }
}
function ac (t) {
  const { state: e, transaction: n } = t
  let { selection: r } = n
  let { doc: i } = n
  let { storedMarks: o } = n
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks () {
      return o
    },
    get selection () {
      return r
    },
    get doc () {
      return i
    },
    get tr () {
      return (r = n.selection), (i = n.doc), (o = n.storedMarks), n
    }
  }
}
const Yo = class {
  constructor (e) {
    (this.editor = e.editor),
    (this.rawCommands = this.editor.extensionManager.commands),
    (this.customState = e.state)
  }

  get hasCustomState () {
    return !!this.customState
  }

  get state () {
    return this.customState || this.editor.state
  }

  get commands () {
    const { rawCommands: e, editor: n, state: r } = this
    const { view: i } = n
    const { tr: o } = r
    const s = this.buildProps(o)
    return Object.fromEntries(
      Object.entries(e).map(([l, u]) => [
        l,
        (...f) => {
          const h = u(...f)(s)
          return (
            !o.getMeta('preventDispatch') &&
                            !this.hasCustomState &&
                            i.dispatch(o),
            h
          )
        }
      ])
    )
  }

  get chain () {
    return () => this.createChain()
  }

  get can () {
    return () => this.createCan()
  }

  createChain (e, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this
    const { view: s } = i
    const l = []
    const u = !!e
    const d = e || o.tr
    const f = () => (
      !u &&
                n &&
                !d.getMeta('preventDispatch') &&
                !this.hasCustomState &&
                s.dispatch(d),
      l.every((m) => m === !0)
    )
    const h = {
      ...Object.fromEntries(
        Object.entries(r).map(([m, b]) => [
          m,
          (...E) => {
            const w = this.buildProps(d, n)
            const S = b(...E)(w)
            return l.push(S), h
          }
        ])
      ),
      run: f
    }
    return h
  }

  createCan (e) {
    const { rawCommands: n, state: r } = this
    const i = !1
    const o = e || r.tr
    const s = this.buildProps(o, i)
    return {
      ...Object.fromEntries(
        Object.entries(n).map(([u, d]) => [
          u,
          (...f) => d(...f)({ ...s, dispatch: void 0 })
        ])
      ),
      chain: () => this.createChain(o, i)
    }
  }

  buildProps (e, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this
    const { view: s } = i
    const l = {
      tr: e,
      editor: i,
      view: s,
      state: ac({ state: o, transaction: e }),
      dispatch: n ? () => {} : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands () {
        return Object.fromEntries(
          Object.entries(r).map(([u, d]) => [
            u,
            (...f) => d(...f)(l)
          ])
        )
      }
    }
    return l
  }
}
const yp = class {
  constructor () {
    this.callbacks = {}
  }

  on (e, n) {
    return (
      this.callbacks[e] || (this.callbacks[e] = []),
      this.callbacks[e].push(n),
      this
    )
  }

  emit (e, ...n) {
    const r = this.callbacks[e]
    return r && r.forEach((i) => i.apply(this, n)), this
  }

  off (e, n) {
    const r = this.callbacks[e]
    return (
      r &&
                (n
                  ? (this.callbacks[e] = r.filter((i) => i !== n))
                  : delete this.callbacks[e]),
      this
    )
  }

  once (e, n) {
    const r = (...i) => {
      this.off(e, r), n.apply(this, i)
    }
    return this.on(e, r)
  }

  removeAllListeners () {
    this.callbacks = {}
  }
}
function re (t, e, n) {
  return t.config[e] === void 0 && t.parent
    ? re(t.parent, e, n)
    : typeof t.config[e] === 'function'
      ? t.config[e].bind({
        ...n,
        parent: t.parent ? re(t.parent, e, n) : null
      })
      : t.config[e]
}
function lc (t) {
  const e = t.filter((i) => i.type === 'extension')
  const n = t.filter((i) => i.type === 'node')
  const r = t.filter((i) => i.type === 'mark')
  return { baseExtensions: e, nodeExtensions: n, markExtensions: r }
}
function qE (t) {
  const e = []
  const { nodeExtensions: n, markExtensions: r } = lc(t)
  const i = [...n, ...r]
  const o = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  }
  return (
    t.forEach((s) => {
      const l = {
        name: s.name,
        options: s.options,
        storage: s.storage,
        extensions: i
      }
      const u = re(s, 'addGlobalAttributes', l)
      if (!u) return
      u().forEach((f) => {
        f.types.forEach((h) => {
          Object.entries(f.attributes).forEach(([m, b]) => {
            e.push({ type: h, name: m, attribute: { ...o, ...b } })
          })
        })
      })
    }),
    i.forEach((s) => {
      const l = { name: s.name, options: s.options, storage: s.storage }
      const u = re(s, 'addAttributes', l)
      if (!u) return
      const d = u()
      Object.entries(d).forEach(([f, h]) => {
        const m = { ...o, ...h }
        typeof m?.default === 'function' && (m.default = m.default()),
        m?.isRequired && m?.default === void 0 && delete m.default,
        e.push({ type: s.name, name: f, attribute: m })
      })
    }),
    e
  )
}
function Ut (t, e) {
  if (typeof t === 'string') {
    if (!e.nodes[t]) {
      throw Error(
                `There is no node type named '${t}'. Maybe you forgot to add the extension?`
      )
    }
    return e.nodes[t]
  }
  return t
}
function ee (...t) {
  return t
    .filter((e) => !!e)
    .reduce((e, n) => {
      const r = { ...e }
      return (
        Object.entries(n).forEach(([i, o]) => {
          if (!r[i]) {
            r[i] = o
            return
          }
          if (i === 'class') {
            const l = o ? String(o).split(' ') : []
            const u = r[i] ? r[i].split(' ') : []
            const d = l.filter((f) => !u.includes(f))
            r[i] = [...u, ...d].join(' ')
          } else if (i === 'style') {
            const l = o
              ? o
                .split(';')
                .map((f) => f.trim())
                .filter(Boolean)
              : []
            const u = r[i]
              ? r[i]
                .split(';')
                .map((f) => f.trim())
                .filter(Boolean)
              : []
            const d = new Map()
            u.forEach((f) => {
              const [h, m] = f.split(':').map((b) => b.trim())
              d.set(h, m)
            }),
            l.forEach((f) => {
              const [h, m] = f
                .split(':')
                .map((b) => b.trim())
              d.set(h, m)
            }),
            (r[i] = Array.from(d.entries())
              .map(([f, h]) => `${f}: ${h}`)
              .join('; '))
          } else r[i] = o
        }),
        r
      )
    }, {})
}
function Ep (t, e) {
  return e
    .filter((n) => n.type === t.type.name)
    .filter((n) => n.attribute.rendered)
    .map((n) =>
      n.attribute.renderHTML
        ? n.attribute.renderHTML(t.attrs) || {}
        : { [n.name]: t.attrs[n.name] }
    )
    .reduce((n, r) => ee(n, r), {})
}
function YE (t) {
  return typeof t === 'function'
}
function Te (t, e = void 0, ...n) {
  return YE(t) ? (e ? t.bind(e)(...n) : t(...n)) : t
}
function VI (t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object
}
function GI (t) {
  return typeof t !== 'string'
    ? t
    : t.match(/^[+-]?(?:\d*\.)?\d+$/)
      ? Number(t)
      : t === 'true'
        ? !0
        : t === 'false'
          ? !1
          : t
}
function $E (t, e) {
  return 'style' in t
    ? t
    : {
        ...t,
        getAttrs: (n) => {
          const r = t.getAttrs ? t.getAttrs(n) : t.attrs
          if (r === !1) return !1
          const i = e.reduce((o, s) => {
            const l = s.attribute.parseHTML
              ? s.attribute.parseHTML(n)
              : GI(n.getAttribute(s.name))
            return l == null ? o : { ...o, [s.name]: l }
          }, {})
          return { ...r, ...i }
        }
      }
}
function zE (t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) =>
      e === 'attrs' && VI(n) ? !1 : n != null
    )
  )
}
function qI (t, e) {
  let n
  const r = qE(t)
  const { nodeExtensions: i, markExtensions: o } = lc(t)
  const s =
        (n = i.find((d) => re(d, 'topNode'))) === null || n === void 0
          ? void 0
          : n.name
  const l = Object.fromEntries(
    i.map((d) => {
      const f = r.filter((S) => S.type === d.name)
      const h = {
        name: d.name,
        options: d.options,
        storage: d.storage,
        editor: e
      }
      const m = t.reduce((S, O) => {
        const k = re(O, 'extendNodeSchema', h)
        return { ...S, ...(k ? k(d) : {}) }
      }, {})
      const b = zE({
        ...m,
        content: Te(re(d, 'content', h)),
        marks: Te(re(d, 'marks', h)),
        group: Te(re(d, 'group', h)),
        inline: Te(re(d, 'inline', h)),
        atom: Te(re(d, 'atom', h)),
        selectable: Te(re(d, 'selectable', h)),
        draggable: Te(re(d, 'draggable', h)),
        code: Te(re(d, 'code', h)),
        whitespace: Te(re(d, 'whitespace', h)),
        linebreakReplacement: Te(re(d, 'linebreakReplacement', h)),
        defining: Te(re(d, 'defining', h)),
        isolating: Te(re(d, 'isolating', h)),
        attrs: Object.fromEntries(
          f.map((S) => {
            let O
            return [
              S.name,
              {
                default:
                                    (O = S?.attribute) === null || O === void 0
                                      ? void 0
                                      : O.default
              }
            ]
          })
        )
      })
      const g = Te(re(d, 'parseHTML', h))
      g && (b.parseDOM = g.map((S) => $E(S, f)))
      const E = re(d, 'renderHTML', h)
      E && (b.toDOM = (S) => E({ node: S, HTMLAttributes: Ep(S, f) }))
      const w = re(d, 'renderText', h)
      return w && (b.toText = w), [d.name, b]
    })
  )
  const u = Object.fromEntries(
    o.map((d) => {
      const f = r.filter((w) => w.type === d.name)
      const h = {
        name: d.name,
        options: d.options,
        storage: d.storage,
        editor: e
      }
      const m = t.reduce((w, S) => {
        const O = re(S, 'extendMarkSchema', h)
        return { ...w, ...(O ? O(d) : {}) }
      }, {})
      const b = zE({
        ...m,
        inclusive: Te(re(d, 'inclusive', h)),
        excludes: Te(re(d, 'excludes', h)),
        group: Te(re(d, 'group', h)),
        spanning: Te(re(d, 'spanning', h)),
        code: Te(re(d, 'code', h)),
        attrs: Object.fromEntries(
          f.map((w) => {
            let S
            return [
              w.name,
              {
                default:
                                    (S = w?.attribute) === null || S === void 0
                                      ? void 0
                                      : S.default
              }
            ]
          })
        )
      })
      const g = Te(re(d, 'parseHTML', h))
      g && (b.parseDOM = g.map((w) => $E(w, f)))
      const E = re(d, 'renderHTML', h)
      return (
        E &&
                    (b.toDOM = (w) => E({ mark: w, HTMLAttributes: Ep(w, f) })),
        [d.name, b]
      )
    })
  )
  return new Bs({ topNode: s, nodes: l, marks: u })
}
function mp (t, e) {
  return e.nodes[t] || e.marks[t] || null
}
function UE (t, e) {
  return Array.isArray(e)
    ? e.some((n) => (typeof n === 'string' ? n : n.name) === t.name)
    : e
}
function Tp (t, e) {
  const n = Ir.fromSchema(e).serializeFragment(t)
  const i = document.implementation.createHTMLDocument().createElement('div')
  return i.appendChild(n), i.innerHTML
}
const YI = (t, e = 500) => {
  let n = ''
  const r = t.parentOffset
  return (
    t.parent.nodesBetween(Math.max(0, r - e), r, (i, o, s, l) => {
      let u, d
      const f =
                ((d = (u = i.type.spec).toText) === null || d === void 0
                  ? void 0
                  : d.call(u, { node: i, pos: o, parent: s, index: l })) ||
                i.textContent ||
                '%leaf%'
      n += i.isAtom && !i.isText ? f : f.slice(0, Math.max(0, r - o))
    }),
    n
  )
}
function Cp (t) {
  return Object.prototype.toString.call(t) === '[object RegExp]'
}
const Jo = class {
  constructor (e) {
    (this.find = e.find), (this.handler = e.handler)
  }
}
const JI = (t, e) => {
  if (Cp(e)) return e.exec(t)
  const n = e(t)
  if (!n) return null
  const r = [n.text]
  return (
    (r.index = n.index),
    (r.input = t),
    (r.data = n.data),
    n.replaceWith &&
            (n.text.includes(n.replaceWith) ||
                console.warn(
                  '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
                ),
            r.push(n.replaceWith)),
    r
  )
}
function Ql (t) {
  let e
  const { editor: n, from: r, to: i, text: o, rules: s, plugin: l } = t
  const { view: u } = n
  if (u.composing) return !1
  const d = u.state.doc.resolve(r)
  if (
    d.parent.type.spec.code ||
        (!((e = d.nodeBefore || d.nodeAfter) === null || e === void 0) &&
            e.marks.find((m) => m.type.spec.code))
  ) {
    return !1
  }
  let f = !1
  const h = YI(d) + o
  return (
    s.forEach((m) => {
      if (f) return
      const b = JI(h, m.find)
      if (!b) return
      const g = u.state.tr
      const E = ac({ state: u.state, transaction: g })
      const w = { from: r - (b[0].length - o.length), to: i }
      const {
        commands: S,
        chain: O,
        can: k
      } = new Yo({ editor: n, state: E })
      m.handler({
        state: E,
        range: w,
        match: b,
        commands: S,
        chain: O,
        can: k
      }) === null ||
                !g.steps.length ||
                (g.setMeta(l, { transform: g, from: r, to: i, text: o }),
                u.dispatch(g),
                (f = !0))
    }),
    f
  )
}
function XI (t) {
  const { editor: e, rules: n } = t
  const r = new Oe({
    state: {
      init () {
        return null
      },
      apply (i, o, s) {
        const l = i.getMeta(r)
        if (l) return l
        const u = i.getMeta('applyInputRules')
        return (
          !!u &&
                        setTimeout(() => {
                          let { text: f } = u
                          typeof f === 'string'
                            ? (f = f)
                            : (f = Tp(K.from(f), s.schema))
                          const { from: h } = u
                          const m = h + f.length
                          Ql({
                            editor: e,
                            from: h,
                            to: m,
                            text: f,
                            rules: n,
                            plugin: r
                          })
                        }),
          i.selectionSet || i.docChanged ? null : o
        )
      }
    },
    props: {
      handleTextInput (i, o, s, l) {
        return Ql({
          editor: e,
          from: o,
          to: s,
          text: l,
          rules: n,
          plugin: r
        })
      },
      handleDOMEvents: {
        compositionend: (i) => (
          setTimeout(() => {
            const { $cursor: o } = i.state.selection
            o &&
                            Ql({
                              editor: e,
                              from: o.pos,
                              to: o.pos,
                              text: '',
                              rules: n,
                              plugin: r
                            })
          }),
          !1
        )
      },
      handleKeyDown (i, o) {
        if (o.key !== 'Enter') return !1
        const { $cursor: s } = i.state.selection
        return s
          ? Ql({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: `
`,
            rules: n,
            plugin: r
          })
          : !1
      }
    },
    isInputRules: !0
  })
  return r
}
function ZI (t) {
  return Object.prototype.toString.call(t).slice(8, -1)
}
function ec (t) {
  return ZI(t) !== 'Object'
    ? !1
    : t.constructor === Object &&
              Object.getPrototypeOf(t) === Object.prototype
}
function cc (t, e) {
  const n = { ...t }
  return (
    ec(t) &&
            ec(e) &&
            Object.keys(e).forEach((r) => {
              ec(e[r]) && ec(t[r]) ? (n[r] = cc(t[r], e[r])) : (n[r] = e[r])
            }),
    n
  )
}
const st = class t {
  constructor (e = {}) {
    (this.type = 'mark'),
    (this.name = 'mark'),
    (this.parent = null),
    (this.child = null),
    (this.config = { name: this.name, defaultOptions: {} }),
    (this.config = { ...this.config, ...e }),
    (this.name = this.config.name),
    e.defaultOptions &&
                Object.keys(e.defaultOptions).length > 0 &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
                ),
    (this.options = this.config.defaultOptions),
    this.config.addOptions &&
                (this.options = Te(
                  re(this, 'addOptions', { name: this.name })
                )),
    (this.storage =
                Te(
                  re(this, 'addStorage', {
                    name: this.name,
                    options: this.options
                  })
                ) || {})
  }

  static create (e = {}) {
    return new t(e)
  }

  configure (e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => cc(this.options, e)
    })
    return (n.name = this.name), (n.parent = this.parent), n
  }

  extend (e = {}) {
    const n = new t(e)
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
                Object.keys(e.defaultOptions).length > 0 &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
                ),
      (n.options = Te(re(n, 'addOptions', { name: n.name }))),
      (n.storage = Te(
        re(n, 'addStorage', { name: n.name, options: n.options })
      )),
      n
    )
  }

  static handleExit ({ editor: e, mark: n }) {
    const { tr: r } = e.state
    const i = e.state.selection.$from
    if (i.pos === i.end()) {
      const s = i.marks()
      if (!s.find((d) => d?.type.name === n.name)) return !1
      const u = s.find((d) => d?.type.name === n.name)
      return (
        u && r.removeStoredMark(u),
        r.insertText(' ', i.pos),
        e.view.dispatch(r),
        !0
      )
    }
    return !1
  }
}
function jI (t) {
  return typeof t === 'number'
}
const vp = class {
  constructor (e) {
    (this.find = e.find), (this.handler = e.handler)
  }
}
const QI = (t, e, n) => {
  if (Cp(e)) return [...t.matchAll(e)]
  const r = e(t, n)
  return r
    ? r.map((i) => {
      const o = [i.text]
      return (
        (o.index = i.index),
        (o.input = t),
        (o.data = i.data),
        i.replaceWith &&
                      (i.text.includes(i.replaceWith) ||
                          console.warn(
                            '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
                          ),
                      o.push(i.replaceWith)),
        o
      )
    })
    : []
}
function eD (t) {
  const {
    editor: e,
    state: n,
    from: r,
    to: i,
    rule: o,
    pasteEvent: s,
    dropEvent: l
  } = t
  const { commands: u, chain: d, can: f } = new Yo({ editor: e, state: n })
  const h = []
  return (
    n.doc.nodesBetween(r, i, (b, g) => {
      if (!b.isTextblock || b.type.spec.code) return
      const E = Math.max(r, g)
      const w = Math.min(i, g + b.content.size)
      const S = b.textBetween(E - g, w - g, void 0, '\uFFFC')
      QI(S, o.find, s).forEach((k) => {
        if (k.index === void 0) return
        const T = E + k.index + 1
        const P = T + k[0].length
        const I = {
          from: n.tr.mapping.map(T),
          to: n.tr.mapping.map(P)
        }
        const Y = o.handler({
          state: n,
          range: I,
          match: k,
          commands: u,
          chain: d,
          can: f,
          pasteEvent: s,
          dropEvent: l
        })
        h.push(Y)
      })
    }),
    h.every((b) => b !== null)
  )
}
let tc = null
const tD = (t) => {
  let e
  const n = new ClipboardEvent('paste', {
    clipboardData: new DataTransfer()
  })
  return (
    (e = n.clipboardData) === null ||
            e === void 0 ||
            e.setData('text/html', t),
    n
  )
}
function nD (t) {
  const { editor: e, rules: n } = t
  let r = null
  let i = !1
  let o = !1
  let s = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null
  let l
  try {
    l = typeof DragEvent < 'u' ? new DragEvent('drop') : null
  } catch {
    l = null
  }
  const u = ({ state: f, from: h, to: m, rule: b, pasteEvt: g }) => {
    const E = f.tr
    const w = ac({ state: f, transaction: E })
    if (
      !(
        !eD({
          editor: e,
          state: w,
          from: Math.max(h - 1, 0),
          to: m.b - 1,
          rule: b,
          pasteEvent: g,
          dropEvent: l
        }) || !E.steps.length
      )
    ) {
      try {
        l = typeof DragEvent < 'u' ? new DragEvent('drop') : null
      } catch {
        l = null
      }
      return (
        (s =
                    typeof ClipboardEvent < 'u'
                      ? new ClipboardEvent('paste')
                      : null),
        E
      )
    }
  }
  return n.map(
    (f) =>
      new Oe({
        view (h) {
          const m = (g) => {
            let E;
            (r =
                            !(
                              (E = h.dom.parentElement) === null ||
                                E === void 0
                            ) && E.contains(g.target)
                              ? h.dom.parentElement
                              : null),
            r && (tc = e)
          }
          const b = () => {
            tc && (tc = null)
          }
          return (
            window.addEventListener('dragstart', m),
            window.addEventListener('dragend', b),
            {
              destroy () {
                window.removeEventListener('dragstart', m),
                window.removeEventListener('dragend', b)
              }
            }
          )
        },
        props: {
          handleDOMEvents: {
            drop: (h, m) => {
              if (
                ((o = r === h.dom.parentElement), (l = m), !o)
              ) {
                const b = tc
                b &&
                                    setTimeout(() => {
                                      const g = b.state.selection
                                      g &&
                                            b.commands.deleteRange({
                                              from: g.from,
                                              to: g.to
                                            })
                                    }, 10)
              }
              return !1
            },
            paste: (h, m) => {
              let b
              const g =
                                (b = m.clipboardData) === null || b === void 0
                                  ? void 0
                                  : b.getData('text/html')
              return (
                (s = m),
                (i = !!g?.includes('data-pm-slice')),
                !1
              )
            }
          }
        },
        appendTransaction: (h, m, b) => {
          const g = h[0]
          const E = g.getMeta('uiEvent') === 'paste' && !i
          const w = g.getMeta('uiEvent') === 'drop' && !o
          const S = g.getMeta('applyPasteRules')
          const O = !!S
          if (!E && !w && !O) return
          if (O) {
            let { text: P } = S
            typeof P === 'string'
              ? (P = P)
              : (P = Tp(K.from(P), b.schema))
            const { from: I } = S
            const Y = I + P.length
            const ne = tD(P)
            return u({
              rule: f,
              state: b,
              from: I,
              to: { b: Y },
              pasteEvt: ne
            })
          }
          const k = m.doc.content.findDiffStart(b.doc.content)
          const T = m.doc.content.findDiffEnd(b.doc.content)
          if (!(!jI(k) || !T || k === T.b)) {
            return u({
              rule: f,
              state: b,
              from: k,
              to: T,
              pasteEvt: s
            })
          }
        }
      })
  )
}
function rD (t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r)
  return Array.from(new Set(e))
}
const wp = class t {
  constructor (e, n) {
    (this.splittableMarks = []),
    (this.editor = n),
    (this.extensions = t.resolve(e)),
    (this.schema = qI(this.extensions, n)),
    this.setupExtensions()
  }

  static resolve (e) {
    const n = t.sort(t.flatten(e))
    const r = rD(n.map((i) => i.name))
    return (
      r.length &&
                console.warn(
                    `[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(', ')}]. This can lead to issues.`
                ),
      n
    )
  }

  static flatten (e) {
    return e
      .map((n) => {
        const r = {
          name: n.name,
          options: n.options,
          storage: n.storage
        }
        const i = re(n, 'addExtensions', r)
        return i ? [n, ...this.flatten(i())] : n
      })
      .flat(10)
  }

  static sort (e) {
    return e.sort((r, i) => {
      const o = re(r, 'priority') || 100
      const s = re(i, 'priority') || 100
      return o > s ? -1 : o < s ? 1 : 0
    })
  }

  get commands () {
    return this.extensions.reduce((e, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: mp(n.name, this.schema)
      }
      const i = re(n, 'addCommands', r)
      return i ? { ...e, ...i() } : e
    }, {})
  }

  get plugins () {
    const { editor: e } = this
    const n = t.sort([...this.extensions].reverse())
    const r = []
    const i = []
    const o = n
      .map((s) => {
        const l = {
          name: s.name,
          options: s.options,
          storage: s.storage,
          editor: e,
          type: mp(s.name, this.schema)
        }
        const u = []
        const d = re(s, 'addKeyboardShortcuts', l)
        let f = {}
        if (
          (s.type === 'mark' &&
                        re(s, 'exitable', l) &&
                        (f.ArrowRight = () =>
                          st.handleExit({ editor: e, mark: s })),
          d)
        ) {
          const E = Object.fromEntries(
            Object.entries(d()).map(([w, S]) => [
              w,
              () => S({ editor: e })
            ])
          )
          f = { ...f, ...E }
        }
        const h = _E(f)
        u.push(h)
        const m = re(s, 'addInputRules', l)
        UE(s, e.options.enableInputRules) && m && r.push(...m())
        const b = re(s, 'addPasteRules', l)
        UE(s, e.options.enablePasteRules) && b && i.push(...b())
        const g = re(s, 'addProseMirrorPlugins', l)
        if (g) {
          const E = g()
          u.push(...E)
        }
        return u
      })
      .flat()
    return [
      XI({ editor: e, rules: r }),
      ...nD({ editor: e, rules: i }),
      ...o
    ]
  }

  get attributes () {
    return qE(this.extensions)
  }

  get nodeViews () {
    const { editor: e } = this
    const { nodeExtensions: n } = lc(this.extensions)
    return Object.fromEntries(
      n
        .filter((r) => !!re(r, 'addNodeView'))
        .map((r) => {
          const i = this.attributes.filter((u) => u.type === r.name)
          const o = {
            name: r.name,
            options: r.options,
            storage: r.storage,
            editor: e,
            type: Ut(r.name, this.schema)
          }
          const s = re(r, 'addNodeView', o)
          if (!s) return []
          const l = (u, d, f, h, m) => {
            const b = Ep(u, i)
            return s()({
              node: u,
              view: d,
              getPos: f,
              decorations: h,
              innerDecorations: m,
              editor: e,
              extension: r,
              HTMLAttributes: b
            })
          }
          return [r.name, l]
        })
    )
  }

  setupExtensions () {
    this.extensions.forEach((e) => {
      let n
      this.editor.extensionStorage[e.name] = e.storage
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: mp(e.name, this.schema)
      }
      e.type === 'mark' &&
                (!(
                  (n = Te(re(e, 'keepOnSplit', r))) !== null && n !== void 0
                ) ||
                    n) &&
                this.splittableMarks.push(e.name)
      const i = re(e, 'onBeforeCreate', r)
      const o = re(e, 'onCreate', r)
      const s = re(e, 'onUpdate', r)
      const l = re(e, 'onSelectionUpdate', r)
      const u = re(e, 'onTransaction', r)
      const d = re(e, 'onFocus', r)
      const f = re(e, 'onBlur', r)
      const h = re(e, 'onDestroy', r)
      i && this.editor.on('beforeCreate', i),
      o && this.editor.on('create', o),
      s && this.editor.on('update', s),
      l && this.editor.on('selectionUpdate', l),
      u && this.editor.on('transaction', u),
      d && this.editor.on('focus', d),
      f && this.editor.on('blur', f),
      h && this.editor.on('destroy', h)
    })
  }
}
const We = class t {
  constructor (e = {}) {
    (this.type = 'extension'),
    (this.name = 'extension'),
    (this.parent = null),
    (this.child = null),
    (this.config = { name: this.name, defaultOptions: {} }),
    (this.config = { ...this.config, ...e }),
    (this.name = this.config.name),
    e.defaultOptions &&
                Object.keys(e.defaultOptions).length > 0 &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
                ),
    (this.options = this.config.defaultOptions),
    this.config.addOptions &&
                (this.options = Te(
                  re(this, 'addOptions', { name: this.name })
                )),
    (this.storage =
                Te(
                  re(this, 'addStorage', {
                    name: this.name,
                    options: this.options
                  })
                ) || {})
  }

  static create (e = {}) {
    return new t(e)
  }

  configure (e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => cc(this.options, e)
    })
    return (n.name = this.name), (n.parent = this.parent), n
  }

  extend (e = {}) {
    const n = new t({ ...this.config, ...e })
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
                Object.keys(e.defaultOptions).length > 0 &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
                ),
      (n.options = Te(re(n, 'addOptions', { name: n.name }))),
      (n.storage = Te(
        re(n, 'addStorage', { name: n.name, options: n.options })
      )),
      n
    )
  }
}
function JE (t, e, n) {
  const { from: r, to: i } = e
  const {
    blockSeparator: o = `

`,
    textSerializers: s = {}
  } = n || {}
  let l = ''
  return (
    t.nodesBetween(r, i, (u, d, f, h) => {
      let m
      u.isBlock && d > r && (l += o)
      const b = s?.[u.type.name]
      if (b) {
        return (
          f &&
                        (l += b({
                          node: u,
                          pos: d,
                          parent: f,
                          index: h,
                          range: e
                        })),
          !1
        )
      }
      u.isText &&
                (l +=
                    (m = u?.text) === null || m === void 0
                      ? void 0
                      : m.slice(Math.max(r, d) - d, i - d))
    }),
    l
  )
}
function uc (t) {
  return Object.fromEntries(
    Object.entries(t.nodes)
      .filter(([, e]) => e.spec.toText)
      .map(([e, n]) => [e, n.spec.toText])
  )
}
const iD = We.create({
  name: 'clipboardTextSerializer',
  addOptions () {
    return { blockSeparator: void 0 }
  },
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('clipboardTextSerializer'),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this
            const { state: e, schema: n } = t
            const { doc: r, selection: i } = e
            const { ranges: o } = i
            const s = Math.min(...o.map((f) => f.$from.pos))
            const l = Math.max(...o.map((f) => f.$to.pos))
            const u = uc(n)
            return JE(
              r,
              { from: s, to: l },
              {
                ...(this.options.blockSeparator !== void 0
                  ? {
                      blockSeparator:
                                              this.options.blockSeparator
                    }
                  : {}),
                textSerializers: u
              }
            )
          }
        }
      })
    ]
  }
})
const oD =
    () =>
      ({ editor: t, view: e }) => (
        requestAnimationFrame(() => {
          let n
          t.isDestroyed ||
                (e.dom.blur(),
                (n = window?.getSelection()) === null ||
                    n === void 0 ||
                    n.removeAllRanges())
        }),
        !0
      )
const sD =
    (t = !1) =>
      ({ commands: e }) =>
        e.setContent('', t)
const aD =
    () =>
      ({ state: t, tr: e, dispatch: n }) => {
        const { selection: r } = e
        const { ranges: i } = r
        return (
          n &&
                i.forEach(({ $from: o, $to: s }) => {
                  t.doc.nodesBetween(o.pos, s.pos, (l, u) => {
                    if (l.type.isText) return
                    const { doc: d, mapping: f } = e
                    const h = d.resolve(f.map(u))
                    const m = d.resolve(f.map(u + l.nodeSize))
                    const b = h.blockRange(m)
                    if (!b) return
                    const g = Lr(b)
                    if (l.type.isTextblock) {
                      const { defaultType: E } = h.parent.contentMatchAt(
                        h.index()
                      )
                      e.setNodeMarkup(b.start, E)
                    }
                    (g || g === 0) && e.lift(b, g)
                  })
                }),
          !0
        )
      }
const lD = (t) => (e) => t(e)
const cD =
    () =>
      ({ state: t, dispatch: e }) =>
        cp(t, e)
const uD =
    (t, e) =>
      ({ editor: n, tr: r }) => {
        const { state: i } = n
        const o = i.doc.slice(t.from, t.to)
        r.deleteRange(t.from, t.to)
        const s = r.mapping.map(e)
        return (
          r.insert(s, o.content),
          r.setSelection(new le(r.doc.resolve(s - 1))),
          !0
        )
      }
const dD =
    () =>
      ({ tr: t, dispatch: e }) => {
        const { selection: n } = t
        const r = n.$anchor.node()
        if (r.content.size > 0) return !1
        const i = t.selection.$anchor
        for (let o = i.depth; o > 0; o -= 1) {
          if (i.node(o).type === r.type) {
            if (e) {
              const l = i.before(o)
              const u = i.after(o)
              t.delete(l, u).scrollIntoView()
            }
            return !0
          }
        }
        return !1
      }
const fD =
    (t) =>
      ({ tr: e, state: n, dispatch: r }) => {
        const i = Ut(t, n.schema)
        const o = e.selection.$anchor
        for (let s = o.depth; s > 0; s -= 1) {
          if (o.node(s).type === i) {
            if (r) {
              const u = o.before(s)
              const d = o.after(s)
              e.delete(u, d).scrollIntoView()
            }
            return !0
          }
        }
        return !1
      }
const pD =
    (t) =>
      ({ tr: e, dispatch: n }) => {
        const { from: r, to: i } = t
        return n && e.delete(r, i), !0
      }
const hD =
    () =>
      ({ state: t, dispatch: e }) =>
        jl(t, e)
const mD =
    () =>
      ({ commands: t }) =>
        t.keyboardShortcut('Enter')
const gD =
    () =>
      ({ state: t, dispatch: e }) =>
        lp(t, e)
function ic (t, e, n = { strict: !0 }) {
  const r = Object.keys(e)
  return r.length
    ? r.every((i) =>
      n.strict
        ? e[i] === t[i]
        : Cp(e[i])
          ? e[i].test(t[i])
          : e[i] === t[i]
    )
    : !0
}
function XE (t, e, n = {}) {
  return t.find(
    (r) =>
      r.type === e &&
            ic(
              Object.fromEntries(Object.keys(n).map((i) => [i, r.attrs[i]])),
              n
            )
  )
}
function WE (t, e, n = {}) {
  return !!XE(t, e, n)
}
function Ap (t, e, n) {
  let r
  if (!t || !e) return
  let i = t.parent.childAfter(t.parentOffset)
  if (
    ((!i.node || !i.node.marks.some((f) => f.type === e)) &&
            (i = t.parent.childBefore(t.parentOffset)),
    !i.node ||
            !i.node.marks.some((f) => f.type === e) ||
            ((n =
                n ||
                ((r = i.node.marks[0]) === null || r === void 0
                  ? void 0
                  : r.attrs)),
            !XE([...i.node.marks], e, n)))
  ) {
    return
  }
  let s = i.index
  let l = t.start() + i.offset
  let u = s + 1
  let d = l + i.node.nodeSize
  for (; s > 0 && WE([...t.parent.child(s - 1).marks], e, n);) {
    (s -= 1), (l -= t.parent.child(s).nodeSize)
  }
  for (
    ;
    u < t.parent.childCount && WE([...t.parent.child(u).marks], e, n);

  ) {
    (d += t.parent.child(u).nodeSize), (u += 1)
  }
  return { from: l, to: d }
}
function yi (t, e) {
  if (typeof t === 'string') {
    if (!e.marks[t]) {
      throw Error(
                `There is no mark type named '${t}'. Maybe you forgot to add the extension?`
      )
    }
    return e.marks[t]
  }
  return t
}
const bD =
    (t, e = {}) =>
      ({ tr: n, state: r, dispatch: i }) => {
        const o = yi(t, r.schema)
        const { doc: s, selection: l } = n
        const { $from: u, from: d, to: f } = l
        if (i) {
          const h = Ap(u, o, e)
          if (h && h.from <= d && h.to >= f) {
            const m = le.create(s, h.from, h.to)
            n.setSelection(m)
          }
        }
        return !0
      }
const yD = (t) => (e) => {
  const n = typeof t === 'function' ? t(e) : t
  for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0
  return !1
}
function dc (t) {
  return t instanceof le
}
function zr (t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n)
}
function ZE (t, e = null) {
  if (!e) return null
  const n = ue.atStart(t)
  const r = ue.atEnd(t)
  if (e === 'start' || e === !0) return n
  if (e === 'end') return r
  const i = n.from
  const o = r.to
  return e === 'all'
    ? le.create(t, zr(0, i, o), zr(t.content.size, i, o))
    : le.create(t, zr(e, i, o), zr(e, i, o))
}
const ED =
    (t = null, e = {}) =>
      ({ editor: n, view: r, tr: i, dispatch: o }) => {
        e = { scrollIntoView: !0, ...e }
        const s = () => {
          r.dom.focus(),
          requestAnimationFrame(() => {
            n.isDestroyed ||
                        (r.focus(),
                        e?.scrollIntoView && n.commands.scrollIntoView())
          })
        }
        if ((r.hasFocus() && t === null) || t === !1) return !0
        if (o && t === null && !dc(n.state.selection)) return s(), !0
        const l = ZE(i.doc, t) || n.state.selection
        const u = n.state.selection.eq(l)
        return (
          o &&
                (u || i.setSelection(l),
                u && i.storedMarks && i.setStoredMarks(i.storedMarks),
                s()),
          !0
        )
      }
const vD = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i }))
const wD =
    (t, e) =>
      ({ tr: n, commands: r }) =>
        r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e)
const jE = (t) => {
  const e = t.childNodes
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const r = e[n]
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
      ? t.removeChild(r)
      : r.nodeType === 1 && jE(r)
  }
  return t
}
function nc (t) {
  const e = `<body>${t}</body>`
  const n = new window.DOMParser().parseFromString(e, 'text/html').body
  return jE(n)
}
function oc (t, e, n) {
  if (t instanceof $n || t instanceof K) return t
  n = { slice: !0, parseOptions: {}, ...n }
  const r = typeof t === 'object' && t !== null
  const i = typeof t === 'string'
  if (r) {
    try {
      if (Array.isArray(t) && t.length > 0) {
        return K.fromArray(t.map((l) => e.nodeFromJSON(l)))
      }
      const s = e.nodeFromJSON(t)
      return n.errorOnInvalidContent && s.check(), s
    } catch (o) {
      if (n.errorOnInvalidContent) {
        throw new Error('[tiptap error]: Invalid JSON content', {
          cause: o
        })
      }
      return (
        console.warn(
          '[tiptap warn]: Invalid content.',
          'Passed value:',
          t,
          'Error:',
          o
        ),
        oc('', e, n)
      )
    }
  }
  if (i) {
    if (n.errorOnInvalidContent) {
      let s = !1
      let l = ''
      const u = new Bs({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: 'inline*',
            group: 'block',
            parseDOM: [
              {
                tag: '*',
                getAttrs: (d) => (
                  (s = !0),
                  (l =
                                        typeof d === 'string'
                                          ? d
                                          : d.outerHTML),
                  null
                )
              }
            ]
          }
        })
      })
      if (
        (n.slice
          ? Rr.fromSchema(u).parseSlice(nc(t), n.parseOptions)
          : Rr.fromSchema(u).parse(nc(t), n.parseOptions),
        n.errorOnInvalidContent && s)
      ) {
        throw new Error('[tiptap error]: Invalid HTML content', {
          cause: new Error(`Invalid element found: ${l}`)
        })
      }
    }
    const o = Rr.fromSchema(e)
    return n.slice
      ? o.parseSlice(nc(t), n.parseOptions).content
      : o.parse(nc(t), n.parseOptions)
  }
  return oc('', e, n)
}
function xD (t, e, n) {
  const r = t.steps.length - 1
  if (r < e) return
  const i = t.steps[r]
  if (!(i instanceof tn || i instanceof Ct)) return
  const o = t.mapping.maps[r]
  let s = 0
  o.forEach((l, u, d, f) => {
    s === 0 && (s = f)
  }),
  t.setSelection(ue.near(t.doc.resolve(s), n))
}
const _D = (t) => !('type' in t)
const SD =
    (t, e, n) =>
      ({ tr: r, dispatch: i, editor: o }) => {
        let s
        if (i) {
          n = {
            parseOptions: o.options.parseOptions,
            updateSelection: !0,
            applyInputRules: !1,
            applyPasteRules: !1,
            ...n
          }
          let l
          try {
            l = oc(e, o.schema, {
              parseOptions: {
                preserveWhitespace: 'full',
                ...n.parseOptions
              },
              errorOnInvalidContent:
                        (s = n.errorOnInvalidContent) !== null && s !== void 0
                          ? s
                          : o.options.enableContentCheck
            })
          } catch (g) {
            return (
              o.emit('contentError', {
                editor: o,
                error: g,
                disableCollaboration: () => {
                  o.storage.collaboration &&
                                (o.storage.collaboration.isDisabled = !0)
                }
              }),
              !1
            )
          }
          let { from: u, to: d } =
                typeof t === 'number'
                  ? { from: t, to: t }
                  : { from: t.from, to: t.to }
          let f = !0
          let h = !0
          if (
            ((_D(l) ? l : [l]).forEach((g) => {
              g.check(),
              (f = f ? g.isText && g.marks.length === 0 : !1),
              (h = h ? g.isBlock : !1)
            }),
            u === d && h)
          ) {
            const { parent: g } = r.doc.resolve(u)
            g.isTextblock &&
                    !g.type.spec.code &&
                    !g.childCount &&
                    ((u -= 1), (d += 1))
          }
          let b
          if (f) {
            if (Array.isArray(e)) {
              b = e.map((g) => g.text || '').join('')
            } else if (e instanceof K) {
              let g = ''
              e.forEach((E) => {
                E.text && (g += E.text)
              }),
              (b = g)
            } else {
              typeof e === 'object' && e && e.text
                ? (b = e.text)
                : (b = e)
            }
            r.insertText(b, u, d)
          } else (b = l), r.replaceWith(u, d, b)
          n.updateSelection && xD(r, r.steps.length - 1, -1),
          n.applyInputRules &&
                    r.setMeta('applyInputRules', { from: u, text: b }),
          n.applyPasteRules &&
                    r.setMeta('applyPasteRules', { from: u, text: b })
        }
        return !0
      }
const TD =
    () =>
      ({ state: t, dispatch: e }) =>
        kE(t, e)
const CD =
    () =>
      ({ state: t, dispatch: e }) =>
        OE(t, e)
const AD =
    () =>
      ({ state: t, dispatch: e }) =>
        ep(t, e)
const MD =
    () =>
      ({ state: t, dispatch: e }) =>
        rp(t, e)
const ND =
    () =>
      ({ state: t, dispatch: e, tr: n }) => {
        try {
          const r = Fo(t.doc, t.selection.$from.pos, -1)
          return r == null ? !1 : (n.join(r, 2), e && e(n), !0)
        } catch {
          return !1
        }
      }
const kD =
    () =>
      ({ state: t, dispatch: e, tr: n }) => {
        try {
          const r = Fo(t.doc, t.selection.$from.pos, 1)
          return r == null ? !1 : (n.join(r, 2), e && e(n), !0)
        } catch {
          return !1
        }
      }
const OD =
    () =>
      ({ state: t, dispatch: e }) =>
        CE(t, e)
const RD =
    () =>
      ({ state: t, dispatch: e }) =>
        AE(t, e)
function QE () {
  return (
    [
      'iPad Simulator',
      'iPhone Simulator',
      'iPod Simulator',
      'iPad',
      'iPhone',
      'iPod'
    ].includes(navigator.platform) ||
        (navigator.userAgent.includes('Mac') && 'ontouchend' in document)
  )
}
function ev () {
  return typeof navigator < 'u' ? /Mac/.test(navigator.platform) : !1
}
function ID (t) {
  const e = t.split(/-(?!$)/)
  let n = e[e.length - 1]
  n === 'Space' && (n = ' ')
  let r, i, o, s
  for (let l = 0; l < e.length - 1; l += 1) {
    const u = e[l]
    if (/^(cmd|meta|m)$/i.test(u)) s = !0
    else if (/^a(lt)?$/i.test(u)) r = !0
    else if (/^(c|ctrl|control)$/i.test(u)) i = !0
    else if (/^s(hift)?$/i.test(u)) o = !0
    else if (/^mod$/i.test(u)) QE() || ev() ? (s = !0) : (i = !0)
    else throw new Error(`Unrecognized modifier name: ${u}`)
  }
  return (
    r && (n = `Alt-${n}`),
    i && (n = `Ctrl-${n}`),
    s && (n = `Meta-${n}`),
    o && (n = `Shift-${n}`),
    n
  )
}
const DD =
    (t) =>
      ({ editor: e, view: n, tr: r, dispatch: i }) => {
        const o = ID(t).split(/-(?!$)/)
        const s = o.find((d) => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(d))
        const l = new KeyboardEvent('keydown', {
          key: s === 'Space' ? ' ' : s,
          altKey: o.includes('Alt'),
          ctrlKey: o.includes('Ctrl'),
          metaKey: o.includes('Meta'),
          shiftKey: o.includes('Shift'),
          bubbles: !0,
          cancelable: !0
        })
        const u = e.captureTransaction(() => {
          n.someProp('handleKeyDown', (d) => d(n, l))
        })
        return (
          u?.steps.forEach((d) => {
            const f = d.map(r.mapping)
            f && i && r.maybeStep(f)
          }),
          !0
        )
      }
function ia (t, e, n = {}) {
  const { from: r, to: i, empty: o } = t.selection
  const s = e ? Ut(e, t.schema) : null
  const l = []
  t.doc.nodesBetween(r, i, (h, m) => {
    if (h.isText) return
    const b = Math.max(r, m)
    const g = Math.min(i, m + h.nodeSize)
    l.push({ node: h, from: b, to: g })
  })
  const u = i - r
  const d = l
    .filter((h) => (s ? s.name === h.node.type.name : !0))
    .filter((h) => ic(h.node.attrs, n, { strict: !1 }))
  return o ? !!d.length : d.reduce((h, m) => h + m.to - m.from, 0) >= u
}
const LD =
    (t, e = {}) =>
      ({ state: n, dispatch: r }) => {
        const i = Ut(t, n.schema)
        return ia(n, i, e) ? RE(n, r) : !1
      }
const PD =
    () =>
      ({ state: t, dispatch: e }) =>
        up(t, e)
const BD =
    (t) =>
      ({ state: e, dispatch: n }) => {
        const r = Ut(t, e.schema)
        return FE(r)(e, n)
      }
const FD =
    () =>
      ({ state: t, dispatch: e }) =>
        sp(t, e)
function fc (t, e) {
  return e.nodes[t] ? 'node' : e.marks[t] ? 'mark' : null
}
function KE (t, e) {
  const n = typeof e === 'string' ? [e] : e
  return Object.keys(t).reduce(
    (r, i) => (n.includes(i) || (r[i] = t[i]), r),
    {}
  )
}
const HD =
    (t, e) =>
      ({ tr: n, state: r, dispatch: i }) => {
        let o = null
        let s = null
        const l = fc(typeof t === 'string' ? t : t.name, r.schema)
        return l
          ? (l === 'node' && (o = Ut(t, r.schema)),
            l === 'mark' && (s = yi(t, r.schema)),
            i &&
                  n.selection.ranges.forEach((u) => {
                    r.doc.nodesBetween(u.$from.pos, u.$to.pos, (d, f) => {
                      o &&
                              o === d.type &&
                              n.setNodeMarkup(f, void 0, KE(d.attrs, e)),
                      s &&
                                  d.marks.length &&
                                  d.marks.forEach((h) => {
                                    s === h.type &&
                                          n.addMark(
                                            f,
                                            f + d.nodeSize,
                                            s.create(KE(h.attrs, e))
                                          )
                                  })
                    })
                  }),
            !0)
          : !1
      }
const $D =
    () =>
      ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0)
const zD =
    () =>
      ({ tr: t, dispatch: e }) => {
        if (e) {
          const n = new fn(t.doc)
          t.setSelection(n)
        }
        return !0
      }
const UD =
    () =>
      ({ state: t, dispatch: e }) =>
        tp(t, e)
const WD =
    () =>
      ({ state: t, dispatch: e }) =>
        ip(t, e)
const KD =
    () =>
      ({ state: t, dispatch: e }) =>
        IE(t, e)
const VD =
    () =>
      ({ state: t, dispatch: e }) =>
        fp(t, e)
const GD =
    () =>
      ({ state: t, dispatch: e }) =>
        dp(t, e)
function xp (t, e, n = {}, r = {}) {
  return oc(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  })
}
const qD =
    (t, e = !1, n = {}, r = {}) =>
      ({ editor: i, tr: o, dispatch: s, commands: l }) => {
        let u, d
        const { doc: f } = o
        if (n.preserveWhitespace !== 'full') {
          const h = xp(t, i.schema, n, {
            errorOnInvalidContent:
                    (u = r.errorOnInvalidContent) !== null && u !== void 0
                      ? u
                      : i.options.enableContentCheck
          })
          return (
            s &&
                    o
                      .replaceWith(0, f.content.size, h)
                      .setMeta('preventUpdate', !e),
            !0
          )
        }
        return (
          s && o.setMeta('preventUpdate', !e),
          l.insertContentAt({ from: 0, to: f.content.size }, t, {
            parseOptions: n,
            errorOnInvalidContent:
                    (d = r.errorOnInvalidContent) !== null && d !== void 0
                      ? d
                      : i.options.enableContentCheck
          })
        )
      }
function tv (t, e) {
  const n = yi(e, t.schema)
  const { from: r, to: i, empty: o } = t.selection
  const s = []
  o
    ? (t.storedMarks && s.push(...t.storedMarks),
      s.push(...t.selection.$head.marks()))
    : t.doc.nodesBetween(r, i, (u) => {
      s.push(...u.marks)
    })
  const l = s.find((u) => u.type.name === n.name)
  return l ? { ...l.attrs } : {}
}
function nv (t, e) {
  const n = new ui(t)
  return (
    e.forEach((r) => {
      r.steps.forEach((i) => {
        n.step(i)
      })
    }),
    n
  )
}
function Mp (t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e)
    if (n.isTextblock && !n.hasRequiredAttrs()) return n
  }
  return null
}
function eo (t, e) {
  const n = []
  return (
    t.descendants((r, i) => {
      e(r) && n.push({ node: r, pos: i })
    }),
    n
  )
}
function rv (t, e, n) {
  const r = []
  return (
    t.nodesBetween(e.from, e.to, (i, o) => {
      n(i) && r.push({ node: i, pos: o })
    }),
    r
  )
}
function Np (t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n)
    if (e(r)) {
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      }
    }
  }
}
function to (t) {
  return (e) => Np(e.$from, t)
}
function kp (t, e) {
  const n = { from: 0, to: t.content.size }
  return JE(t, n, e)
}
function YD (t, e) {
  const n = Ut(e, t.schema)
  const { from: r, to: i } = t.selection
  const o = []
  t.doc.nodesBetween(r, i, (l) => {
    o.push(l)
  })
  const s = o.reverse().find((l) => l.type.name === n.name)
  return s ? { ...s.attrs } : {}
}
function Op (t, e) {
  const n = fc(typeof e === 'string' ? e : e.name, t.schema)
  return n === 'node' ? YD(t, e) : n === 'mark' ? tv(t, e) : {}
}
function JD (t, e = JSON.stringify) {
  const n = {}
  return t.filter((r) => {
    const i = e(r)
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : (n[i] = !0)
  })
}
function XD (t) {
  const e = JD(t)
  return e.length === 1
    ? e
    : e.filter(
      (n, r) =>
        !e
          .filter((o, s) => s !== r)
          .some(
            (o) =>
              n.oldRange.from >= o.oldRange.from &&
                              n.oldRange.to <= o.oldRange.to &&
                              n.newRange.from >= o.newRange.from &&
                              n.newRange.to <= o.newRange.to
          )
    )
}
function iv (t) {
  const { mapping: e, steps: n } = t
  const r = []
  return (
    e.maps.forEach((i, o) => {
      const s = []
      if (i.ranges.length) {
        i.forEach((l, u) => {
          s.push({ from: l, to: u })
        })
      } else {
        const { from: l, to: u } = n[o]
        if (l === void 0 || u === void 0) return
        s.push({ from: l, to: u })
      }
      s.forEach(({ from: l, to: u }) => {
        const d = e.slice(o).map(l, -1)
        const f = e.slice(o).map(u)
        const h = e.invert().map(d, -1)
        const m = e.invert().map(f)
        r.push({
          oldRange: { from: h, to: m },
          newRange: { from: d, to: f }
        })
      })
    }),
    XD(r)
  )
}
function pc (t, e, n) {
  const r = []
  return (
    t === e
      ? n
        .resolve(t)
        .marks()
        .forEach((i) => {
          const o = n.resolve(t)
          const s = Ap(o, i.type)
          s && r.push({ mark: i, ...s })
        })
      : n.nodesBetween(t, e, (i, o) => {
        !i ||
                      i?.nodeSize === void 0 ||
                      r.push(
                        ...i.marks.map((s) => ({
                          from: o,
                          to: o + i.nodeSize,
                          mark: s
                        }))
                      )
      }),
    r
  )
}
function rc (t, e, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const i = t.find((o) => o.type === e && o.name === r)
      return i ? i.attribute.keepOnSplit : !1
    })
  )
}
function _p (t, e, n = {}) {
  const { empty: r, ranges: i } = t.selection
  const o = e ? yi(e, t.schema) : null
  if (r) {
    return !!(t.storedMarks || t.selection.$from.marks())
      .filter((h) => (o ? o.name === h.type.name : !0))
      .find((h) => ic(h.attrs, n, { strict: !1 }))
  }
  let s = 0
  const l = []
  if (
    (i.forEach(({ $from: h, $to: m }) => {
      const b = h.pos
      const g = m.pos
      t.doc.nodesBetween(b, g, (E, w) => {
        if (!E.isText && !E.marks.length) return
        const S = Math.max(b, w)
        const O = Math.min(g, w + E.nodeSize)
        const k = O - S;
        (s += k),
        l.push(
          ...E.marks.map((T) => ({ mark: T, from: S, to: O }))
        )
      })
    }),
    s === 0)
  ) {
    return !1
  }
  const u = l
    .filter((h) => (o ? o.name === h.mark.type.name : !0))
    .filter((h) => ic(h.mark.attrs, n, { strict: !1 }))
    .reduce((h, m) => h + m.to - m.from, 0)
  const d = l
    .filter((h) => (o ? h.mark.type !== o && h.mark.type.excludes(o) : !0))
    .reduce((h, m) => h + m.to - m.from, 0)
  return (u > 0 ? u + d : u) >= s
}
function Ur (t, e, n = {}) {
  if (!e) return ia(t, null, n) || _p(t, null, n)
  const r = fc(e, t.schema)
  return r === 'node' ? ia(t, e, n) : r === 'mark' ? _p(t, e, n) : !1
}
function VE (t, e) {
  const { nodeExtensions: n } = lc(e)
  const r = n.find((s) => s.name === t)
  if (!r) return !1
  const i = { name: r.name, options: r.options, storage: r.storage }
  const o = Te(re(r, 'group', i))
  return typeof o !== 'string' ? !1 : o.split(' ').includes('list')
}
function oa (t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  let r
  if (n) {
    if (t.type.name === 'hardBreak') return !0
    if (t.isText) {
      return /^\s*$/m.test(
        (r = t.text) !== null && r !== void 0 ? r : ''
      )
    }
  }
  if (t.isText) return !t.text
  if (t.isAtom || t.isLeaf) return !1
  if (t.content.childCount === 0) return !0
  if (e) {
    let i = !0
    return (
      t.content.forEach((o) => {
        i !== !1 &&
                    (oa(o, { ignoreWhitespace: n, checkChildren: e }) ||
                        (i = !1))
      }),
      i
    )
  }
  return !1
}
function hc (t) {
  return t instanceof he
}
function mc (t, e, n) {
  const i = t.state.doc.content.size
  const o = zr(e, 0, i)
  const s = zr(n, 0, i)
  const l = t.coordsAtPos(o)
  const u = t.coordsAtPos(s, -1)
  const d = Math.min(l.top, u.top)
  const f = Math.max(l.bottom, u.bottom)
  const h = Math.min(l.left, u.left)
  const m = Math.max(l.right, u.right)
  const b = m - h
  const g = f - d
  const S = {
    top: d,
    bottom: f,
    left: h,
    right: m,
    width: b,
    height: g,
    x: h,
    y: d
  }
  return { ...S, toJSON: () => S }
}
function ZD (t, e, n) {
  let r
  const { selection: i } = e
  let o = null
  if ((dc(i) && (o = i.$cursor), o)) {
    const l = (r = t.storedMarks) !== null && r !== void 0 ? r : o.marks()
    return !!n.isInSet(l) || !l.some((u) => u.type.excludes(n))
  }
  const { ranges: s } = i
  return s.some(({ $from: l, $to: u }) => {
    let d =
            l.depth === 0
              ? t.doc.inlineContent && t.doc.type.allowsMarkType(n)
              : !1
    return (
      t.doc.nodesBetween(l.pos, u.pos, (f, h, m) => {
        if (d) return !1
        if (f.isInline) {
          const b = !m || m.type.allowsMarkType(n)
          const g =
                        !!n.isInSet(f.marks) ||
                        !f.marks.some((E) => E.type.excludes(n))
          d = b && g
        }
        return !d
      }),
      d
    )
  })
}
const jD =
    (t, e = {}) =>
      ({ tr: n, state: r, dispatch: i }) => {
        const { selection: o } = n
        const { empty: s, ranges: l } = o
        const u = yi(t, r.schema)
        if (i) {
          if (s) {
            const d = tv(r, u)
            n.addStoredMark(u.create({ ...d, ...e }))
          } else {
            l.forEach((d) => {
              const f = d.$from.pos
              const h = d.$to.pos
              r.doc.nodesBetween(f, h, (m, b) => {
                const g = Math.max(b, f)
                const E = Math.min(b + m.nodeSize, h)
                m.marks.find((S) => S.type === u)
                  ? m.marks.forEach((S) => {
                    u === S.type &&
                                      n.addMark(
                                        g,
                                        E,
                                        u.create({ ...S.attrs, ...e })
                                      )
                  })
                  : n.addMark(g, E, u.create(e))
              })
            })
          }
        }
        return ZD(r, n, u)
      }
const QD =
    (t, e) =>
      ({ tr: n }) => (n.setMeta(t, e), !0)
const eL =
    (t, e = {}) =>
      ({ state: n, dispatch: r, chain: i }) => {
        const o = Ut(t, n.schema)
        let s
        return (
          n.selection.$anchor.sameParent(n.selection.$head) &&
                (s = n.selection.$anchor.parent.attrs),
          o.isTextblock
            ? i()
              .command(({ commands: l }) =>
                pp(o, { ...s, ...e })(n) ? !0 : l.clearNodes()
              )
              .command(({ state: l }) => pp(o, { ...s, ...e })(l, r))
              .run()
            : (console.warn(
                '[tiptap warn]: Currently "setNode()" only supports text block nodes.'
              ),
              !1)
        )
      }
const tL =
    (t) =>
      ({ tr: e, dispatch: n }) => {
        if (n) {
          const { doc: r } = e
          const i = zr(t, 0, r.content.size)
          const o = he.create(r, i)
          e.setSelection(o)
        }
        return !0
      }
const nL =
    (t) =>
      ({ tr: e, dispatch: n }) => {
        if (n) {
          const { doc: r } = e
          const { from: i, to: o } =
                typeof t === 'number' ? { from: t, to: t } : t
          const s = le.atStart(r).from
          const l = le.atEnd(r).to
          const u = zr(i, s, l)
          const d = zr(o, s, l)
          const f = le.create(r, u, d)
          e.setSelection(f)
        }
        return !0
      }
const rL =
    (t) =>
      ({ state: e, dispatch: n }) => {
        const r = Ut(t, e.schema)
        return HE(r)(e, n)
      }
function GE (t, e) {
  const n =
        t.storedMarks ||
        (t.selection.$to.parentOffset && t.selection.$from.marks())
  if (n) {
    const r = n.filter((i) => e?.includes(i.type.name))
    t.tr.ensureMarks(r)
  }
}
const iL =
    ({ keepMarks: t = !0 } = {}) =>
      ({ tr: e, state: n, dispatch: r, editor: i }) => {
        const { selection: o, doc: s } = e
        const { $from: l, $to: u } = o
        const d = i.extensionManager.attributes
        const f = rc(d, l.node().type.name, l.node().attrs)
        if (o instanceof he && o.node.isBlock) {
          return !l.parentOffset || !zn(s, l.pos)
            ? !1
            : (r &&
                      (t && GE(n, i.extensionManager.splittableMarks),
                      e.split(l.pos).scrollIntoView()),
              !0)
        }
        if (!l.parent.isBlock) return !1
        const h = u.parentOffset === u.parent.content.size
        const m =
            l.depth === 0
              ? void 0
              : Mp(l.node(-1).contentMatchAt(l.indexAfter(-1)))
        let b = h && m ? [{ type: m, attrs: f }] : void 0
        let g = zn(e.doc, e.mapping.map(l.pos), 1, b)
        if (
          (!b &&
                !g &&
                zn(
                  e.doc,
                  e.mapping.map(l.pos),
                  1,
                  m ? [{ type: m }] : void 0
                ) &&
                ((g = !0), (b = m ? [{ type: m, attrs: f }] : void 0)),
          r)
        ) {
          if (
            g &&
                (o instanceof le && e.deleteSelection(),
                e.split(e.mapping.map(l.pos), 1, b),
                m && !h && !l.parentOffset && l.parent.type !== m)
          ) {
            const E = e.mapping.map(l.before())
            const w = e.doc.resolve(E)
            l.node(-1).canReplaceWith(w.index(), w.index() + 1, m) &&
                    e.setNodeMarkup(e.mapping.map(l.before()), m)
          }
          t && GE(n, i.extensionManager.splittableMarks), e.scrollIntoView()
        }
        return g
      }
const oL =
    (t, e = {}) =>
      ({ tr: n, state: r, dispatch: i, editor: o }) => {
        let s
        const l = Ut(t, r.schema)
        const { $from: u, $to: d } = r.selection
        const f = r.selection.node
        if ((f && f.isBlock) || u.depth < 2 || !u.sameParent(d)) return !1
        const h = u.node(-1)
        if (h.type !== l) return !1
        const m = o.extensionManager.attributes
        if (
          u.parent.content.size === 0 &&
            u.node(-1).childCount === u.indexAfter(-1)
        ) {
          if (
            u.depth === 2 ||
                u.node(-3).type !== l ||
                u.index(-2) !== u.node(-2).childCount - 1
          ) {
            return !1
          }
          if (i) {
            let S = K.empty
            const O = u.index(-1) ? 1 : u.index(-2) ? 2 : 3
            for (let ne = u.depth - O; ne >= u.depth - 3; ne -= 1) {
              S = K.from(u.node(ne).copy(S))
            }
            const k =
                    u.indexAfter(-1) < u.node(-2).childCount
                      ? 1
                      : u.indexAfter(-2) < u.node(-3).childCount
                        ? 2
                        : 3
            const T = {
              ...rc(m, u.node().type.name, u.node().attrs),
              ...e
            }
            const P =
                    ((s = l.contentMatch.defaultType) === null || s === void 0
                      ? void 0
                      : s.createAndFill(T)) || void 0
            S = S.append(K.from(l.createAndFill(null, P) || void 0))
            const I = u.before(u.depth - (O - 1))
            n.replace(I, u.after(-k), new Z(S, 4 - O, 0))
            let Y = -1
            n.doc.nodesBetween(I, n.doc.content.size, (ne, q) => {
              if (Y > -1) return !1
              ne.isTextblock && ne.content.size === 0 && (Y = q + 1)
            }),
            Y > -1 && n.setSelection(le.near(n.doc.resolve(Y))),
            n.scrollIntoView()
          }
          return !0
        }
        const b = d.pos === u.end() ? h.contentMatchAt(0).defaultType : null
        const g = { ...rc(m, h.type.name, h.attrs), ...e }
        const E = { ...rc(m, u.node().type.name, u.node().attrs), ...e }
        n.delete(u.pos, d.pos)
        const w = b
          ? [
              { type: l, attrs: g },
              { type: b, attrs: E }
            ]
          : [{ type: l, attrs: g }]
        if (!zn(n.doc, u.pos, 2)) return !1
        if (i) {
          const { selection: S, storedMarks: O } = r
          const { splittableMarks: k } = o.extensionManager
          const T = O || (S.$to.parentOffset && S.$from.marks())
          if ((n.split(u.pos, 2, w).scrollIntoView(), !T || !i)) {
            return !0
          }
          const P = T.filter((I) => k.includes(I.type.name))
          n.ensureMarks(P)
        }
        return !0
      }
const gp = (t, e) => {
  const n = to((s) => s.type === e)(t.selection)
  if (!n) return !0
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth)
  if (r === void 0) return !0
  const i = t.doc.nodeAt(r)
  return n.node.type === i?.type && rr(t.doc, n.pos) && t.join(n.pos), !0
}
const bp = (t, e) => {
  const n = to((s) => s.type === e)(t.selection)
  if (!n) return !0
  const r = t.doc.resolve(n.start).after(n.depth)
  if (r === void 0) return !0
  const i = t.doc.nodeAt(r)
  return n.node.type === i?.type && rr(t.doc, r) && t.join(r), !0
}
const sL =
    (t, e, n, r = {}) =>
      ({
        editor: i,
        tr: o,
        state: s,
        dispatch: l,
        chain: u,
        commands: d,
        can: f
      }) => {
        const { extensions: h, splittableMarks: m } = i.extensionManager
        const b = Ut(t, s.schema)
        const g = Ut(e, s.schema)
        const { selection: E, storedMarks: w } = s
        const { $from: S, $to: O } = E
        const k = S.blockRange(O)
        const T = w || (E.$to.parentOffset && E.$from.marks())
        if (!k) return !1
        const P = to((I) => VE(I.type.name, h))(E)
        if (k.depth >= 1 && P && k.depth - P.depth <= 1) {
          if (P.node.type === b) return d.liftListItem(g)
          if (
            VE(P.node.type.name, h) &&
                b.validContent(P.node.content) &&
                l
          ) {
            return u()
              .command(() => (o.setNodeMarkup(P.pos, b), !0))
              .command(() => gp(o, b))
              .command(() => bp(o, b))
              .run()
          }
        }
        return !n || !T || !l
          ? u()
            .command(() => (f().wrapInList(b, r) ? !0 : d.clearNodes()))
            .wrapInList(b, r)
            .command(() => gp(o, b))
            .command(() => bp(o, b))
            .run()
          : u()
            .command(() => {
              const I = f().wrapInList(b, r)
              const Y = T.filter((ne) => m.includes(ne.type.name))
              return o.ensureMarks(Y), I ? !0 : d.clearNodes()
            })
            .wrapInList(b, r)
            .command(() => gp(o, b))
            .command(() => bp(o, b))
            .run()
      }
const aL =
    (t, e = {}, n = {}) =>
      ({ state: r, commands: i }) => {
        const { extendEmptyMarkRange: o = !1 } = n
        const s = yi(t, r.schema)
        return _p(r, s, e)
          ? i.unsetMark(s, { extendEmptyMarkRange: o })
          : i.setMark(s, e)
      }
const lL =
    (t, e, n = {}) =>
      ({ state: r, commands: i }) => {
        const o = Ut(t, r.schema)
        const s = Ut(e, r.schema)
        const l = ia(r, o, n)
        let u
        return (
          r.selection.$anchor.sameParent(r.selection.$head) &&
                (u = r.selection.$anchor.parent.attrs),
          l ? i.setNode(s, u) : i.setNode(o, { ...u, ...n })
        )
      }
const cL =
    (t, e = {}) =>
      ({ state: n, commands: r }) => {
        const i = Ut(t, n.schema)
        return ia(n, i, e) ? r.lift(i) : r.wrapIn(i, e)
      }
const uL =
    () =>
      ({ state: t, dispatch: e }) => {
        const n = t.plugins
        for (let r = 0; r < n.length; r += 1) {
          const i = n[r]
          let o
          if (i.spec.isInputRules && (o = i.getState(t))) {
            if (e) {
              const s = t.tr
              const l = o.transform
              for (let u = l.steps.length - 1; u >= 0; u -= 1) {
                s.step(l.steps[u].invert(l.docs[u]))
              }
              if (o.text) {
                const u = s.doc.resolve(o.from).marks()
                s.replaceWith(o.from, o.to, t.schema.text(o.text, u))
              } else s.delete(o.from, o.to)
            }
            return !0
          }
        }
        return !1
      }
const dL =
    () =>
      ({ tr: t, dispatch: e }) => {
        const { selection: n } = t
        const { empty: r, ranges: i } = n
        return (
          r ||
                (e &&
                    i.forEach((o) => {
                      t.removeMark(o.$from.pos, o.$to.pos)
                    })),
          !0
        )
      }
const fL =
    (t, e = {}) =>
      ({ tr: n, state: r, dispatch: i }) => {
        let o
        const { extendEmptyMarkRange: s = !1 } = e
        const { selection: l } = n
        const u = yi(t, r.schema)
        const { $from: d, empty: f, ranges: h } = l
        if (!i) return !0
        if (f && s) {
          let { from: m, to: b } = l
          const g =
                (o = d.marks().find((w) => w.type === u)) === null ||
                o === void 0
                  ? void 0
                  : o.attrs
          const E = Ap(d, u, g)
          E && ((m = E.from), (b = E.to)), n.removeMark(m, b, u)
        } else {
          h.forEach((m) => {
            n.removeMark(m.$from.pos, m.$to.pos, u)
          })
        }
        return n.removeStoredMark(u), !0
      }
const pL =
    (t, e = {}) =>
      ({ tr: n, state: r, dispatch: i }) => {
        let o = null
        let s = null
        const l = fc(typeof t === 'string' ? t : t.name, r.schema)
        return l
          ? (l === 'node' && (o = Ut(t, r.schema)),
            l === 'mark' && (s = yi(t, r.schema)),
            i &&
                  n.selection.ranges.forEach((u) => {
                    const d = u.$from.pos
                    const f = u.$to.pos
                    let h
                    let m
                    let b
                    let g
                    n.selection.empty
                      ? r.doc.nodesBetween(d, f, (E, w) => {
                        o &&
                                    o === E.type &&
                                    ((b = Math.max(w, d)),
                                    (g = Math.min(w + E.nodeSize, f)),
                                    (h = w),
                                    (m = E))
                      })
                      : r.doc.nodesBetween(d, f, (E, w) => {
                        w < d &&
                                    o &&
                                    o === E.type &&
                                    ((b = Math.max(w, d)),
                                    (g = Math.min(w + E.nodeSize, f)),
                                    (h = w),
                                    (m = E)),
                        w >= d &&
                                        w <= f &&
                                        (o &&
                                            o === E.type &&
                                            n.setNodeMarkup(w, void 0, {
                                              ...E.attrs,
                                              ...e
                                            }),
                                        s &&
                                            E.marks.length &&
                                            E.marks.forEach((S) => {
                                              if (s === S.type) {
                                                const O = Math.max(w, d)
                                                const k = Math.min(
                                                  w + E.nodeSize,
                                                  f
                                                )
                                                n.addMark(
                                                  O,
                                                  k,
                                                  s.create({
                                                    ...S.attrs,
                                                    ...e
                                                  })
                                                )
                                              }
                                            }))
                      }),
                    m &&
                              (h !== void 0 &&
                                  n.setNodeMarkup(h, void 0, {
                                    ...m.attrs,
                                    ...e
                                  }),
                              s &&
                                  m.marks.length &&
                                  m.marks.forEach((E) => {
                                    s === E.type &&
                                          n.addMark(
                                            b,
                                            g,
                                            s.create({
                                              ...E.attrs,
                                              ...e
                                            })
                                          )
                                  }))
                  }),
            !0)
          : !1
      }
const hL =
    (t, e = {}) =>
      ({ state: n, dispatch: r }) => {
        const i = Ut(t, n.schema)
        return PE(i, e)(n, r)
      }
const mL =
    (t, e = {}) =>
      ({ state: n, dispatch: r }) => {
        const i = Ut(t, n.schema)
        return BE(i, e)(n, r)
      }
const gL = Object.freeze({
  __proto__: null,
  blur: oD,
  clearContent: sD,
  clearNodes: aD,
  command: lD,
  createParagraphNear: cD,
  cut: uD,
  deleteCurrentNode: dD,
  deleteNode: fD,
  deleteRange: pD,
  deleteSelection: hD,
  enter: mD,
  exitCode: gD,
  extendMarkRange: bD,
  first: yD,
  focus: ED,
  forEach: vD,
  insertContent: wD,
  insertContentAt: SD,
  joinBackward: AD,
  joinDown: CD,
  joinForward: MD,
  joinItemBackward: ND,
  joinItemForward: kD,
  joinTextblockBackward: OD,
  joinTextblockForward: RD,
  joinUp: TD,
  keyboardShortcut: DD,
  lift: LD,
  liftEmptyBlock: PD,
  liftListItem: BD,
  newlineInCode: FD,
  resetAttributes: HD,
  scrollIntoView: $D,
  selectAll: zD,
  selectNodeBackward: UD,
  selectNodeForward: WD,
  selectParentNode: KD,
  selectTextblockEnd: VD,
  selectTextblockStart: GD,
  setContent: qD,
  setMark: jD,
  setMeta: QD,
  setNode: eL,
  setNodeSelection: tL,
  setTextSelection: nL,
  sinkListItem: rL,
  splitBlock: iL,
  splitListItem: oL,
  toggleList: sL,
  toggleMark: aL,
  toggleNode: lL,
  toggleWrap: cL,
  undoInputRule: uL,
  unsetAllMarks: dL,
  unsetMark: fL,
  updateAttributes: pL,
  wrapIn: hL,
  wrapInList: mL
})
const bL = We.create({
  name: 'commands',
  addCommands () {
    return { ...gL }
  }
})
const yL = We.create({
  name: 'drop',
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('tiptapDrop'),
        props: {
          handleDrop: (t, e, n, r) => {
            this.editor.emit('drop', {
              editor: this.editor,
              event: e,
              slice: n,
              moved: r
            })
          }
        }
      })
    ]
  }
})
const EL = We.create({
  name: 'editable',
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('editable'),
        props: { editable: () => this.editor.options.editable }
      })
    ]
  }
})
const vL = We.create({
  name: 'focusEvents',
  addProseMirrorPlugins () {
    const { editor: t } = this
    return [
      new Oe({
        key: new ze('focusEvents'),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0
              const r = t.state.tr
                .setMeta('focus', { event: n })
                .setMeta('addToHistory', !1)
              return e.dispatch(r), !1
            },
            blur: (e, n) => {
              t.isFocused = !1
              const r = t.state.tr
                .setMeta('blur', { event: n })
                .setMeta('addToHistory', !1)
              return e.dispatch(r), !1
            }
          }
        }
      })
    ]
  }
})
const wL = We.create({
  name: 'keymap',
  addKeyboardShortcuts () {
    const t = () =>
      this.editor.commands.first(({ commands: s }) => [
        () => s.undoInputRule(),
        () =>
          s.command(({ tr: l }) => {
            const { selection: u, doc: d } = l
            const { empty: f, $anchor: h } = u
            const { pos: m, parent: b } = h
            const g =
                            h.parent.isTextblock && m > 0
                              ? l.doc.resolve(m - 1)
                              : h
            const E = g.parent.type.spec.isolating
            const w = h.pos - h.parentOffset
            const S =
                            E && g.parent.childCount === 1
                              ? w === h.pos
                              : ue.atStart(d).from === m
            return !f ||
                            !b.type.isTextblock ||
                            b.textContent.length ||
                            !S ||
                            (S && h.parent.type.name === 'paragraph')
              ? !1
              : s.clearNodes()
          }),
        () => s.deleteSelection(),
        () => s.joinBackward(),
        () => s.selectNodeBackward()
      ])
    const e = () =>
      this.editor.commands.first(({ commands: s }) => [
        () => s.deleteSelection(),
        () => s.deleteCurrentNode(),
        () => s.joinForward(),
        () => s.selectNodeForward()
      ])
    const r = {
      Enter: () =>
        this.editor.commands.first(({ commands: s }) => [
          () => s.newlineInCode(),
          () => s.createParagraphNear(),
          () => s.liftEmptyBlock(),
          () => s.splitBlock()
        ]),
      'Mod-Enter': () => this.editor.commands.exitCode(),
      Backspace: t,
      'Mod-Backspace': t,
      'Shift-Backspace': t,
      Delete: e,
      'Mod-Delete': e,
      'Mod-a': () => this.editor.commands.selectAll()
    }
    const i = { ...r }
    const o = {
      ...r,
      'Ctrl-h': t,
      'Alt-Backspace': t,
      'Ctrl-d': e,
      'Ctrl-Alt-Backspace': e,
      'Alt-Delete': e,
      'Alt-d': e,
      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),
      'Ctrl-e': () => this.editor.commands.selectTextblockEnd()
    }
    return QE() || ev() ? o : i
  },
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('clearDocument'),
        appendTransaction: (t, e, n) => {
          const r = t.some((E) => E.docChanged) && !e.doc.eq(n.doc)
          const i = t.some((E) => E.getMeta('preventClearDocument'))
          if (!r || i) return
          const { empty: o, from: s, to: l } = e.selection
          const u = ue.atStart(e.doc).from
          const d = ue.atEnd(e.doc).to
          if (o || !(s === u && l === d) || !oa(n.doc)) return
          const m = n.tr
          const b = ac({ state: n, transaction: m })
          const { commands: g } = new Yo({
            editor: this.editor,
            state: b
          })
          if ((g.clearNodes(), !!m.steps.length)) return m
        }
      })
    ]
  }
})
const xL = We.create({
  name: 'paste',
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('tiptapPaste'),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit('paste', {
              editor: this.editor,
              event: e,
              slice: n
            })
          }
        }
      })
    ]
  }
})
const _L = We.create({
  name: 'tabindex',
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('tabindex'),
        props: {
          attributes: () =>
            this.editor.isEditable ? { tabindex: '0' } : {}
        }
      })
    ]
  }
})
const Sp = class t {
  get name () {
    return this.node.type.name
  }

  constructor (e, n, r = !1, i = null) {
    (this.currentNode = null),
    (this.actualDepth = null),
    (this.isBlock = r),
    (this.resolvedPos = e),
    (this.editor = n),
    (this.currentNode = i)
  }

  get node () {
    return this.currentNode || this.resolvedPos.node()
  }

  get element () {
    return this.editor.view.domAtPos(this.pos).node
  }

  get depth () {
    let e
    return (e = this.actualDepth) !== null && e !== void 0
      ? e
      : this.resolvedPos.depth
  }

  get pos () {
    return this.resolvedPos.pos
  }

  get content () {
    return this.node.content
  }

  set content (e) {
    let n = this.from
    let r = this.to
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(
                    `You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
        )
        return
      }
      (n = this.from + 1), (r = this.to - 1)
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e)
  }

  get attributes () {
    return this.node.attrs
  }

  get textContent () {
    return this.node.textContent
  }

  get size () {
    return this.node.nodeSize
  }

  get from () {
    return this.isBlock
      ? this.pos
      : this.resolvedPos.start(this.resolvedPos.depth)
  }

  get range () {
    return { from: this.from, to: this.to }
  }

  get to () {
    return this.isBlock
      ? this.pos + this.size
      : this.resolvedPos.end(this.resolvedPos.depth) +
                  (this.node.isText ? 0 : 1)
  }

  get parent () {
    if (this.depth === 0) return null
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1)
    const n = this.resolvedPos.doc.resolve(e)
    return new t(n, this.editor)
  }

  get before () {
    let e = this.resolvedPos.doc.resolve(
      this.from - (this.isBlock ? 1 : 2)
    )
    return (
      e.depth !== this.depth &&
                (e = this.resolvedPos.doc.resolve(this.from - 3)),
      new t(e, this.editor)
    )
  }

  get after () {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1))
    return (
      e.depth !== this.depth &&
                (e = this.resolvedPos.doc.resolve(this.to + 3)),
      new t(e, this.editor)
    )
  }

  get children () {
    const e = []
    return (
      this.node.content.forEach((n, r) => {
        const i = n.isBlock && !n.isTextblock
        const o = n.isAtom && !n.isText
        const s = this.pos + r + (o ? 0 : 1)
        const l = this.resolvedPos.doc.resolve(s)
        if (!i && l.depth <= this.depth) return
        const u = new t(l, this.editor, i, i ? n : null)
        i && (u.actualDepth = this.depth + 1),
        e.push(new t(l, this.editor, i, i ? n : null))
      }),
      e
    )
  }

  get firstChild () {
    return this.children[0] || null
  }

  get lastChild () {
    const e = this.children
    return e[e.length - 1] || null
  }

  closest (e, n = {}) {
    let r = null
    let i = this.parent
    for (; i && !r;) {
      if (i.node.type.name === e) {
        if (Object.keys(n).length > 0) {
          const o = i.node.attrs
          const s = Object.keys(n)
          for (let l = 0; l < s.length; l += 1) {
            const u = s[l]
            if (o[u] !== n[u]) break
          }
        } else r = i
      }
      i = i.parent
    }
    return r
  }

  querySelector (e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null
  }

  querySelectorAll (e, n = {}, r = !1) {
    let i = []
    if (!this.children || this.children.length === 0) return i
    const o = Object.keys(n)
    return (
      this.children.forEach((s) => {
        (r && i.length > 0) ||
                    (s.node.type.name === e &&
                        o.every((u) => n[u] === s.node.attrs[u]) &&
                        i.push(s),
                    !(r && i.length > 0) &&
                        (i = i.concat(s.querySelectorAll(e, n, r))))
      }),
      i
    )
  }

  setAttribute (e) {
    const { tr: n } = this.editor.state
    n.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }),
    this.editor.view.dispatch(n)
  }
}
const SL = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`
function TL (t, e, n) {
  const r = document.querySelector(
        `style[data-tiptap-style${n ? `-${n}` : ''}]`
  )
  if (r !== null) return r
  const i = document.createElement('style')
  return (
    e && i.setAttribute('nonce', e),
    i.setAttribute(`data-tiptap-style${n ? `-${n}` : ''}`, ''),
    (i.innerHTML = t),
    document.getElementsByTagName('head')[0].appendChild(i),
    i
  )
}
const sc = class extends yp {
  constructor (e = {}) {
    super(),
    (this.isFocused = !1),
    (this.isInitialized = !1),
    (this.extensionStorage = {}),
    (this.options = {
      element: document.createElement('div'),
      content: '',
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n
      },
      onPaste: () => null,
      onDrop: () => null
    }),
    (this.isCapturingTransaction = !1),
    (this.capturedTransaction = null),
    this.setOptions(e),
    this.createExtensionManager(),
    this.createCommandManager(),
    this.createSchema(),
    this.on('beforeCreate', this.options.onBeforeCreate),
    this.emit('beforeCreate', { editor: this }),
    this.on('contentError', this.options.onContentError),
    this.createView(),
    this.injectCSS(),
    this.on('create', this.options.onCreate),
    this.on('update', this.options.onUpdate),
    this.on('selectionUpdate', this.options.onSelectionUpdate),
    this.on('transaction', this.options.onTransaction),
    this.on('focus', this.options.onFocus),
    this.on('blur', this.options.onBlur),
    this.on('destroy', this.options.onDestroy),
    this.on('drop', ({ event: n, slice: r, moved: i }) =>
      this.options.onDrop(n, r, i)
    ),
    this.on('paste', ({ event: n, slice: r }) =>
      this.options.onPaste(n, r)
    ),
    window.setTimeout(() => {
      this.isDestroyed ||
                    (this.commands.focus(this.options.autofocus),
                    this.emit('create', { editor: this }),
                    (this.isInitialized = !0))
    }, 0)
  }

  get storage () {
    return this.extensionStorage
  }

  get commands () {
    return this.commandManager.commands
  }

  chain () {
    return this.commandManager.chain()
  }

  can () {
    return this.commandManager.can()
  }

  injectCSS () {
    this.options.injectCSS &&
            document &&
            (this.css = TL(SL, this.options.injectNonce))
  }

  setOptions (e = {}) {
    (this.options = { ...this.options, ...e }),
    !(!this.view || !this.state || this.isDestroyed) &&
                (this.options.editorProps &&
                    this.view.setProps(this.options.editorProps),
                this.view.updateState(this.state))
  }

  setEditable (e, n = !0) {
    this.setOptions({ editable: e }),
    n &&
                this.emit('update', {
                  editor: this,
                  transaction: this.state.tr
                })
  }

  get isEditable () {
    return this.options.editable && this.view && this.view.editable
  }

  get state () {
    return this.view.state
  }

  registerPlugin (e, n) {
    const r = YE(n)
      ? n(e, [...this.state.plugins])
      : [...this.state.plugins, e]
    const i = this.state.reconfigure({ plugins: r })
    return this.view.updateState(i), i
  }

  unregisterPlugin (e) {
    if (this.isDestroyed) return
    const n = this.state.plugins
    let r = n
    if (
      ([].concat(e).forEach((o) => {
        const s = typeof o === 'string' ? `${o}$` : o.key
        r = n.filter((l) => !l.key.startsWith(s))
      }),
      n.length === r.length)
    ) {
      return
    }
    const i = this.state.reconfigure({ plugins: r })
    return this.view.updateState(i), i
  }

  createExtensionManager () {
    let e, n
    const i = [
      ...(this.options.enableCoreExtensions
        ? [
            EL,
            iD.configure({
              blockSeparator:
                              (n =
                                  (e = this.options.coreExtensionOptions) ===
                                      null || e === void 0
                                    ? void 0
                                    : e.clipboardTextSerializer) === null ||
                              n === void 0
                                ? void 0
                                : n.blockSeparator
            }),
            bL,
            vL,
            wL,
            _L,
            yL,
            xL
          ].filter((o) =>
            typeof this.options.enableCoreExtensions === 'object'
              ? this.options.enableCoreExtensions[o.name] !== !1
              : !0
          )
        : []),
      ...this.options.extensions
    ].filter((o) => ['extension', 'node', 'mark'].includes(o?.type))
    this.extensionManager = new wp(i, this)
  }

  createCommandManager () {
    this.commandManager = new Yo({ editor: this })
  }

  createSchema () {
    this.schema = this.extensionManager.schema
  }

  createView () {
    let e
    let n
    try {
      n = xp(
        this.options.content,
        this.schema,
        this.options.parseOptions,
        { errorOnInvalidContent: this.options.enableContentCheck }
      )
    } catch (s) {
      if (
        !(s instanceof Error) ||
                ![
                  '[tiptap error]: Invalid JSON content',
                  '[tiptap error]: Invalid HTML content'
                ].includes(s.message)
      ) {
        throw s
      }
      this.emit('contentError', {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration &&
                        (this.storage.collaboration.isDisabled = !0),
          (this.options.extensions =
                            this.options.extensions.filter(
                              (l) => l.name !== 'collaboration'
                            )),
          this.createExtensionManager()
        }
      }),
      (n = xp(
        this.options.content,
        this.schema,
        this.options.parseOptions,
        { errorOnInvalidContent: !1 }
      ))
    }
    const r = ZE(n, this.options.autofocus)
    this.view = new ql(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        role: 'textbox',
        ...((e = this.options.editorProps) === null || e === void 0
          ? void 0
          : e.attributes)
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Pl.create({ doc: n, selection: r || void 0 })
    })
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    })
    this.view.updateState(i), this.createNodeViews(), this.prependClass()
    const o = this.view.dom
    o.editor = this
  }

  createNodeViews () {
    this.view.isDestroyed ||
            this.view.setProps({ nodeViews: this.extensionManager.nodeViews })
  }

  prependClass () {
    this.view.dom.className = `tiptap ${this.view.dom.className}`
  }

  captureTransaction (e) {
    (this.isCapturingTransaction = !0),
    e(),
    (this.isCapturingTransaction = !1)
    const n = this.capturedTransaction
    return (this.capturedTransaction = null), n
  }

  dispatchTransaction (e) {
    if (this.view.isDestroyed) return
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e
        return
      }
      e.steps.forEach((s) => {
        let l
        return (l = this.capturedTransaction) === null || l === void 0
          ? void 0
          : l.step(s)
      })
      return
    }
    const n = this.state.apply(e)
    const r = !this.state.selection.eq(n.selection)
    this.emit('beforeTransaction', {
      editor: this,
      transaction: e,
      nextState: n
    }),
    this.view.updateState(n),
    this.emit('transaction', { editor: this, transaction: e }),
    r && this.emit('selectionUpdate', { editor: this, transaction: e })
    const i = e.getMeta('focus')
    const o = e.getMeta('blur')
    i &&
            this.emit('focus', {
              editor: this,
              event: i.event,
              transaction: e
            }),
    o &&
                this.emit('blur', {
                  editor: this,
                  event: o.event,
                  transaction: e
                }),
    !(!e.docChanged || e.getMeta('preventUpdate')) &&
                this.emit('update', { editor: this, transaction: e })
  }

  getAttributes (e) {
    return Op(this.state, e)
  }

  isActive (e, n) {
    const r = typeof e === 'string' ? e : null
    const i = typeof e === 'string' ? n : e
    return Ur(this.state, r, i)
  }

  getJSON () {
    return this.state.doc.toJSON()
  }

  getHTML () {
    return Tp(this.state.doc.content, this.schema)
  }

  getText (e) {
    const {
      blockSeparator: n = `

`,
      textSerializers: r = {}
    } = e || {}
    return kp(this.state.doc, {
      blockSeparator: n,
      textSerializers: { ...uc(this.schema), ...r }
    })
  }

  get isEmpty () {
    return oa(this.state.doc)
  }

  getCharacterCount () {
    return (
      console.warn(
        '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
      ),
      this.state.doc.content.size - 2
    )
  }

  destroy () {
    if ((this.emit('destroy'), this.view)) {
      const e = this.view.dom
      e && e.editor && delete e.editor, this.view.destroy()
    }
    this.removeAllListeners()
  }

  get isDestroyed () {
    let e
    return !(!((e = this.view) === null || e === void 0) && e.docView)
  }

  $node (e, n) {
    let r
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelector(e, n)) || null
    )
  }

  $nodes (e, n) {
    let r
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelectorAll(e, n)) || null
    )
  }

  $pos (e) {
    const n = this.state.doc.resolve(e)
    return new Sp(n, this)
  }

  get $doc () {
    return this.$pos(0)
  }
}
function Vn (t) {
  return new Jo({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = Te(t.getAttributes, void 0, r)
      if (i === !1 || i === null) return null
      const { tr: o } = e
      const s = r[r.length - 1]
      const l = r[0]
      if (s) {
        const u = l.search(/\S/)
        const d = n.from + l.indexOf(s)
        const f = d + s.length
        if (
          pc(n.from, n.to, e.doc)
            .filter((b) =>
              b.mark.type.excluded.find(
                (E) => E === t.type && E !== b.mark.type
              )
            )
            .filter((b) => b.to > d).length
        ) {
          return null
        }
        f < n.to && o.delete(f, n.to),
        d > n.from && o.delete(n.from + u, d)
        const m = n.from + u + s.length
        o.addMark(n.from + u, m, t.type.create(i || {})),
        o.removeStoredMark(t.type)
      }
    }
  })
}
function gc (t) {
  return new Jo({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = Te(t.getAttributes, void 0, r) || {}
      const { tr: o } = e
      const s = n.from
      let l = n.to
      const u = t.type.create(i)
      if (r[1]) {
        const d = r[0].lastIndexOf(r[1])
        let f = s + d
        f > l ? (f = l) : (l = f + r[1].length)
        const h = r[0][r[0].length - 1]
        o.insertText(h, s + r[0].length - 1), o.replaceWith(f, l, u)
      } else if (r[0]) {
        const d = t.type.isInline ? s : s - 1
        o.insert(d, t.type.create(i)).delete(
          o.mapping.map(s),
          o.mapping.map(l)
        )
      }
      o.scrollIntoView()
    }
  })
}
function sa (t) {
  return new Jo({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = e.doc.resolve(n.from)
      const o = Te(t.getAttributes, void 0, r) || {}
      if (
        !i
          .node(-1)
          .canReplaceWith(i.index(-1), i.indexAfter(-1), t.type)
      ) {
        return null
      }
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, o)
    }
  })
}
function Ei (t) {
  return new Jo({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: i }) => {
      const o = Te(t.getAttributes, void 0, r) || {}
      const s = e.tr.delete(n.from, n.to)
      const u = s.doc.resolve(n.from).blockRange()
      const d = u && Bo(u, t.type, o)
      if (!d) return null
      if ((s.wrap(u, d), t.keepMarks && t.editor)) {
        const { selection: h, storedMarks: m } = e
        const { splittableMarks: b } = t.editor.extensionManager
        const g = m || (h.$to.parentOffset && h.$from.marks())
        if (g) {
          const E = g.filter((w) => b.includes(w.type.name))
          s.ensureMarks(E)
        }
      }
      if (t.keepAttributes) {
        const h =
                    t.type.name === 'bulletList' ||
                    t.type.name === 'orderedList'
                      ? 'listItem'
                      : 'taskList'
        i().updateAttributes(h, o).run()
      }
      const f = s.doc.resolve(n.from - 1).nodeBefore
      f &&
                f.type === t.type &&
                rr(s.doc, n.from - 1) &&
                (!t.joinPredicate || t.joinPredicate(r, f)) &&
                s.join(n.from - 1)
    }
  })
}
const ce = class t {
  constructor (e = {}) {
    (this.type = 'node'),
    (this.name = 'node'),
    (this.parent = null),
    (this.child = null),
    (this.config = { name: this.name, defaultOptions: {} }),
    (this.config = { ...this.config, ...e }),
    (this.name = this.config.name),
    e.defaultOptions &&
                Object.keys(e.defaultOptions).length > 0 &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
                ),
    (this.options = this.config.defaultOptions),
    this.config.addOptions &&
                (this.options = Te(
                  re(this, 'addOptions', { name: this.name })
                )),
    (this.storage =
                Te(
                  re(this, 'addStorage', {
                    name: this.name,
                    options: this.options
                  })
                ) || {})
  }

  static create (e = {}) {
    return new t(e)
  }

  configure (e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => cc(this.options, e)
    })
    return (n.name = this.name), (n.parent = this.parent), n
  }

  extend (e = {}) {
    const n = new t(e)
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
                Object.keys(e.defaultOptions).length > 0 &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
                ),
      (n.options = Te(re(n, 'addOptions', { name: n.name }))),
      (n.storage = Te(
        re(n, 'addStorage', { name: n.name, options: n.options })
      )),
      n
    )
  }
}
function xn (t) {
  return new vp({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: i }) => {
      const o = Te(t.getAttributes, void 0, r, i)
      if (o === !1 || o === null) return null
      const { tr: s } = e
      const l = r[r.length - 1]
      const u = r[0]
      let d = n.to
      if (l) {
        const f = u.search(/\S/)
        const h = n.from + u.indexOf(l)
        const m = h + l.length
        if (
          pc(n.from, n.to, e.doc)
            .filter((g) =>
              g.mark.type.excluded.find(
                (w) => w === t.type && w !== g.mark.type
              )
            )
            .filter((g) => g.to > h).length
        ) {
          return null
        }
        m < n.to && s.delete(m, n.to),
        h > n.from && s.delete(n.from + f, h),
        (d = n.from + f + l.length),
        s.addMark(n.from + f, d, t.type.create(o || {})),
        s.removeStoredMark(t.type)
      }
    }
  })
}
function ov (t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')
}
const CL = /^\s*>\s$/
const sv = ce.create({
  name: 'blockquote',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  content: 'block+',
  group: 'block',
  defining: !0,
  parseHTML () {
    return [{ tag: 'blockquote' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['blockquote', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setBlockquote:
                () =>
                  ({ commands: t }) =>
                    t.wrapIn(this.name),
      toggleBlockquote:
                () =>
                  ({ commands: t }) =>
                    t.toggleWrap(this.name),
      unsetBlockquote:
                () =>
                  ({ commands: t }) =>
                    t.lift(this.name)
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote()
    }
  },
  addInputRules () {
    return [Ei({ find: CL, type: this.type })]
  }
})
const AL = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/
const ML = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g
const NL = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/
const kL = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g
const av = st.create({
  name: 'bold',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [
      { tag: 'strong' },
      {
        tag: 'b',
        getAttrs: (t) => t.style.fontWeight !== 'normal' && null
      },
      {
        style: 'font-weight=400',
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: 'font-weight',
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['strong', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setBold:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleBold:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetBold:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-b': () => this.editor.commands.toggleBold(),
      'Mod-B': () => this.editor.commands.toggleBold()
    }
  },
  addInputRules () {
    return [
      Vn({ find: AL, type: this.type }),
      Vn({ find: NL, type: this.type })
    ]
  },
  addPasteRules () {
    return [
      xn({ find: ML, type: this.type }),
      xn({ find: kL, type: this.type })
    ]
  }
})
const OL = 'listItem'
const lv = 'textStyle'
const cv = /^\s*([-+*])\s$/
const uv = ce.create({
  name: 'bulletList',
  addOptions () {
    return {
      itemTypeName: 'listItem',
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    }
  },
  group: 'block list',
  content () {
    return `${this.options.itemTypeName}+`
  },
  parseHTML () {
    return [{ tag: 'ul' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['ul', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      toggleBulletList:
                () =>
                  ({ commands: t, chain: e }) =>
                    this.options.keepAttributes
                      ? e()
                        .toggleList(
                          this.name,
                          this.options.itemTypeName,
                          this.options.keepMarks
                        )
                        .updateAttributes(
                          OL,
                          this.editor.getAttributes(lv)
                        )
                        .run()
                      : t.toggleList(
                        this.name,
                        this.options.itemTypeName,
                        this.options.keepMarks
                      )
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-Shift-8': () => this.editor.commands.toggleBulletList()
    }
  },
  addInputRules () {
    let t = Ei({ find: cv, type: this.type })
    return (
      (this.options.keepMarks || this.options.keepAttributes) &&
                (t = Ei({
                  find: cv,
                  type: this.type,
                  keepMarks: this.options.keepMarks,
                  keepAttributes: this.options.keepAttributes,
                  getAttributes: () => this.editor.getAttributes(lv),
                  editor: this.editor
                })),
      [t]
    )
  }
})
const RL = /(^|[^`])`([^`]+)`(?!`)/
const IL = /(^|[^`])`([^`]+)`(?!`)/g
const dv = st.create({
  name: 'code',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  excludes: '_',
  code: !0,
  exitable: !0,
  parseHTML () {
    return [{ tag: 'code' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['code', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setCode:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleCode:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetCode:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return { 'Mod-e': () => this.editor.commands.toggleCode() }
  },
  addInputRules () {
    return [Vn({ find: RL, type: this.type })]
  },
  addPasteRules () {
    return [xn({ find: IL, type: this.type })]
  }
})
const DL = (t) => {
  if (!t.children.length) return
  const e = t.querySelectorAll('span')
  e &&
        e.forEach((n) => {
          let r, i
          const o = n.getAttribute('style')
          const s =
                (i =
                    (r = n.parentElement) === null || r === void 0
                      ? void 0
                      : r.closest('span')) === null || i === void 0
                  ? void 0
                  : i.getAttribute('style')
          n.setAttribute('style', `${s};${o}`)
        })
}
const fv = st.create({
  name: 'textStyle',
  priority: 101,
  addOptions () {
    return { HTMLAttributes: {}, mergeNestedSpanStyles: !1 }
  },
  parseHTML () {
    return [
      {
        tag: 'span',
        getAttrs: (t) =>
          t.hasAttribute('style')
            ? (this.options.mergeNestedSpanStyles && DL(t), {})
            : !1
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['span', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      removeEmptyTextStyle:
                () =>
                  ({ tr: t }) => {
                    const { selection: e } = t
                    return (
                      t.doc.nodesBetween(e.from, e.to, (n, r) => {
                        if (n.isTextblock) return !0
                        n.marks
                          .filter((i) => i.type === this.type)
                          .some((i) =>
                            Object.values(i.attrs).some((o) => !!o)
                          ) || t.removeMark(r, r + n.nodeSize, this.type)
                      }),
                      !0
                    )
                  }
    }
  }
})
const pv = We.create({
  name: 'color',
  addOptions () {
    return { types: ['textStyle'] }
  },
  addGlobalAttributes () {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              let e
              return (e = t.style.color) === null || e === void 0
                ? void 0
                : e.replace(/['"]+/g, '')
            },
            renderHTML: (t) =>
              t.color ? { style: `color: ${t.color}` } : {}
          }
        }
      }
    ]
  },
  addCommands () {
    return {
      setColor:
                (t) =>
                  ({ chain: e }) =>
                    e().setMark('textStyle', { color: t }).run(),
      unsetColor:
                () =>
                  ({ chain: t }) =>
                    t()
                      .setMark('textStyle', { color: null })
                      .removeEmptyTextStyle()
                      .run()
    }
  }
})
const Rp = ce.create({ name: 'doc', topNode: !0, content: 'block+' })
function hv (t = {}) {
  return new Oe({
    view (e) {
      return new Ip(e, t)
    }
  })
}
var Ip = class {
  constructor (e, n) {
    let r;
    (this.editorView = e),
    (this.cursorPos = null),
    (this.element = null),
    (this.timeout = -1),
    (this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
    (this.color = n.color === !1 ? void 0 : n.color || 'black'),
    (this.class = n.class),
    (this.handlers = ['dragover', 'dragend', 'drop', 'dragleave'].map(
      (i) => {
        const o = (s) => {
          this[i](s)
        }
        return (
          e.dom.addEventListener(i, o), { name: i, handler: o }
        )
      }
    ))
  }

  destroy () {
    this.handlers.forEach(({ name: e, handler: n }) =>
      this.editorView.dom.removeEventListener(e, n)
    )
  }

  update (e, n) {
    this.cursorPos != null &&
            n.doc != e.state.doc &&
            (this.cursorPos > e.state.doc.content.size
              ? this.setCursor(null)
              : this.updateOverlay())
  }

  setCursor (e) {
    e != this.cursorPos &&
            ((this.cursorPos = e),
            e == null
              ? (this.element.parentNode.removeChild(this.element),
                (this.element = null))
              : this.updateOverlay())
  }

  updateOverlay () {
    const e = this.editorView.state.doc.resolve(this.cursorPos)
    const n = !e.parent.inlineContent
    let r
    if (n) {
      const l = e.nodeBefore
      const u = e.nodeAfter
      if (l || u) {
        const d = this.editorView.nodeDOM(
          this.cursorPos - (l ? l.nodeSize : 0)
        )
        if (d) {
          const f = d.getBoundingClientRect()
          let h = l ? f.bottom : f.top
          l &&
                        u &&
                        (h =
                            (h +
                                this.editorView
                                  .nodeDOM(this.cursorPos)
                                  .getBoundingClientRect().top) /
                            2),
          (r = {
            left: f.left,
            right: f.right,
            top: h - this.width / 2,
            bottom: h + this.width / 2
          })
        }
      }
    }
    if (!r) {
      const l = this.editorView.coordsAtPos(this.cursorPos)
      r = {
        left: l.left - this.width / 2,
        right: l.left + this.width / 2,
        top: l.top,
        bottom: l.bottom
      }
    }
    const i = this.editorView.dom.offsetParent
    this.element ||
            ((this.element = i.appendChild(document.createElement('div'))),
            this.class && (this.element.className = this.class),
            (this.element.style.cssText =
                'position: absolute; z-index: 50; pointer-events: none;'),
            this.color && (this.element.style.backgroundColor = this.color)),
    this.element.classList.toggle('prosemirror-dropcursor-block', n),
    this.element.classList.toggle('prosemirror-dropcursor-inline', !n)
    let o, s
    if (
      !i ||
            (i == document.body && getComputedStyle(i).position == 'static')
    ) {
      (o = -pageXOffset), (s = -pageYOffset)
    } else {
      const l = i.getBoundingClientRect();
      (o = l.left - i.scrollLeft), (s = l.top - i.scrollTop)
    }
    (this.element.style.left = r.left - o + 'px'),
    (this.element.style.top = r.top - s + 'px'),
    (this.element.style.width = r.right - r.left + 'px'),
    (this.element.style.height = r.bottom - r.top + 'px')
  }

  scheduleRemoval (e) {
    clearTimeout(this.timeout),
    (this.timeout = setTimeout(() => this.setCursor(null), e))
  }

  dragover (e) {
    if (!this.editorView.editable) return
    const n = this.editorView.posAtCoords({
      left: e.clientX,
      top: e.clientY
    })
    const r =
            n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside)
    const i = r && r.type.spec.disableDropCursor
    const o = typeof i === 'function' ? i(this.editorView, n, e) : i
    if (n && !o) {
      let s = n.pos
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        const l = Il(
          this.editorView.state.doc,
          s,
          this.editorView.dragging.slice
        )
        l != null && (s = l)
      }
      this.setCursor(s), this.scheduleRemoval(5e3)
    }
  }

  dragend () {
    this.scheduleRemoval(20)
  }

  drop () {
    this.scheduleRemoval(20)
  }

  dragleave (e) {
    (e.target == this.editorView.dom ||
            !this.editorView.dom.contains(e.relatedTarget)) &&
            this.setCursor(null)
  }
}
const mv = We.create({
  name: 'dropCursor',
  addOptions () {
    return { color: 'currentColor', width: 1, class: void 0 }
  },
  addProseMirrorPlugins () {
    return [hv(this.options)]
  }
})
const on = class t extends ue {
  constructor (e) {
    super(e, e)
  }

  map (e, n) {
    const r = e.resolve(n.map(this.head))
    return t.valid(r) ? new t(r) : ue.near(r)
  }

  content () {
    return Z.empty
  }

  eq (e) {
    return e instanceof t && e.head == this.head
  }

  toJSON () {
    return { type: 'gapcursor', pos: this.head }
  }

  static fromJSON (e, n) {
    if (typeof n.pos !== 'number') {
      throw new RangeError('Invalid input for GapCursor.fromJSON')
    }
    return new t(e.resolve(n.pos))
  }

  getBookmark () {
    return new Dp(this.anchor)
  }

  static valid (e) {
    const n = e.parent
    if (n.isTextblock || !LL(e) || !PL(e)) return !1
    const r = n.type.spec.allowGapCursor
    if (r != null) return r
    const i = n.contentMatchAt(e.index()).defaultType
    return i && i.isTextblock
  }

  static findGapCursorFrom (e, n, r = !1) {
    e: for (;;) {
      if (!r && t.valid(e)) return e
      let i = e.pos
      let o = null
      for (let s = e.depth; ; s--) {
        const l = e.node(s)
        if (n > 0 ? e.indexAfter(s) < l.childCount : e.index(s) > 0) {
          o = l.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1)
          break
        } else if (s == 0) return null
        i += n
        const u = e.doc.resolve(i)
        if (t.valid(u)) return u
      }
      for (;;) {
        const s = n > 0 ? o.firstChild : o.lastChild
        if (!s) {
          if (o.isAtom && !o.isText && !he.isSelectable(o)) {
            (e = e.doc.resolve(i + o.nodeSize * n)), (r = !1)
            continue e
          }
          break
        }
        (o = s), (i += n)
        const l = e.doc.resolve(i)
        if (t.valid(l)) return l
      }
      return null
    }
  }
}
on.prototype.visible = !1
on.findFrom = on.findGapCursorFrom
ue.jsonID('gapcursor', on)
var Dp = class t {
  constructor (e) {
    this.pos = e
  }

  map (e) {
    return new t(e.map(this.pos))
  }

  resolve (e) {
    const n = e.resolve(this.pos)
    return on.valid(n) ? new on(n) : ue.near(n)
  }
}
function LL (t) {
  for (let e = t.depth; e >= 0; e--) {
    const n = t.index(e)
    const r = t.node(e)
    if (n == 0) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (
        (i.childCount == 0 && !i.inlineContent) ||
                i.isAtom ||
                i.type.spec.isolating
      ) {
        return !0
      }
      if (i.inlineContent) return !1
    }
  }
  return !0
}
function PL (t) {
  for (let e = t.depth; e >= 0; e--) {
    const n = t.indexAfter(e)
    const r = t.node(e)
    if (n == r.childCount) {
      if (r.type.spec.isolating) return !0
      continue
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (
        (i.childCount == 0 && !i.inlineContent) ||
                i.isAtom ||
                i.type.spec.isolating
      ) {
        return !0
      }
      if (i.inlineContent) return !1
    }
  }
  return !0
}
function gv () {
  return new Oe({
    props: {
      decorations: $L,
      createSelectionBetween (t, e, n) {
        return e.pos == n.pos && on.valid(n) ? new on(n) : null
      },
      handleClick: FL,
      handleKeyDown: BL,
      handleDOMEvents: { beforeinput: HL }
    }
  })
}
var BL = ra({
  ArrowLeft: bc('horiz', -1),
  ArrowRight: bc('horiz', 1),
  ArrowUp: bc('vert', -1),
  ArrowDown: bc('vert', 1)
})
function bc (t, e) {
  const n = t == 'vert' ? (e > 0 ? 'down' : 'up') : e > 0 ? 'right' : 'left'
  return function (r, i, o) {
    const s = r.selection
    let l = e > 0 ? s.$to : s.$from
    let u = s.empty
    if (s instanceof le) {
      if (!o.endOfTextblock(n) || l.depth == 0) return !1;
      (u = !1), (l = r.doc.resolve(e > 0 ? l.after() : l.before()))
    }
    const d = on.findGapCursorFrom(l, e, u)
    return d ? (i && i(r.tr.setSelection(new on(d))), !0) : !1
  }
}
function FL (t, e, n) {
  if (!t || !t.editable) return !1
  const r = t.state.doc.resolve(e)
  if (!on.valid(r)) return !1
  const i = t.posAtCoords({ left: n.clientX, top: n.clientY })
  return i && i.inside > -1 && he.isSelectable(t.state.doc.nodeAt(i.inside))
    ? !1
    : (t.dispatch(t.state.tr.setSelection(new on(r))), !0)
}
function HL (t, e) {
  if (
    e.inputType != 'insertCompositionText' ||
        !(t.state.selection instanceof on)
  ) {
    return !1
  }
  const { $from: n } = t.state.selection
  const r = n.parent
    .contentMatchAt(n.index())
    .findWrapping(t.state.schema.nodes.text)
  if (!r) return !1
  let i = K.empty
  for (let s = r.length - 1; s >= 0; s--) {
    i = K.from(r[s].createAndFill(null, i))
  }
  const o = t.state.tr.replace(n.pos, n.pos, new Z(i, 0, 0))
  return o.setSelection(le.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1
}
function $L (t) {
  if (!(t.selection instanceof on)) return null
  const e = document.createElement('div')
  return (
    (e.className = 'ProseMirror-gapcursor'),
    ot.create(t.doc, [wt.widget(t.selection.head, e, { key: 'gapcursor' })])
  )
}
const bv = We.create({
  name: 'gapCursor',
  addProseMirrorPlugins () {
    return [gv()]
  },
  extendNodeSchema (t) {
    let e
    const n = { name: t.name, options: t.options, storage: t.storage }
    return {
      allowGapCursor:
                (e = Te(re(t, 'allowGapCursor', n))) !== null && e !== void 0
                  ? e
                  : null
    }
  }
})
const yv = ce.create({
  name: 'hardBreak',
  addOptions () {
    return { keepMarks: !0, HTMLAttributes: {} }
  },
  inline: !0,
  group: 'inline',
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML () {
    return [{ tag: 'br' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['br', ee(this.options.HTMLAttributes, t)]
  },
  renderText () {
    return `
`
  },
  addCommands () {
    return {
      setHardBreak:
                () =>
                  ({ commands: t, chain: e, state: n, editor: r }) =>
                    t.first([
                      () => t.exitCode(),
                      () =>
                        t.command(() => {
                          const { selection: i, storedMarks: o } = n
                          if (i.$from.parent.type.spec.isolating) {
                            return !1
                          }
                          const { keepMarks: s } = this.options
                          const { splittableMarks: l } =
                                    r.extensionManager
                          const u =
                                    o ||
                                    (i.$to.parentOffset && i.$from.marks())
                          return e()
                            .insertContent({ type: this.name })
                            .command(({ tr: d, dispatch: f }) => {
                              if (f && u && s) {
                                const h = u.filter((m) =>
                                  l.includes(m.type.name)
                                )
                                d.ensureMarks(h)
                              }
                              return !0
                            })
                            .run()
                        })
                    ])
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-Enter': () => this.editor.commands.setHardBreak(),
      'Shift-Enter': () => this.editor.commands.setHardBreak()
    }
  }
})
const Ev = ce.create({
  name: 'heading',
  addOptions () {
    return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} }
  },
  content: 'inline*',
  group: 'block',
  defining: !0,
  addAttributes () {
    return { level: { default: 1, rendered: !1 } }
  },
  parseHTML () {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }))
  },
  renderHTML ({ node: t, HTMLAttributes: e }) {
    return [
            `h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`,
            ee(this.options.HTMLAttributes, e),
            0
    ]
  },
  addCommands () {
    return {
      setHeading:
                (t) =>
                  ({ commands: e }) =>
                    this.options.levels.includes(t.level)
                      ? e.setNode(this.name, t)
                      : !1,
      toggleHeading:
                (t) =>
                  ({ commands: e }) =>
                    this.options.levels.includes(t.level)
                      ? e.toggleNode(this.name, 'paragraph', t)
                      : !1
    }
  },
  addKeyboardShortcuts () {
    return this.options.levels.reduce(
      (t, e) => ({
        ...t,
        [`Mod-Alt-${e}`]: () =>
          this.editor.commands.toggleHeading({ level: e })
      }),
      {}
    )
  },
  addInputRules () {
    return this.options.levels.map((t) =>
      sa({
        find: new RegExp(
                    `^(#{${Math.min(...this.options.levels)},${t}})\\s$`
        ),
        type: this.type,
        getAttributes: { level: t }
      })
    )
  }
})
const yc = 200
const Yt = function () {}
Yt.prototype.append = function (e) {
  return e.length
    ? ((e = Yt.from(e)),
      (!this.length && e) ||
              (e.length < yc && this.leafAppend(e)) ||
              (this.length < yc && e.leafPrepend(this)) ||
              this.appendInner(e))
    : this
}
Yt.prototype.prepend = function (e) {
  return e.length ? Yt.from(e).append(this) : this
}
Yt.prototype.appendInner = function (e) {
  return new zL(this, e)
}
Yt.prototype.slice = function (e, n) {
  return (
    e === void 0 && (e = 0),
    n === void 0 && (n = this.length),
    e >= n
      ? Yt.empty
      : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
  )
}
Yt.prototype.get = function (e) {
  if (!(e < 0 || e >= this.length)) return this.getInner(e)
}
Yt.prototype.forEach = function (e, n, r) {
  n === void 0 && (n = 0),
  r === void 0 && (r = this.length),
  n <= r
    ? this.forEachInner(e, n, r, 0)
    : this.forEachInvertedInner(e, n, r, 0)
}
Yt.prototype.map = function (e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length)
  const i = []
  return (
    this.forEach(
      function (o, s) {
        return i.push(e(o, s))
      },
      n,
      r
    ),
    i
  )
}
Yt.from = function (e) {
  return e instanceof Yt ? e : e && e.length ? new vv(e) : Yt.empty
}
var vv = (function (t) {
  function e (r) {
    t.call(this), (this.values = r)
  }
  t && (e.__proto__ = t),
  (e.prototype = Object.create(t && t.prototype)),
  (e.prototype.constructor = e)
  const n = { length: { configurable: !0 }, depth: { configurable: !0 } }
  return (
    (e.prototype.flatten = function () {
      return this.values
    }),
    (e.prototype.sliceInner = function (i, o) {
      return i == 0 && o == this.length
        ? this
        : new e(this.values.slice(i, o))
    }),
    (e.prototype.getInner = function (i) {
      return this.values[i]
    }),
    (e.prototype.forEachInner = function (i, o, s, l) {
      for (let u = o; u < s; u++) {
        if (i(this.values[u], l + u) === !1) return !1
      }
    }),
    (e.prototype.forEachInvertedInner = function (i, o, s, l) {
      for (let u = o - 1; u >= s; u--) {
        if (i(this.values[u], l + u) === !1) return !1
      }
    }),
    (e.prototype.leafAppend = function (i) {
      if (this.length + i.length <= yc) {
        return new e(this.values.concat(i.flatten()))
      }
    }),
    (e.prototype.leafPrepend = function (i) {
      if (this.length + i.length <= yc) {
        return new e(i.flatten().concat(this.values))
      }
    }),
    (n.length.get = function () {
      return this.values.length
    }),
    (n.depth.get = function () {
      return 0
    }),
    Object.defineProperties(e.prototype, n),
    e
  )
})(Yt)
Yt.empty = new vv([])
var zL = (function (t) {
  function e (n, r) {
    t.call(this),
    (this.left = n),
    (this.right = r),
    (this.length = n.length + r.length),
    (this.depth = Math.max(n.depth, r.depth) + 1)
  }
  return (
    t && (e.__proto__ = t),
    (e.prototype = Object.create(t && t.prototype)),
    (e.prototype.constructor = e),
    (e.prototype.flatten = function () {
      return this.left.flatten().concat(this.right.flatten())
    }),
    (e.prototype.getInner = function (r) {
      return r < this.left.length
        ? this.left.get(r)
        : this.right.get(r - this.left.length)
    }),
    (e.prototype.forEachInner = function (r, i, o, s) {
      const l = this.left.length
      if (
        (i < l &&
                    this.left.forEachInner(r, i, Math.min(o, l), s) === !1) ||
                (o > l &&
                    this.right.forEachInner(
                      r,
                      Math.max(i - l, 0),
                      Math.min(this.length, o) - l,
                      s + l
                    ) === !1)
      ) {
        return !1
      }
    }),
    (e.prototype.forEachInvertedInner = function (r, i, o, s) {
      const l = this.left.length
      if (
        (i > l &&
                    this.right.forEachInvertedInner(
                      r,
                      i - l,
                      Math.max(o, l) - l,
                      s + l
                    ) === !1) ||
                (o < l &&
                    this.left.forEachInvertedInner(r, Math.min(i, l), o, s) ===
                        !1)
      ) {
        return !1
      }
    }),
    (e.prototype.sliceInner = function (r, i) {
      if (r == 0 && i == this.length) return this
      const o = this.left.length
      return i <= o
        ? this.left.slice(r, i)
        : r >= o
          ? this.right.slice(r - o, i - o)
          : this.left.slice(r, o).append(this.right.slice(0, i - o))
    }),
    (e.prototype.leafAppend = function (r) {
      const i = this.right.leafAppend(r)
      if (i) return new e(this.left, i)
    }),
    (e.prototype.leafPrepend = function (r) {
      const i = this.left.leafPrepend(r)
      if (i) return new e(i, this.right)
    }),
    (e.prototype.appendInner = function (r) {
      return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
        ? new e(this.left, new e(this.right, r))
        : new e(this, r)
    }),
    e
  )
})(Yt)
const Lp = Yt
const UL = 500
const ro = class t {
  constructor (e, n) {
    (this.items = e), (this.eventCount = n)
  }

  popEvent (e, n) {
    if (this.eventCount == 0) return null
    let r = this.items.length
    for (; ; r--) {
      if (this.items.get(r - 1).selection) {
        --r
        break
      }
    }
    let i, o
    n && ((i = this.remapping(r, this.items.length)), (o = i.maps.length))
    const s = e.tr
    let l
    let u
    const d = []
    const f = []
    return (
      this.items.forEach(
        (h, m) => {
          if (!h.step) {
            i ||
                            ((i = this.remapping(r, m + 1)),
                            (o = i.maps.length)),
            o--,
            f.push(h)
            return
          }
          if (i) {
            f.push(new mr(h.map))
            const b = h.step.map(i.slice(o))
            let g
            b &&
                            s.maybeStep(b).doc &&
                            ((g = s.mapping.maps[s.mapping.maps.length - 1]),
                            d.push(
                              new mr(g, void 0, void 0, d.length + f.length)
                            )),
            o--,
            g && i.appendMap(g, o)
          } else s.maybeStep(h.step)
          if (h.selection) {
            return (
              (l = i ? h.selection.map(i.slice(o)) : h.selection),
              (u = new t(
                this.items
                  .slice(0, r)
                  .append(f.reverse().concat(d)),
                this.eventCount - 1
              )),
              !1
            )
          }
        },
        this.items.length,
        0
      ),
      { remaining: u, transform: s, selection: l }
    )
  }

  addTransform (e, n, r, i) {
    const o = []
    let s = this.eventCount
    let l = this.items
    let u = !i && l.length ? l.get(l.length - 1) : null
    for (let f = 0; f < e.steps.length; f++) {
      const h = e.steps[f].invert(e.docs[f])
      let m = new mr(e.mapping.maps[f], h, n)
      let b;
      (b = u && u.merge(m)) &&
                ((m = b), f ? o.pop() : (l = l.slice(0, l.length - 1))),
      o.push(m),
      n && (s++, (n = void 0)),
      i || (u = m)
    }
    const d = s - r.depth
    return d > KL && ((l = WL(l, d)), (s -= d)), new t(l.append(o), s)
  }

  remapping (e, n) {
    const r = new Us()
    return (
      this.items.forEach(
        (i, o) => {
          const s =
                        i.mirrorOffset != null && o - i.mirrorOffset >= e
                          ? r.maps.length - i.mirrorOffset
                          : void 0
          r.appendMap(i.map, s)
        },
        e,
        n
      ),
      r
    )
  }

  addMaps (e) {
    return this.eventCount == 0
      ? this
      : new t(
        this.items.append(e.map((n) => new mr(n))),
        this.eventCount
      )
  }

  rebased (e, n) {
    if (!this.eventCount) return this
    const r = []
    const i = Math.max(0, this.items.length - n)
    const o = e.mapping
    let s = e.steps.length
    let l = this.eventCount
    this.items.forEach((m) => {
      m.selection && l--
    }, i)
    let u = n
    this.items.forEach((m) => {
      const b = o.getMirror(--u)
      if (b == null) return
      s = Math.min(s, b)
      const g = o.maps[b]
      if (m.step) {
        const E = e.steps[b].invert(e.docs[b])
        const w = m.selection && m.selection.map(o.slice(u + 1, b))
        w && l++, r.push(new mr(g, E, w))
      } else r.push(new mr(g))
    }, i)
    const d = []
    for (let m = n; m < s; m++) d.push(new mr(o.maps[m]))
    const f = this.items.slice(0, i).append(d).append(r)
    let h = new t(f, l)
    return (
      h.emptyItemCount() > UL &&
                (h = h.compress(this.items.length - r.length)),
      h
    )
  }

  emptyItemCount () {
    let e = 0
    return (
      this.items.forEach((n) => {
        n.step || e++
      }),
      e
    )
  }

  compress (e = this.items.length) {
    const n = this.remapping(0, e)
    let r = n.maps.length
    const i = []
    let o = 0
    return (
      this.items.forEach(
        (s, l) => {
          if (l >= e) i.push(s), s.selection && o++
          else if (s.step) {
            const u = s.step.map(n.slice(r))
            const d = u && u.getMap()
            if ((r--, d && n.appendMap(d, r), u)) {
              const f =
                                s.selection && s.selection.map(n.slice(r))
              f && o++
              const h = new mr(d.invert(), u, f)
              let m
              const b = i.length - 1;
              (m = i.length && i[b].merge(h))
                ? (i[b] = m)
                : i.push(h)
            }
          } else s.map && r--
        },
        this.items.length,
        0
      ),
      new t(Lp.from(i.reverse()), o)
    )
  }
}
ro.empty = new ro(Lp.empty, 0)
function WL (t, e) {
  let n
  return (
    t.forEach((r, i) => {
      if (r.selection && e-- == 0) return (n = i), !1
    }),
    t.slice(n)
  )
}
var mr = class t {
  constructor (e, n, r, i) {
    (this.map = e),
    (this.step = n),
    (this.selection = r),
    (this.mirrorOffset = i)
  }

  merge (e) {
    if (this.step && e.step && !e.selection) {
      const n = e.step.merge(this.step)
      if (n) return new t(n.getMap().invert(), n, this.selection)
    }
  }
}
const gr = class {
  constructor (e, n, r, i, o) {
    (this.done = e),
    (this.undone = n),
    (this.prevRanges = r),
    (this.prevTime = i),
    (this.prevComposition = o)
  }
}
var KL = 20
function VL (t, e, n, r) {
  const i = n.getMeta(no)
  let o
  if (i) return i.historyState
  n.getMeta(YL) && (t = new gr(t.done, t.undone, null, 0, -1))
  const s = n.getMeta('appendedTransaction')
  if (n.steps.length == 0) return t
  if (s && s.getMeta(no)) {
    return s.getMeta(no).redo
      ? new gr(
        t.done.addTransform(n, void 0, r, Ec(e)),
        t.undone,
        wv(n.mapping.maps),
        t.prevTime,
        t.prevComposition
      )
      : new gr(
        t.done,
        t.undone.addTransform(n, void 0, r, Ec(e)),
        null,
        t.prevTime,
        t.prevComposition
      )
  }
  if (
    n.getMeta('addToHistory') !== !1 &&
        !(s && s.getMeta('addToHistory') === !1)
  ) {
    const l = n.getMeta('composition')
    const u =
            t.prevTime == 0 ||
            (!s &&
                t.prevComposition != l &&
                (t.prevTime < (n.time || 0) - r.newGroupDelay ||
                    !GL(n, t.prevRanges)))
    const d = s ? Pp(t.prevRanges, n.mapping) : wv(n.mapping.maps)
    return new gr(
      t.done.addTransform(
        n,
        u ? e.selection.getBookmark() : void 0,
        r,
        Ec(e)
      ),
      ro.empty,
      d,
      n.time,
      l ?? t.prevComposition
    )
  } else {
    return (o = n.getMeta('rebased'))
      ? new gr(
        t.done.rebased(n, o),
        t.undone.rebased(n, o),
        Pp(t.prevRanges, n.mapping),
        t.prevTime,
        t.prevComposition
      )
      : new gr(
        t.done.addMaps(n.mapping.maps),
        t.undone.addMaps(n.mapping.maps),
        Pp(t.prevRanges, n.mapping),
        t.prevTime,
        t.prevComposition
      )
  }
}
function GL (t, e) {
  if (!e) return !1
  if (!t.docChanged) return !0
  let n = !1
  return (
    t.mapping.maps[0].forEach((r, i) => {
      for (let o = 0; o < e.length; o += 2) {
        r <= e[o + 1] && i >= e[o] && (n = !0)
      }
    }),
    n
  )
}
function wv (t) {
  const e = []
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--) {
    t[n].forEach((r, i, o, s) => e.push(o, s))
  }
  return e
}
function Pp (t, e) {
  if (!t) return null
  const n = []
  for (let r = 0; r < t.length; r += 2) {
    const i = e.map(t[r], 1)
    const o = e.map(t[r + 1], -1)
    i <= o && n.push(i, o)
  }
  return n
}
function qL (t, e, n) {
  const r = Ec(e)
  const i = no.get(e).spec.config
  const o = (n ? t.undone : t.done).popEvent(e, r)
  if (!o) return null
  const s = o.selection.resolve(o.transform.doc)
  const l = (n ? t.done : t.undone).addTransform(
    o.transform,
    e.selection.getBookmark(),
    i,
    r
  )
  const u = new gr(n ? l : o.remaining, n ? o.remaining : l, null, 0, -1)
  return o.transform
    .setSelection(s)
    .setMeta(no, { redo: n, historyState: u })
}
let Bp = !1
let xv = null
function Ec (t) {
  const e = t.plugins
  if (xv != e) {
    (Bp = !1), (xv = e)
    for (let n = 0; n < e.length; n++) {
      if (e[n].spec.historyPreserveItems) {
        Bp = !0
        break
      }
    }
  }
  return Bp
}
var no = new ze('history')
var YL = new ze('closeHistory')
function _v (t = {}) {
  return (
    (t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
    new Oe({
      key: no,
      state: {
        init () {
          return new gr(ro.empty, ro.empty, null, 0, -1)
        },
        apply (e, n, r) {
          return VL(n, r, e, t)
        }
      },
      config: t,
      props: {
        handleDOMEvents: {
          beforeinput (e, n) {
            const r = n.inputType
            const i =
                            r == 'historyUndo'
                              ? Fp
                              : r == 'historyRedo'
                                ? Hp
                                : null
            return i
              ? (n.preventDefault(), i(e.state, e.dispatch))
              : !1
          }
        }
      }
    })
  )
}
function vc (t, e) {
  return (n, r) => {
    const i = no.getState(n)
    if (!i || (t ? i.undone : i.done).eventCount == 0) return !1
    if (r) {
      const o = qL(i, n, t)
      o && r(e ? o.scrollIntoView() : o)
    }
    return !0
  }
}
var Fp = vc(!1, !0)
var Hp = vc(!0, !0)
const $z = vc(!1, !1)
const zz = vc(!0, !1)
const Sv = We.create({
  name: 'history',
  addOptions () {
    return { depth: 100, newGroupDelay: 500 }
  },
  addCommands () {
    return {
      undo:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Fp(t, e),
      redo:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Hp(t, e)
    }
  },
  addProseMirrorPlugins () {
    return [_v(this.options)]
  },
  addKeyboardShortcuts () {
    return {
      'Mod-z': () => this.editor.commands.undo(),
      'Shift-Mod-z': () => this.editor.commands.redo(),
      'Mod-y': () => this.editor.commands.redo(),
      'Mod-\u044F': () => this.editor.commands.undo(),
      'Shift-Mod-\u044F': () => this.editor.commands.redo()
    }
  }
})
const Tv = ce.create({
  name: 'horizontalRule',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  group: 'block',
  parseHTML () {
    return [{ tag: 'hr' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['hr', ee(this.options.HTMLAttributes, t)]
  },
  addCommands () {
    return {
      setHorizontalRule:
                () =>
                  ({ chain: t, state: e }) => {
                    const { selection: n } = e
                    const { $from: r, $to: i } = n
                    const o = t()
                    return (
                      r.parentOffset === 0
                        ? o.insertContentAt(
                          { from: Math.max(r.pos - 1, 0), to: i.pos },
                          { type: this.name }
                        )
                        : hc(n)
                          ? o.insertContentAt(i.pos, { type: this.name })
                          : o.insertContent({ type: this.name }),
                      o
                        .command(({ tr: s, dispatch: l }) => {
                          let u
                          if (l) {
                            const { $to: d } = s.selection
                            const f = d.end()
                            if (d.nodeAfter) {
                              d.nodeAfter.isTextblock
                                ? s.setSelection(
                                  le.create(s.doc, d.pos + 1)
                                )
                                : d.nodeAfter.isBlock
                                  ? s.setSelection(
                                    he.create(s.doc, d.pos)
                                  )
                                  : s.setSelection(
                                    le.create(s.doc, d.pos)
                                  )
                            } else {
                              const h =
                                            (u =
                                                d.parent.type.contentMatch
                                                  .defaultType) === null ||
                                            u === void 0
                                              ? void 0
                                              : u.create()
                              h &&
                                            (s.insert(f, h),
                                            s.setSelection(
                                              le.create(s.doc, f + 1)
                                            ))
                            }
                            s.scrollIntoView()
                          }
                          return !0
                        })
                        .run()
                    )
                  }
    }
  },
  addInputRules () {
    return [gc({ find: /^(?:---|—-|___\s|\*\*\*\s)$/, type: this.type })]
  }
})
const JL = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/
const XL = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g
const ZL = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/
const jL = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g
const Cv = st.create({
  name: 'italic',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [
      { tag: 'em' },
      {
        tag: 'i',
        getAttrs: (t) => t.style.fontStyle !== 'normal' && null
      },
      {
        style: 'font-style=normal',
        clearMark: (t) => t.type.name === this.name
      },
      { style: 'font-style=italic' }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['em', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setItalic:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleItalic:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetItalic:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-i': () => this.editor.commands.toggleItalic(),
      'Mod-I': () => this.editor.commands.toggleItalic()
    }
  },
  addInputRules () {
    return [
      Vn({ find: JL, type: this.type }),
      Vn({ find: ZL, type: this.type })
    ]
  },
  addPasteRules () {
    return [
      xn({ find: XL, type: this.type }),
      xn({ find: jL, type: this.type })
    ]
  }
})
const $p = ce.create({
  name: 'listItem',
  addOptions () {
    return {
      HTMLAttributes: {},
      bulletListTypeName: 'bulletList',
      orderedListTypeName: 'orderedList'
    }
  },
  content: 'paragraph block*',
  defining: !0,
  parseHTML () {
    return [{ tag: 'li' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['li', ee(this.options.HTMLAttributes, t), 0]
  },
  addKeyboardShortcuts () {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      'Shift-Tab': () => this.editor.commands.liftListItem(this.name)
    }
  }
})
const QL = 'listItem'
const Av = 'textStyle'
const Mv = /^(\d+)\.\s$/
const Nv = ce.create({
  name: 'orderedList',
  addOptions () {
    return {
      itemTypeName: 'listItem',
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    }
  },
  group: 'block list',
  content () {
    return `${this.options.itemTypeName}+`
  },
  addAttributes () {
    return {
      start: {
        default: 1,
        parseHTML: (t) =>
          t.hasAttribute('start')
            ? parseInt(t.getAttribute('start') || '', 10)
            : 1
      },
      type: {
        default: void 0,
        parseHTML: (t) => t.getAttribute('type')
      }
    }
  },
  parseHTML () {
    return [{ tag: 'ol' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    const { start: e, ...n } = t
    return e === 1
      ? ['ol', ee(this.options.HTMLAttributes, n), 0]
      : ['ol', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      toggleOrderedList:
                () =>
                  ({ commands: t, chain: e }) =>
                    this.options.keepAttributes
                      ? e()
                        .toggleList(
                          this.name,
                          this.options.itemTypeName,
                          this.options.keepMarks
                        )
                        .updateAttributes(
                          QL,
                          this.editor.getAttributes(Av)
                        )
                        .run()
                      : t.toggleList(
                        this.name,
                        this.options.itemTypeName,
                        this.options.keepMarks
                      )
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList()
    }
  },
  addInputRules () {
    let t = Ei({
      find: Mv,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    })
    return (
      (this.options.keepMarks || this.options.keepAttributes) &&
                (t = Ei({
                  find: Mv,
                  type: this.type,
                  keepMarks: this.options.keepMarks,
                  keepAttributes: this.options.keepAttributes,
                  getAttributes: (e) => ({
                    start: +e[1],
                    ...this.editor.getAttributes(Av)
                  }),
                  joinPredicate: (e, n) =>
                    n.childCount + n.attrs.start === +e[1],
                  editor: this.editor
                })),
      [t]
    )
  }
})
const wc = ce.create({
  name: 'paragraph',
  priority: 1e3,
  addOptions () {
    return { HTMLAttributes: {} }
  },
  group: 'block',
  content: 'inline*',
  parseHTML () {
    return [{ tag: 'p' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['p', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setParagraph:
                () =>
                  ({ commands: t }) =>
                    t.setNode(this.name)
    }
  },
  addKeyboardShortcuts () {
    return { 'Mod-Alt-0': () => this.editor.commands.setParagraph() }
  }
})
const kv = We.create({
  name: 'placeholder',
  addOptions () {
    return {
      emptyEditorClass: 'is-editor-empty',
      emptyNodeClass: 'is-empty',
      placeholder: 'Write something \u2026',
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    }
  },
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('placeholder'),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n =
                            this.editor.isEditable ||
                            !this.options.showOnlyWhenEditable
            const { anchor: r } = e
            const i = []
            if (!n) return null
            const o = this.editor.isEmpty
            return (
              t.descendants((s, l) => {
                const u = r >= l && r <= l + s.nodeSize
                const d = !s.isLeaf && oa(s)
                if ((u || !this.options.showOnlyCurrent) && d) {
                  const f = [this.options.emptyNodeClass]
                  o && f.push(this.options.emptyEditorClass)
                  const h = wt.node(l, l + s.nodeSize, {
                    class: f.join(' '),
                    'data-placeholder':
                                            typeof this.options.placeholder ===
                                            'function'
                                              ? this.options.placeholder({
                                                editor: this.editor,
                                                node: s,
                                                pos: l,
                                                hasAnchor: u
                                              })
                                              : this.options.placeholder
                  })
                  i.push(h)
                }
                return this.options.includeChildren
              }),
              ot.create(t, i)
            )
          }
        }
      })
    ]
  }
})
const eP = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/
const tP = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g
const Ov = st.create({
  name: 'strike',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [
      { tag: 's' },
      { tag: 'del' },
      { tag: 'strike' },
      {
        style: 'text-decoration',
        consuming: !1,
        getAttrs: (t) => (t.includes('line-through') ? {} : !1)
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['s', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setStrike:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleStrike:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetStrike:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return { 'Mod-Shift-s': () => this.editor.commands.toggleStrike() }
  },
  addInputRules () {
    return [Vn({ find: eP, type: this.type })]
  },
  addPasteRules () {
    return [xn({ find: tP, type: this.type })]
  }
})
const Rv = st.create({
  name: 'subscript',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [
      { tag: 'sub' },
      {
        style: 'vertical-align',
        getAttrs (t) {
          return t !== 'sub' ? !1 : null
        }
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['sub', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setSubscript:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleSubscript:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetSubscript:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return { 'Mod-,': () => this.editor.commands.toggleSubscript() }
  }
})
const Iv = st.create({
  name: 'superscript',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [
      { tag: 'sup' },
      {
        style: 'vertical-align',
        getAttrs (t) {
          return t !== 'super' ? !1 : null
        }
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['sup', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setSuperscript:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleSuperscript:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetSuperscript:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return { 'Mod-.': () => this.editor.commands.toggleSuperscript() }
  }
})
let Up, Wp
if (typeof WeakMap < 'u') {
  const t = new WeakMap();
  (Up = (e) => t.get(e)), (Wp = (e, n) => (t.set(e, n), n))
} else {
  const t = []
  let n = 0;
  (Up = (r) => {
    for (let i = 0; i < t.length; i += 2) if (t[i] == r) return t[i + 1]
  }),
  (Wp = (r, i) => (n == 10 && (n = 0), (t[n++] = r), (t[n++] = i)))
}
const mt = class {
  constructor (t, e, n, r) {
    (this.width = t),
    (this.height = e),
    (this.map = n),
    (this.problems = r)
  }

  findCell (t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e]
      if (n != t) continue
      const r = e % this.width
      const i = (e / this.width) | 0
      let o = r + 1
      let s = i + 1
      for (let l = 1; o < this.width && this.map[e + l] == n; l++) o++
      for (
        let l = 1;
        s < this.height && this.map[e + this.width * l] == n;
        l++
      ) {
        s++
      }
      return { left: r, top: i, right: o, bottom: s }
    }
    throw new RangeError(`No cell with offset ${t} found`)
  }

  colCount (t) {
    for (let e = 0; e < this.map.length; e++) {
      if (this.map[e] == t) return e % this.width
    }
    throw new RangeError(`No cell with offset ${t} found`)
  }

  nextCell (t, e, n) {
    const { left: r, right: i, top: o, bottom: s } = this.findCell(t)
    return e == 'horiz'
      ? (n < 0 ? r == 0 : i == this.width)
          ? null
          : this.map[o * this.width + (n < 0 ? r - 1 : i)]
      : (n < 0 ? o == 0 : s == this.height)
          ? null
          : this.map[r + this.width * (n < 0 ? o - 1 : s)]
  }

  rectBetween (t, e) {
    const { left: n, right: r, top: i, bottom: o } = this.findCell(t)
    const { left: s, right: l, top: u, bottom: d } = this.findCell(e)
    return {
      left: Math.min(n, s),
      top: Math.min(i, u),
      right: Math.max(r, l),
      bottom: Math.max(o, d)
    }
  }

  cellsInRect (t) {
    const e = []
    const n = {}
    for (let r = t.top; r < t.bottom; r++) {
      for (let i = t.left; i < t.right; i++) {
        const o = r * this.width + i
        const s = this.map[o]
        n[s] ||
                    ((n[s] = !0),
                    !(
                      (i == t.left && i && this.map[o - 1] == s) ||
                        (r == t.top && r && this.map[o - this.width] == s)
                    ) && e.push(s))
      }
    }
    return e
  }

  positionAt (t, e, n) {
    for (let r = 0, i = 0; ; r++) {
      const o = i + n.child(r).nodeSize
      if (r == t) {
        let s = e + t * this.width
        const l = (t + 1) * this.width
        for (; s < l && this.map[s] < i;) s++
        return s == l ? o - 1 : this.map[s]
      }
      i = o
    }
  }

  static get (t) {
    return Up(t) || Wp(t, nP(t))
  }
}
function nP (t) {
  if (t.type.spec.tableRole != 'table') {
    throw new RangeError('Not a table node: ' + t.type.name)
  }
  const e = rP(t)
  const n = t.childCount
  const r = []
  let i = 0
  let o = null
  const s = []
  for (let d = 0, f = e * n; d < f; d++) r[d] = 0
  for (let d = 0, f = 0; d < n; d++) {
    const h = t.child(d)
    f++
    for (let g = 0; ; g++) {
      for (; i < r.length && r[i] != 0;) i++
      if (g == h.childCount) break
      const E = h.child(g)
      const { colspan: w, rowspan: S, colwidth: O } = E.attrs
      for (let k = 0; k < S; k++) {
        if (k + d >= n) {
          (o || (o = [])).push({
            type: 'overlong_rowspan',
            pos: f,
            n: S - k
          })
          break
        }
        const T = i + k * e
        for (let P = 0; P < w; P++) {
          r[T + P] == 0
            ? (r[T + P] = f)
            : (o || (o = [])).push({
                type: 'collision',
                row: d,
                pos: f,
                n: w - P
              })
          const I = O && O[P]
          if (I) {
            const Y = ((T + P) % e) * 2
            const ne = s[Y]
            ne == null || (ne != I && s[Y + 1] == 1)
              ? ((s[Y] = I), (s[Y + 1] = 1))
              : ne == I && s[Y + 1]++
          }
        }
      }
      (i += w), (f += E.nodeSize)
    }
    const m = (d + 1) * e
    let b = 0
    for (; i < m;) r[i++] == 0 && b++
    b && (o || (o = [])).push({ type: 'missing', row: d, n: b }), f++
  }
  const l = new mt(e, n, r, o)
  let u = !1
  for (let d = 0; !u && d < s.length; d += 2) {
    s[d] != null && s[d + 1] < n && (u = !0)
  }
  return u && iP(l, s, t), l
}
function rP (t) {
  let e = -1
  let n = !1
  for (let r = 0; r < t.childCount; r++) {
    const i = t.child(r)
    let o = 0
    if (n) {
      for (let s = 0; s < r; s++) {
        const l = t.child(s)
        for (let u = 0; u < l.childCount; u++) {
          const d = l.child(u)
          s + d.attrs.rowspan > r && (o += d.attrs.colspan)
        }
      }
    }
    for (let s = 0; s < i.childCount; s++) {
      const l = i.child(s);
      (o += l.attrs.colspan), l.attrs.rowspan > 1 && (n = !0)
    }
    e == -1 ? (e = o) : e != o && (e = Math.max(e, o))
  }
  return e
}
function iP (t, e, n) {
  t.problems || (t.problems = [])
  const r = {}
  for (let i = 0; i < t.map.length; i++) {
    const o = t.map[i]
    if (r[o]) continue
    r[o] = !0
    const s = n.nodeAt(o)
    if (!s) throw new RangeError(`No cell with offset ${o} found`)
    let l = null
    const u = s.attrs
    for (let d = 0; d < u.colspan; d++) {
      const f = (i + d) % t.width
      const h = e[f * 2]
      h != null &&
                (!u.colwidth || u.colwidth[d] != h) &&
                ((l || (l = oP(u)))[d] = h)
    }
    l &&
            t.problems.unshift({
              type: 'colwidth mismatch',
              pos: o,
              colwidth: l
            })
  }
}
function oP (t) {
  if (t.colwidth) return t.colwidth.slice()
  const e = []
  for (let n = 0; n < t.colspan; n++) e.push(0)
  return e
}
function sn (t) {
  let e = t.cached.tableNodeTypes
  if (!e) {
    e = t.cached.tableNodeTypes = {}
    for (const n in t.nodes) {
      const r = t.nodes[n]
      const i = r.spec.tableRole
      i && (e[i] = r)
    }
  }
  return e
}
const vi = new ze('selectingCells')
function Xo (t) {
  for (let e = t.depth - 1; e > 0; e--) {
    if (t.node(e).type.spec.tableRole == 'row') {
      return t.node(0).resolve(t.before(e + 1))
    }
  }
  return null
}
function sP (t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole
    if (n === 'cell' || n === 'header_cell') return t.node(e)
  }
  return null
}
function or (t) {
  const e = t.selection.$head
  for (let n = e.depth; n > 0; n--) {
    if (e.node(n).type.spec.tableRole == 'row') return !0
  }
  return !1
}
function Ac (t) {
  const e = t.selection
  if ('$anchorCell' in e && e.$anchorCell) {
    return e.$anchorCell.pos > e.$headCell.pos
      ? e.$anchorCell
      : e.$headCell
  }
  if ('node' in e && e.node && e.node.type.spec.tableRole == 'cell') {
    return e.$anchor
  }
  const n = Xo(e.$head) || aP(e.$head)
  if (n) return n
  throw new RangeError(`No cell found around position ${e.head}`)
}
function aP (t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole
    if (r == 'cell' || r == 'header_cell') return t.doc.resolve(n)
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole
    if (r == 'cell' || r == 'header_cell') {
      return t.doc.resolve(n - e.nodeSize)
    }
  }
}
function Kp (t) {
  return t.parent.type.spec.tableRole == 'row' && !!t.nodeAfter
}
function lP (t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize)
}
function qp (t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1)
}
function Wv (t, e, n) {
  const r = t.node(-1)
  const i = mt.get(r)
  const o = t.start(-1)
  const s = i.nextCell(t.pos - o, e, n)
  return s == null ? null : t.node(0).resolve(o + s)
}
function io (t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n }
  return (
    r.colwidth &&
            ((r.colwidth = r.colwidth.slice()),
            r.colwidth.splice(e, n),
            r.colwidth.some((i) => i > 0) || (r.colwidth = null)),
    r
  )
}
function Kv (t, e, n = 1) {
  const r = { ...t, colspan: t.colspan + n }
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice()
    for (let i = 0; i < n; i++) r.colwidth.splice(e, 0, 0)
  }
  return r
}
function cP (t, e, n) {
  const r = sn(e.type.schema).header_cell
  for (let i = 0; i < t.height; i++) {
    if (e.nodeAt(t.map[n + i * t.width]).type != r) return !1
  }
  return !0
}
const et = class Wr extends ue {
  constructor (e, n = e) {
    const r = e.node(-1)
    const i = mt.get(r)
    const o = e.start(-1)
    const s = i.rectBetween(e.pos - o, n.pos - o)
    const l = e.node(0)
    const u = i.cellsInRect(s).filter((f) => f != n.pos - o)
    u.unshift(n.pos - o)
    const d = u.map((f) => {
      const h = r.nodeAt(f)
      if (!h) throw RangeError(`No cell with offset ${f} found`)
      const m = o + f + 1
      return new $o(l.resolve(m), l.resolve(m + h.content.size))
    })
    super(d[0].$from, d[0].$to, d),
    (this.$anchorCell = e),
    (this.$headCell = n)
  }

  map (e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos))
    const i = e.resolve(n.map(this.$headCell.pos))
    if (Kp(r) && Kp(i) && qp(r, i)) {
      const o = this.$anchorCell.node(-1) != r.node(-1)
      return o && this.isRowSelection()
        ? Wr.rowSelection(r, i)
        : o && this.isColSelection()
          ? Wr.colSelection(r, i)
          : new Wr(r, i)
    }
    return le.between(r, i)
  }

  content () {
    const e = this.$anchorCell.node(-1)
    const n = mt.get(e)
    const r = this.$anchorCell.start(-1)
    const i = n.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    )
    const o = {}
    const s = []
    for (let u = i.top; u < i.bottom; u++) {
      const d = []
      for (
        let f = u * n.width + i.left, h = i.left;
        h < i.right;
        h++, f++
      ) {
        const m = n.map[f]
        if (o[m]) continue
        o[m] = !0
        const b = n.findCell(m)
        let g = e.nodeAt(m)
        if (!g) throw RangeError(`No cell with offset ${m} found`)
        const E = i.left - b.left
        const w = b.right - i.right
        if (E > 0 || w > 0) {
          let S = g.attrs
          if (
            (E > 0 && (S = io(S, 0, E)),
            w > 0 && (S = io(S, S.colspan - w, w)),
            b.left < i.left)
          ) {
            if (((g = g.type.createAndFill(S)), !g)) {
              throw RangeError(
                                `Could not create cell with attrs ${JSON.stringify(S)}`
              )
            }
          } else g = g.type.create(S, g.content)
        }
        if (b.top < i.top || b.bottom > i.bottom) {
          const S = {
            ...g.attrs,
            rowspan:
                            Math.min(b.bottom, i.bottom) -
                            Math.max(b.top, i.top)
          }
          b.top < i.top
            ? (g = g.type.createAndFill(S))
            : (g = g.type.create(S, g.content))
        }
        d.push(g)
      }
      s.push(e.child(u).copy(K.from(d)))
    }
    const l = this.isColSelection() && this.isRowSelection() ? e : s
    return new Z(K.from(l), 1, 1)
  }

  replace (e, n = Z.empty) {
    const r = e.steps.length
    const i = this.ranges
    for (let s = 0; s < i.length; s++) {
      const { $from: l, $to: u } = i[s]
      const d = e.mapping.slice(r)
      e.replace(d.map(l.pos), d.map(u.pos), s ? Z.empty : n)
    }
    const o = ue.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    )
    o && e.setSelection(o)
  }

  replaceWith (e, n) {
    this.replace(e, new Z(K.from(n), 0, 0))
  }

  forEachCell (e) {
    const n = this.$anchorCell.node(-1)
    const r = mt.get(n)
    const i = this.$anchorCell.start(-1)
    const o = r.cellsInRect(
      r.rectBetween(this.$anchorCell.pos - i, this.$headCell.pos - i)
    )
    for (let s = 0; s < o.length; s++) e(n.nodeAt(o[s]), i + o[s])
  }

  isColSelection () {
    const e = this.$anchorCell.index(-1)
    const n = this.$headCell.index(-1)
    if (Math.min(e, n) > 0) return !1
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan
    const i = n + this.$headCell.nodeAfter.attrs.rowspan
    return Math.max(r, i) == this.$headCell.node(-1).childCount
  }

  static colSelection (e, n = e) {
    const r = e.node(-1)
    const i = mt.get(r)
    const o = e.start(-1)
    const s = i.findCell(e.pos - o)
    const l = i.findCell(n.pos - o)
    const u = e.node(0)
    return (
      s.top <= l.top
        ? (s.top > 0 && (e = u.resolve(o + i.map[s.left])),
          l.bottom < i.height &&
                      (n = u.resolve(
                        o + i.map[i.width * (i.height - 1) + l.right - 1]
                      )))
        : (l.top > 0 && (n = u.resolve(o + i.map[l.left])),
          s.bottom < i.height &&
                      (e = u.resolve(
                        o + i.map[i.width * (i.height - 1) + s.right - 1]
                      ))),
      new Wr(e, n)
    )
  }

  isRowSelection () {
    const e = this.$anchorCell.node(-1)
    const n = mt.get(e)
    const r = this.$anchorCell.start(-1)
    const i = n.colCount(this.$anchorCell.pos - r)
    const o = n.colCount(this.$headCell.pos - r)
    if (Math.min(i, o) > 0) return !1
    const s = i + this.$anchorCell.nodeAfter.attrs.colspan
    const l = o + this.$headCell.nodeAfter.attrs.colspan
    return Math.max(s, l) == n.width
  }

  eq (e) {
    return (
      e instanceof Wr &&
            e.$anchorCell.pos == this.$anchorCell.pos &&
            e.$headCell.pos == this.$headCell.pos
    )
  }

  static rowSelection (e, n = e) {
    const r = e.node(-1)
    const i = mt.get(r)
    const o = e.start(-1)
    const s = i.findCell(e.pos - o)
    const l = i.findCell(n.pos - o)
    const u = e.node(0)
    return (
      s.left <= l.left
        ? (s.left > 0 && (e = u.resolve(o + i.map[s.top * i.width])),
          l.right < i.width &&
                      (n = u.resolve(o + i.map[i.width * (l.top + 1) - 1])))
        : (l.left > 0 && (n = u.resolve(o + i.map[l.top * i.width])),
          s.right < i.width &&
                      (e = u.resolve(o + i.map[i.width * (s.top + 1) - 1]))),
      new Wr(e, n)
    )
  }

  toJSON () {
    return {
      type: 'cell',
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    }
  }

  static fromJSON (e, n) {
    return new Wr(e.resolve(n.anchor), e.resolve(n.head))
  }

  static create (e, n, r = n) {
    return new Wr(e.resolve(n), e.resolve(r))
  }

  getBookmark () {
    return new uP(this.$anchorCell.pos, this.$headCell.pos)
  }
}
et.prototype.visible = !1
ue.jsonID('cell', et)
var uP = class Vv {
  constructor (e, n) {
    (this.anchor = e), (this.head = n)
  }

  map (e) {
    return new Vv(e.map(this.anchor), e.map(this.head))
  }

  resolve (e) {
    const n = e.resolve(this.anchor)
    const r = e.resolve(this.head)
    return n.parent.type.spec.tableRole == 'row' &&
            r.parent.type.spec.tableRole == 'row' &&
            n.index() < n.parent.childCount &&
            r.index() < r.parent.childCount &&
            qp(n, r)
      ? new et(n, r)
      : ue.near(r, 1)
  }
}
function dP (t) {
  if (!(t.selection instanceof et)) return null
  const e = []
  return (
    t.selection.forEachCell((n, r) => {
      e.push(wt.node(r, r + n.nodeSize, { class: 'selectedCell' }))
    }),
    ot.create(t.doc, e)
  )
}
function fP ({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6) return !1
  let n = t.pos
  let r = e.pos
  let i = t.depth
  for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++);
  for (let o = e.depth; o >= 0 && !(e.before(o + 1) > e.start(o)); o--, r--);
  return n == r && /row|table/.test(t.node(i).type.spec.tableRole)
}
function pP ({ $from: t, $to: e }) {
  let n, r
  for (let i = t.depth; i > 0; i--) {
    const o = t.node(i)
    if (
      o.type.spec.tableRole === 'cell' ||
            o.type.spec.tableRole === 'header_cell'
    ) {
      n = o
      break
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const o = e.node(i)
    if (
      o.type.spec.tableRole === 'cell' ||
            o.type.spec.tableRole === 'header_cell'
    ) {
      r = o
      break
    }
  }
  return n !== r && e.parentOffset === 0
}
function hP (t, e, n) {
  const r = (e || t).selection
  const i = (e || t).doc
  let o
  let s
  if (r instanceof he && (s = r.node.type.spec.tableRole)) {
    if (s == 'cell' || s == 'header_cell') o = et.create(i, r.from)
    else if (s == 'row') {
      const l = i.resolve(r.from + 1)
      o = et.rowSelection(l, l)
    } else if (!n) {
      const l = mt.get(r.node)
      const u = r.from + 1
      const d = u + l.map[l.width * l.height - 1]
      o = et.create(i, u + 1, d)
    }
  } else {
    r instanceof le && fP(r)
      ? (o = le.create(i, r.from))
      : r instanceof le &&
              pP(r) &&
              (o = le.create(i, r.$from.start(), r.$from.end()))
  }
  return o && (e || (e = t.tr)).setSelection(o), e
}
const mP = new ze('fix-tables')
function Gv (t, e, n, r) {
  const i = t.childCount
  const o = e.childCount
  e: for (let s = 0, l = 0; s < o; s++) {
    const u = e.child(s)
    for (let d = l, f = Math.min(i, s + 3); d < f; d++) {
      if (t.child(d) == u) {
        (l = d + 1), (n += u.nodeSize)
        continue e
      }
    }
    r(u, n),
    l < i && t.child(l).sameMarkup(u)
      ? Gv(t.child(l), u, n + 1, r)
      : u.nodesBetween(0, u.content.size, r, n + 1),
    (n += u.nodeSize)
  }
}
function Yp (t, e) {
  let n
  const r = (i, o) => {
    i.type.spec.tableRole == 'table' && (n = gP(t, i, o, n))
  }
  return (
    e ? e.doc != t.doc && Gv(e.doc, t.doc, 0, r) : t.doc.descendants(r), n
  )
}
function gP (t, e, n, r) {
  const i = mt.get(e)
  if (!i.problems) return r
  r || (r = t.tr)
  const o = []
  for (let u = 0; u < i.height; u++) o.push(0)
  for (let u = 0; u < i.problems.length; u++) {
    const d = i.problems[u]
    if (d.type == 'collision') {
      const f = e.nodeAt(d.pos)
      if (!f) continue
      const h = f.attrs
      for (let m = 0; m < h.rowspan; m++) o[d.row + m] += d.n
      r.setNodeMarkup(
        r.mapping.map(n + 1 + d.pos),
        null,
        io(h, h.colspan - d.n, d.n)
      )
    } else if (d.type == 'missing') o[d.row] += d.n
    else if (d.type == 'overlong_rowspan') {
      const f = e.nodeAt(d.pos)
      if (!f) continue
      r.setNodeMarkup(r.mapping.map(n + 1 + d.pos), null, {
        ...f.attrs,
        rowspan: f.attrs.rowspan - d.n
      })
    } else if (d.type == 'colwidth mismatch') {
      const f = e.nodeAt(d.pos)
      if (!f) continue
      r.setNodeMarkup(r.mapping.map(n + 1 + d.pos), null, {
        ...f.attrs,
        colwidth: d.colwidth
      })
    }
  }
  let s, l
  for (let u = 0; u < o.length; u++) o[u] && (s == null && (s = u), (l = u))
  for (let u = 0, d = n + 1; u < i.height; u++) {
    const f = e.child(u)
    const h = d + f.nodeSize
    const m = o[u]
    if (m > 0) {
      let b = 'cell'
      f.firstChild && (b = f.firstChild.type.spec.tableRole)
      const g = []
      for (let w = 0; w < m; w++) {
        const S = sn(t.schema)[b].createAndFill()
        S && g.push(S)
      }
      const E = (u == 0 || s == u - 1) && l == u ? d + 1 : h - 1
      r.insert(r.mapping.map(E), g)
    }
    d = h
  }
  return r.setMeta(mP, { fixTables: !0 })
}
function br (t) {
  const e = t.selection
  const n = Ac(t)
  const r = n.node(-1)
  const i = n.start(-1)
  const o = mt.get(r)
  return {
    ...(e instanceof et
      ? o.rectBetween(e.$anchorCell.pos - i, e.$headCell.pos - i)
      : o.findCell(n.pos - i)),
    tableStart: i,
    map: o,
    table: r
  }
}
function qv (t, { map: e, tableStart: n, table: r }, i) {
  let o = i > 0 ? -1 : 0
  cP(e, r, i + o) && (o = i == 0 || i == e.width ? null : 0)
  for (let s = 0; s < e.height; s++) {
    const l = s * e.width + i
    if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) {
      const u = e.map[l]
      const d = r.nodeAt(u)
      t.setNodeMarkup(
        t.mapping.map(n + u),
        null,
        Kv(d.attrs, i - e.colCount(u))
      ),
      (s += d.attrs.rowspan - 1)
    } else {
      const u =
                o == null
                  ? sn(r.type.schema).cell
                  : r.nodeAt(e.map[l + o]).type
      const d = e.positionAt(s, i, r)
      t.insert(t.mapping.map(n + d), u.createAndFill())
    }
  }
  return t
}
function Yv (t, e) {
  if (!or(t)) return !1
  if (e) {
    const n = br(t)
    e(qv(t.tr, n, n.left))
  }
  return !0
}
function Jv (t, e) {
  if (!or(t)) return !1
  if (e) {
    const n = br(t)
    e(qv(t.tr, n, n.right))
  }
  return !0
}
function bP (t, { map: e, table: n, tableStart: r }, i) {
  const o = t.mapping.maps.length
  for (let s = 0; s < e.height;) {
    const l = s * e.width + i
    const u = e.map[l]
    const d = n.nodeAt(u)
    const f = d.attrs
    if (
      (i > 0 && e.map[l - 1] == u) ||
            (i < e.width - 1 && e.map[l + 1] == u)
    ) {
      t.setNodeMarkup(
        t.mapping.slice(o).map(r + u),
        null,
        io(f, i - e.colCount(u))
      )
    } else {
      const h = t.mapping.slice(o).map(r + u)
      t.delete(h, h + d.nodeSize)
    }
    s += f.rowspan
  }
}
function Xv (t, e) {
  if (!or(t)) return !1
  if (e) {
    const n = br(t)
    const r = t.tr
    if (n.left == 0 && n.right == n.map.width) return !1
    for (let i = n.right - 1; bP(r, n, i), i != n.left; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc
      if (!o) throw RangeError('No table found');
      (n.table = o), (n.map = mt.get(o))
    }
    e(r)
  }
  return !0
}
function yP (t, e, n) {
  let r
  const i = sn(e.type.schema).header_cell
  for (let o = 0; o < t.width; o++) {
    if (
      ((r = e.nodeAt(t.map[o + n * t.width])) == null
        ? void 0
        : r.type) != i
    ) {
      return !1
    }
  }
  return !0
}
function Zv (t, { map: e, tableStart: n, table: r }, i) {
  let o
  let s = n
  for (let d = 0; d < i; d++) s += r.child(d).nodeSize
  const l = []
  let u = i > 0 ? -1 : 0
  yP(e, r, i + u) && (u = i == 0 || i == e.height ? null : 0)
  for (let d = 0, f = e.width * i; d < e.width; d++, f++) {
    if (i > 0 && i < e.height && e.map[f] == e.map[f - e.width]) {
      const h = e.map[f]
      const m = r.nodeAt(h).attrs
      t.setNodeMarkup(n + h, null, { ...m, rowspan: m.rowspan + 1 }),
      (d += m.colspan - 1)
    } else {
      const h =
                u == null
                  ? sn(r.type.schema).cell
                  : (o = r.nodeAt(e.map[f + u * e.width])) == null
                      ? void 0
                      : o.type
      const m = h?.createAndFill()
      m && l.push(m)
    }
  }
  return t.insert(s, sn(r.type.schema).row.create(null, l)), t
}
function jv (t, e) {
  if (!or(t)) return !1
  if (e) {
    const n = br(t)
    e(Zv(t.tr, n, n.top))
  }
  return !0
}
function Qv (t, e) {
  if (!or(t)) return !1
  if (e) {
    const n = br(t)
    e(Zv(t.tr, n, n.bottom))
  }
  return !0
}
function EP (t, { map: e, table: n, tableStart: r }, i) {
  let o = 0
  for (let d = 0; d < i; d++) o += n.child(d).nodeSize
  const s = o + n.child(i).nodeSize
  const l = t.mapping.maps.length
  t.delete(o + r, s + r)
  const u = new Set()
  for (let d = 0, f = i * e.width; d < e.width; d++, f++) {
    const h = e.map[f]
    if (!u.has(h)) {
      if ((u.add(h), i > 0 && h == e.map[f - e.width])) {
        const m = n.nodeAt(h).attrs
        t.setNodeMarkup(t.mapping.slice(l).map(h + r), null, {
          ...m,
          rowspan: m.rowspan - 1
        }),
        (d += m.colspan - 1)
      } else if (i < e.height && h == e.map[f + e.width]) {
        const m = n.nodeAt(h)
        const b = m.attrs
        const g = m.type.create(
          { ...b, rowspan: m.attrs.rowspan - 1 },
          m.content
        )
        const E = e.positionAt(i + 1, d, n)
        t.insert(t.mapping.slice(l).map(r + E), g),
        (d += b.colspan - 1)
      }
    }
  }
}
function ew (t, e) {
  if (!or(t)) return !1
  if (e) {
    const n = br(t)
    const r = t.tr
    if (n.top == 0 && n.bottom == n.map.height) return !1
    for (let i = n.bottom - 1; EP(r, n, i), i != n.top; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc
      if (!o) throw RangeError('No table found');
      (n.table = o), (n.map = mt.get(n.table))
    }
    e(r)
  }
  return !0
}
function Dv (t) {
  const e = t.content
  return (
    e.childCount == 1 &&
        e.child(0).isTextblock &&
        e.child(0).childCount == 0
  )
}
function vP ({ width: t, height: e, map: n }, r) {
  let i = r.top * t + r.left
  let o = i
  let s = (r.bottom - 1) * t + r.left
  let l = i + (r.right - r.left - 1)
  for (let u = r.top; u < r.bottom; u++) {
    if (
      (r.left > 0 && n[o] == n[o - 1]) ||
            (r.right < t && n[l] == n[l + 1])
    ) {
      return !0
    }
    (o += t), (l += t)
  }
  for (let u = r.left; u < r.right; u++) {
    if (
      (r.top > 0 && n[i] == n[i - t]) ||
            (r.bottom < e && n[s] == n[s + t])
    ) {
      return !0
    }
    i++, s++
  }
  return !1
}
function Jp (t, e) {
  const n = t.selection
  if (!(n instanceof et) || n.$anchorCell.pos == n.$headCell.pos) return !1
  const r = br(t)
  const { map: i } = r
  if (vP(i, r)) return !1
  if (e) {
    const o = t.tr
    const s = {}
    let l = K.empty
    let u
    let d
    for (let f = r.top; f < r.bottom; f++) {
      for (let h = r.left; h < r.right; h++) {
        const m = i.map[f * i.width + h]
        const b = r.table.nodeAt(m)
        if (!(s[m] || !b)) {
          if (((s[m] = !0), u == null)) (u = m), (d = b)
          else {
            Dv(b) || (l = l.append(b.content))
            const g = o.mapping.map(m + r.tableStart)
            o.delete(g, g + b.nodeSize)
          }
        }
      }
    }
    if (u == null || d == null) return !0
    if (
      (o.setNodeMarkup(u + r.tableStart, null, {
        ...Kv(
          d.attrs,
          d.attrs.colspan,
          r.right - r.left - d.attrs.colspan
        ),
        rowspan: r.bottom - r.top
      }),
      l.size)
    ) {
      const f = u + 1 + d.content.size
      const h = Dv(d) ? u + 1 : f
      o.replaceWith(h + r.tableStart, f + r.tableStart, l)
    }
    o.setSelection(new et(o.doc.resolve(u + r.tableStart))), e(o)
  }
  return !0
}
function Xp (t, e) {
  const n = sn(t.schema)
  return wP(({ node: r }) => n[r.type.spec.tableRole])(t, e)
}
function wP (t) {
  return (e, n) => {
    let r
    const i = e.selection
    let o
    let s
    if (i instanceof et) {
      if (i.$anchorCell.pos != i.$headCell.pos) return !1;
      (o = i.$anchorCell.nodeAfter), (s = i.$anchorCell.pos)
    } else {
      if (((o = sP(i.$from)), !o)) return !1
      s = (r = Xo(i.$from)) == null ? void 0 : r.pos
    }
    if (
      o == null ||
            s == null ||
            (o.attrs.colspan == 1 && o.attrs.rowspan == 1)
    ) {
      return !1
    }
    if (n) {
      let l = o.attrs
      const u = []
      const d = l.colwidth
      l.rowspan > 1 && (l = { ...l, rowspan: 1 }),
      l.colspan > 1 && (l = { ...l, colspan: 1 })
      const f = br(e)
      const h = e.tr
      for (let b = 0; b < f.right - f.left; b++) {
        u.push(d ? { ...l, colwidth: d && d[b] ? [d[b]] : null } : l)
      }
      let m
      for (let b = f.top; b < f.bottom; b++) {
        let g = f.map.positionAt(b, f.left, f.table)
        b == f.top && (g += o.nodeSize)
        for (let E = f.left, w = 0; E < f.right; E++, w++) {
          (E == f.left && b == f.top) ||
                        h.insert(
                          (m = h.mapping.map(g + f.tableStart, 1)),
                          t({ node: o, row: b, col: E }).createAndFill(u[w])
                        )
        }
      }
      h.setNodeMarkup(s, t({ node: o, row: f.top, col: f.left }), u[0]),
      i instanceof et &&
                    h.setSelection(
                      new et(
                        h.doc.resolve(i.$anchorCell.pos),
                        m ? h.doc.resolve(m) : void 0
                      )
                    ),
      n(h)
    }
    return !0
  }
}
function tw (t, e) {
  return function (n, r) {
    if (!or(n)) return !1
    const i = Ac(n)
    if (i.nodeAfter.attrs[t] === e) return !1
    if (r) {
      const o = n.tr
      n.selection instanceof et
        ? n.selection.forEachCell((s, l) => {
          s.attrs[t] !== e &&
                          o.setNodeMarkup(l, null, { ...s.attrs, [t]: e })
        })
        : o.setNodeMarkup(i.pos, null, {
          ...i.nodeAfter.attrs,
          [t]: e
        }),
      r(o)
    }
    return !0
  }
}
function xP (t) {
  return function (e, n) {
    if (!or(e)) return !1
    if (n) {
      const r = sn(e.schema)
      const i = br(e)
      const o = e.tr
      const s = i.map.cellsInRect(
        t == 'column'
          ? {
              left: i.left,
              top: 0,
              right: i.right,
              bottom: i.map.height
            }
          : t == 'row'
            ? {
                left: 0,
                top: i.top,
                right: i.map.width,
                bottom: i.bottom
              }
            : i
      )
      const l = s.map((u) => i.table.nodeAt(u))
      for (let u = 0; u < s.length; u++) {
        l[u].type == r.header_cell &&
                    o.setNodeMarkup(i.tableStart + s[u], r.cell, l[u].attrs)
      }
      if (o.steps.length == 0) {
        for (let u = 0; u < s.length; u++) {
          o.setNodeMarkup(
            i.tableStart + s[u],
            r.header_cell,
            l[u].attrs
          )
        }
      }
      n(o)
    }
    return !0
  }
}
function Lv (t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == 'row' ? e.map.width : 1,
    bottom: t == 'column' ? e.map.height : 1
  })
  for (let i = 0; i < r.length; i++) {
    const o = e.table.nodeAt(r[i])
    if (o && o.type !== n.header_cell) return !1
  }
  return !0
}
function Zo (t, e) {
  return (
    (e = e || { useDeprecatedLogic: !1 }),
    e.useDeprecatedLogic
      ? xP(t)
      : function (n, r) {
        if (!or(n)) return !1
        if (r) {
          const i = sn(n.schema)
          const o = br(n)
          const s = n.tr
          const l = Lv('row', o, i)
          const u = Lv('column', o, i)
          const f = (t === 'column' ? l : t === 'row' ? u : !1)
            ? 1
            : 0
          const h =
                          t == 'column'
                            ? {
                                left: 0,
                                top: f,
                                right: 1,
                                bottom: o.map.height
                              }
                            : t == 'row'
                              ? {
                                  left: f,
                                  top: 0,
                                  right: o.map.width,
                                  bottom: 1
                                }
                              : o
          const m =
                          t == 'column'
                            ? u
                              ? i.cell
                              : i.header_cell
                            : t == 'row'
                              ? l
                                ? i.cell
                                : i.header_cell
                              : i.cell
          o.map.cellsInRect(h).forEach((b) => {
            const g = b + o.tableStart
            const E = s.doc.nodeAt(g)
            E && s.setNodeMarkup(g, m, E.attrs)
          }),
          r(s)
        }
        return !0
      }
  )
}
const CU = Zo('row', { useDeprecatedLogic: !0 })
const AU = Zo('column', { useDeprecatedLogic: !0 })
const nw = Zo('cell', { useDeprecatedLogic: !0 })
function _P (t, e) {
  if (e < 0) {
    const n = t.nodeBefore
    if (n) return t.pos - n.nodeSize
    for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) {
      const o = t.node(-1).child(r)
      const s = o.lastChild
      if (s) return i - 1 - s.nodeSize
      i -= o.nodeSize
    }
  } else {
    if (t.index() < t.parent.childCount - 1) {
      return t.pos + t.nodeAfter.nodeSize
    }
    const n = t.node(-1)
    for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) {
      const o = n.child(r)
      if (o.childCount) return i + 1
      i += o.nodeSize
    }
  }
  return null
}
function Zp (t) {
  return function (e, n) {
    if (!or(e)) return !1
    const r = _P(Ac(e), t)
    if (r == null) return !1
    if (n) {
      const i = e.doc.resolve(r)
      n(e.tr.setSelection(le.between(i, lP(i))).scrollIntoView())
    }
    return !0
  }
}
function rw (t, e) {
  const n = t.selection.$anchor
  for (let r = n.depth; r > 0; r--) {
    if (n.node(r).type.spec.tableRole == 'table') {
      return (
        e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()),
        !0
      )
    }
  }
  return !1
}
function xc (t, e) {
  const n = t.selection
  if (!(n instanceof et)) return !1
  if (e) {
    const r = t.tr
    const i = sn(t.schema).cell.createAndFill().content
    n.forEachCell((o, s) => {
      o.content.eq(i) ||
                r.replace(
                  r.mapping.map(s + 1),
                  r.mapping.map(s + o.nodeSize - 1),
                  new Z(i, 0, 0)
                )
    }),
    r.docChanged && e(r)
  }
  return !0
}
function SP (t) {
  if (!t.size) return null
  let { content: e, openStart: n, openEnd: r } = t
  for (
    ;
    e.childCount == 1 &&
        ((n > 0 && r > 0) || e.child(0).type.spec.tableRole == 'table');

  ) {
    n--, r--, (e = e.child(0).content)
  }
  const i = e.child(0)
  const o = i.type.spec.tableRole
  const s = i.type.schema
  const l = []
  if (o == 'row') {
    for (let u = 0; u < e.childCount; u++) {
      let d = e.child(u).content
      const f = u ? 0 : Math.max(0, n - 1)
      const h = u < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (f || h) && (d = Vp(sn(s).row, new Z(d, f, h)).content), l.push(d)
    }
  } else if (o == 'cell' || o == 'header_cell') {
    l.push(n || r ? Vp(sn(s).row, new Z(e, n, r)).content : e)
  } else return null
  return TP(s, l)
}
function TP (t, e) {
  const n = []
  for (let i = 0; i < e.length; i++) {
    const o = e[i]
    for (let s = o.childCount - 1; s >= 0; s--) {
      const { rowspan: l, colspan: u } = o.child(s).attrs
      for (let d = i; d < i + l; d++) n[d] = (n[d] || 0) + u
    }
  }
  let r = 0
  for (let i = 0; i < n.length; i++) r = Math.max(r, n[i])
  for (let i = 0; i < n.length; i++) {
    if ((i >= e.length && e.push(K.empty), n[i] < r)) {
      const o = sn(t).cell.createAndFill()
      const s = []
      for (let l = n[i]; l < r; l++) s.push(o)
      e[i] = e[i].append(K.from(s))
    }
  }
  return { height: e.length, width: r, rows: e }
}
function Vp (t, e) {
  const n = t.createAndFill()
  return new ui(n).replace(0, n.content.size, e).doc
}
function CP ({ width: t, height: e, rows: n }, r, i) {
  if (t != r) {
    const o = []
    const s = []
    for (let l = 0; l < n.length; l++) {
      const u = n[l]
      const d = []
      for (let f = o[l] || 0, h = 0; f < r; h++) {
        let m = u.child(h % u.childCount)
        f + m.attrs.colspan > r &&
                    (m = m.type.createChecked(
                      io(m.attrs, m.attrs.colspan, f + m.attrs.colspan - r),
                      m.content
                    )),
        d.push(m),
        (f += m.attrs.colspan)
        for (let b = 1; b < m.attrs.rowspan; b++) {
          o[l + b] = (o[l + b] || 0) + m.attrs.colspan
        }
      }
      s.push(K.from(d))
    }
    (n = s), (t = r)
  }
  if (e != i) {
    const o = []
    for (let s = 0, l = 0; s < i; s++, l++) {
      const u = []
      const d = n[l % e]
      for (let f = 0; f < d.childCount; f++) {
        let h = d.child(f)
        s + h.attrs.rowspan > i &&
                    (h = h.type.create(
                      {
                        ...h.attrs,
                        rowspan: Math.max(1, i - h.attrs.rowspan)
                      },
                      h.content
                    )),
        u.push(h)
      }
      o.push(K.from(u))
    }
    (n = o), (e = i)
  }
  return { width: t, height: e, rows: n }
}
function AP (t, e, n, r, i, o, s) {
  const l = t.doc.type.schema
  const u = sn(l)
  let d
  let f
  if (i > e.width) {
    for (let h = 0, m = 0; h < e.height; h++) {
      const b = n.child(h)
      m += b.nodeSize
      const g = []
      let E
      b.lastChild == null || b.lastChild.type == u.cell
        ? (E = d || (d = u.cell.createAndFill()))
        : (E = f || (f = u.header_cell.createAndFill()))
      for (let w = e.width; w < i; w++) g.push(E)
      t.insert(t.mapping.slice(s).map(m - 1 + r), g)
    }
  }
  if (o > e.height) {
    const h = []
    for (
      let g = 0, E = (e.height - 1) * e.width;
      g < Math.max(e.width, i);
      g++
    ) {
      const w =
                g >= e.width
                  ? !1
                  : n.nodeAt(e.map[E + g]).type == u.header_cell
      h.push(
        w
          ? f || (f = u.header_cell.createAndFill())
          : d || (d = u.cell.createAndFill())
      )
    }
    const m = u.row.create(null, K.from(h))
    const b = []
    for (let g = e.height; g < o; g++) b.push(m)
    t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), b)
  }
  return !!(d || f)
}
function Pv (t, e, n, r, i, o, s, l) {
  if (s == 0 || s == e.height) return !1
  let u = !1
  for (let d = i; d < o; d++) {
    const f = s * e.width + d
    const h = e.map[f]
    if (e.map[f - e.width] == h) {
      u = !0
      const m = n.nodeAt(h)
      const { top: b, left: g } = e.findCell(h)
      t.setNodeMarkup(t.mapping.slice(l).map(h + r), null, {
        ...m.attrs,
        rowspan: s - b
      }),
      t.insert(
        t.mapping.slice(l).map(e.positionAt(s, g, n)),
        m.type.createAndFill({
          ...m.attrs,
          rowspan: b + m.attrs.rowspan - s
        })
      ),
      (d += m.attrs.colspan - 1)
    }
  }
  return u
}
function Bv (t, e, n, r, i, o, s, l) {
  if (s == 0 || s == e.width) return !1
  let u = !1
  for (let d = i; d < o; d++) {
    const f = d * e.width + s
    const h = e.map[f]
    if (e.map[f - 1] == h) {
      u = !0
      const m = n.nodeAt(h)
      const b = e.colCount(h)
      const g = t.mapping.slice(l).map(h + r)
      t.setNodeMarkup(
        g,
        null,
        io(m.attrs, s - b, m.attrs.colspan - (s - b))
      ),
      t.insert(
        g + m.nodeSize,
        m.type.createAndFill(io(m.attrs, 0, s - b))
      ),
      (d += m.attrs.rowspan - 1)
    }
  }
  return u
}
function Fv (t, e, n, r, i) {
  let o = n ? t.doc.nodeAt(n - 1) : t.doc
  if (!o) throw new Error('No table found')
  let s = mt.get(o)
  const { top: l, left: u } = r
  const d = u + i.width
  const f = l + i.height
  const h = t.tr
  let m = 0
  function b () {
    if (((o = n ? h.doc.nodeAt(n - 1) : h.doc), !o)) {
      throw new Error('No table found')
    }
    (s = mt.get(o)), (m = h.mapping.maps.length)
  }
  AP(h, s, o, n, d, f, m) && b(),
  Pv(h, s, o, n, u, d, l, m) && b(),
  Pv(h, s, o, n, u, d, f, m) && b(),
  Bv(h, s, o, n, l, f, u, m) && b(),
  Bv(h, s, o, n, l, f, d, m) && b()
  for (let g = l; g < f; g++) {
    const E = s.positionAt(g, u, o)
    const w = s.positionAt(g, d, o)
    h.replace(
      h.mapping.slice(m).map(E + n),
      h.mapping.slice(m).map(w + n),
      new Z(i.rows[g - l], 0, 0)
    )
  }
  b(),
  h.setSelection(
    new et(
      h.doc.resolve(n + s.positionAt(l, u, o)),
      h.doc.resolve(n + s.positionAt(f - 1, d - 1, o))
    )
  ),
  e(h)
}
const MP = ra({
  ArrowLeft: _c('horiz', -1),
  ArrowRight: _c('horiz', 1),
  ArrowUp: _c('vert', -1),
  ArrowDown: _c('vert', 1),
  'Shift-ArrowLeft': Sc('horiz', -1),
  'Shift-ArrowRight': Sc('horiz', 1),
  'Shift-ArrowUp': Sc('vert', -1),
  'Shift-ArrowDown': Sc('vert', 1),
  Backspace: xc,
  'Mod-Backspace': xc,
  Delete: xc,
  'Mod-Delete': xc
})
function Tc (t, e, n) {
  return n.eq(t.selection)
    ? !1
    : (e && e(t.tr.setSelection(n).scrollIntoView()), !0)
}
function _c (t, e) {
  return (n, r, i) => {
    if (!i) return !1
    const o = n.selection
    if (o instanceof et) return Tc(n, r, ue.near(o.$headCell, e))
    if (t != 'horiz' && !o.empty) return !1
    const s = iw(i, t, e)
    if (s == null) return !1
    if (t == 'horiz') {
      return Tc(n, r, ue.near(n.doc.resolve(o.head + e), e))
    }
    {
      const l = n.doc.resolve(s)
      const u = Wv(l, t, e)
      let d
      return (
        u
          ? (d = ue.near(u, 1))
          : e < 0
            ? (d = ue.near(n.doc.resolve(l.before(-1)), -1))
            : (d = ue.near(n.doc.resolve(l.after(-1)), 1)),
        Tc(n, r, d)
      )
    }
  }
}
function Sc (t, e) {
  return (n, r, i) => {
    if (!i) return !1
    const o = n.selection
    let s
    if (o instanceof et) s = o
    else {
      const u = iw(i, t, e)
      if (u == null) return !1
      s = new et(n.doc.resolve(u))
    }
    const l = Wv(s.$headCell, t, e)
    return l ? Tc(n, r, new et(s.$anchorCell, l)) : !1
  }
}
function NP (t, e) {
  const n = t.state.doc
  const r = Xo(n.resolve(e))
  return r ? (t.dispatch(t.state.tr.setSelection(new et(r))), !0) : !1
}
function kP (t, e, n) {
  if (!or(t.state)) return !1
  let r = SP(n)
  const i = t.state.selection
  if (i instanceof et) {
    r ||
            (r = {
              width: 1,
              height: 1,
              rows: [K.from(Vp(sn(t.state.schema).cell, n))]
            })
    const o = i.$anchorCell.node(-1)
    const s = i.$anchorCell.start(-1)
    const l = mt
      .get(o)
      .rectBetween(i.$anchorCell.pos - s, i.$headCell.pos - s)
    return (
      (r = CP(r, l.right - l.left, l.bottom - l.top)),
      Fv(t.state, t.dispatch, s, l, r),
      !0
    )
  } else if (r) {
    const o = Ac(t.state)
    const s = o.start(-1)
    return (
      Fv(
        t.state,
        t.dispatch,
        s,
        mt.get(o.node(-1)).findCell(o.pos - s),
        r
      ),
      !0
    )
  } else return !1
}
function OP (t, e) {
  let n
  if (e.ctrlKey || e.metaKey) return
  const r = Hv(t, e.target)
  let i
  if (e.shiftKey && t.state.selection instanceof et) {
    o(t.state.selection.$anchorCell, e), e.preventDefault()
  } else if (
    e.shiftKey &&
        r &&
        (i = Xo(t.state.selection.$anchor)) != null &&
        ((n = zp(t, e)) == null ? void 0 : n.pos) != i.pos
  ) {
    o(i, e), e.preventDefault()
  } else if (!r) return
  function o (u, d) {
    let f = zp(t, d)
    const h = vi.getState(t.state) == null
    if (!f || !qp(u, f)) {
      if (h) f = u
      else return
    }
    const m = new et(u, f)
    if (h || !t.state.selection.eq(m)) {
      const b = t.state.tr.setSelection(m)
      h && b.setMeta(vi, u.pos), t.dispatch(b)
    }
  }
  function s () {
    t.root.removeEventListener('mouseup', s),
    t.root.removeEventListener('dragstart', s),
    t.root.removeEventListener('mousemove', l),
    vi.getState(t.state) != null &&
                t.dispatch(t.state.tr.setMeta(vi, -1))
  }
  function l (u) {
    const d = u
    const f = vi.getState(t.state)
    let h
    if (f != null) h = t.state.doc.resolve(f)
    else if (Hv(t, d.target) != r && ((h = zp(t, e)), !h)) return s()
    h && o(h, d)
  }
  t.root.addEventListener('mouseup', s),
  t.root.addEventListener('dragstart', s),
  t.root.addEventListener('mousemove', l)
}
function iw (t, e, n) {
  if (!(t.state.selection instanceof le)) return null
  const { $head: r } = t.state.selection
  for (let i = r.depth - 1; i >= 0; i--) {
    const o = r.node(i)
    if (
      (n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : o.childCount)
    ) {
      return null
    }
    if (
      o.type.spec.tableRole == 'cell' ||
            o.type.spec.tableRole == 'header_cell'
    ) {
      const l = r.before(i)
      const u =
                e == 'vert'
                  ? n > 0
                    ? 'down'
                    : 'up'
                  : n > 0
                    ? 'right'
                    : 'left'
      return t.endOfTextblock(u) ? l : null
    }
  }
  return null
}
function Hv (t, e) {
  for (; e && e != t.dom; e = e.parentNode) {
    if (e.nodeName == 'TD' || e.nodeName == 'TH') return e
  }
  return null
}
function zp (t, e) {
  const n = t.posAtCoords({ left: e.clientX, top: e.clientY })
  return n && n ? Xo(t.state.doc.resolve(n.pos)) : null
}
const RP = class {
  constructor (t, e) {
    (this.node = t),
    (this.defaultCellMinWidth = e),
    (this.dom = document.createElement('div')),
    (this.dom.className = 'tableWrapper'),
    (this.table = this.dom.appendChild(
      document.createElement('table')
    )),
    this.table.style.setProperty('--default-cell-min-width', `${e}px`),
    (this.colgroup = this.table.appendChild(
      document.createElement('colgroup')
    )),
    Gp(t, this.colgroup, this.table, e),
    (this.contentDOM = this.table.appendChild(
      document.createElement('tbody')
    ))
  }

  update (t) {
    return t.type != this.node.type
      ? !1
      : ((this.node = t),
        Gp(t, this.colgroup, this.table, this.defaultCellMinWidth),
        !0)
  }

  ignoreMutation (t) {
    return (
      t.type == 'attributes' &&
            (t.target == this.table || this.colgroup.contains(t.target))
    )
  }
}
function Gp (t, e, n, r, i, o) {
  let s
  let l = 0
  let u = !0
  let d = e.firstChild
  const f = t.firstChild
  if (f) {
    for (let h = 0, m = 0; h < f.childCount; h++) {
      const { colspan: b, colwidth: g } = f.child(h).attrs
      for (let E = 0; E < b; E++, m++) {
        const w = i == m ? o : g && g[E]
        const S = w ? w + 'px' : ''
        if (((l += w || r), w || (u = !1), d)) {
          d.style.width != S && (d.style.width = S),
          (d = d.nextSibling)
        } else {
          const O = document.createElement('col');
          (O.style.width = S), e.appendChild(O)
        }
      }
    }
    for (; d;) {
      const h = d.nextSibling;
      (s = d.parentNode) == null || s.removeChild(d), (d = h)
    }
    u
      ? ((n.style.width = l + 'px'), (n.style.minWidth = ''))
      : ((n.style.width = ''), (n.style.minWidth = l + 'px'))
  }
}
const On = new ze('tableColumnResizing')
function ow ({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: r = RP,
  lastColumnResizable: i = !0
} = {}) {
  const o = new Oe({
    key: On,
    state: {
      init (s, l) {
        let u, d
        const f =
                    (d = (u = o.spec) == null ? void 0 : u.props) == null
                      ? void 0
                      : d.nodeViews
        const h = sn(l.schema).table.name
        return (
          r && f && (f[h] = (m, b) => new r(m, n, b)), new IP(-1, !1)
        )
      },
      apply (s, l) {
        return l.apply(s)
      }
    },
    props: {
      attributes: (s) => {
        const l = On.getState(s)
        return l && l.activeHandle > -1
          ? { class: 'resize-cursor' }
          : {}
      },
      handleDOMEvents: {
        mousemove: (s, l) => {
          DP(s, l, t, i)
        },
        mouseleave: (s) => {
          LP(s)
        },
        mousedown: (s, l) => {
          PP(s, l, e, n)
        }
      },
      decorations: (s) => {
        const l = On.getState(s)
        if (l && l.activeHandle > -1) return zP(s, l.activeHandle)
      },
      nodeViews: {}
    }
  })
  return o
}
var IP = class Cc {
  constructor (e, n) {
    (this.activeHandle = e), (this.dragging = n)
  }

  apply (e) {
    const n = this
    const r = e.getMeta(On)
    if (r && r.setHandle != null) return new Cc(r.setHandle, !1)
    if (r && r.setDragging !== void 0) {
      return new Cc(n.activeHandle, r.setDragging)
    }
    if (n.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(n.activeHandle, -1)
      return Kp(e.doc.resolve(i)) || (i = -1), new Cc(i, n.dragging)
    }
    return n
  }
}
function DP (t, e, n, r) {
  const i = On.getState(t.state)
  if (i && !i.dragging) {
    const o = FP(e.target)
    let s = -1
    if (o) {
      const { left: l, right: u } = o.getBoundingClientRect()
      e.clientX - l <= n
        ? (s = $v(t, e, 'left', n))
        : u - e.clientX <= n && (s = $v(t, e, 'right', n))
    }
    if (s != i.activeHandle) {
      if (!r && s !== -1) {
        const l = t.state.doc.resolve(s)
        const u = l.node(-1)
        const d = mt.get(u)
        const f = l.start(-1)
        if (
          d.colCount(l.pos - f) + l.nodeAfter.attrs.colspan - 1 ==
                    d.width - 1
        ) {
          return
        }
      }
      sw(t, s)
    }
  }
}
function LP (t) {
  const e = On.getState(t.state)
  e && e.activeHandle > -1 && !e.dragging && sw(t, -1)
}
function PP (t, e, n, r) {
  let i
  const o = (i = t.dom.ownerDocument.defaultView) != null ? i : window
  const s = On.getState(t.state)
  if (!s || s.activeHandle == -1 || s.dragging) return !1
  const l = t.state.doc.nodeAt(s.activeHandle)
  const u = BP(t, s.activeHandle, l.attrs)
  t.dispatch(
    t.state.tr.setMeta(On, {
      setDragging: { startX: e.clientX, startWidth: u }
    })
  )
  function d (h) {
    o.removeEventListener('mouseup', d),
    o.removeEventListener('mousemove', f)
    const m = On.getState(t.state)
    m?.dragging &&
            (HP(t, m.activeHandle, zv(m.dragging, h, n)),
            t.dispatch(t.state.tr.setMeta(On, { setDragging: null })))
  }
  function f (h) {
    if (!h.which) return d(h)
    const m = On.getState(t.state)
    if (m && m.dragging) {
      const b = zv(m.dragging, h, n)
      Uv(t, m.activeHandle, b, r)
    }
  }
  return (
    Uv(t, s.activeHandle, u, r),
    o.addEventListener('mouseup', d),
    o.addEventListener('mousemove', f),
    e.preventDefault(),
    !0
  )
}
function BP (t, e, { colspan: n, colwidth: r }) {
  const i = r && r[r.length - 1]
  if (i) return i
  const o = t.domAtPos(e)
  let l = o.node.childNodes[o.offset].offsetWidth
  let u = n
  if (r) for (let d = 0; d < n; d++) r[d] && ((l -= r[d]), u--)
  return l / u
}
function FP (t) {
  for (; t && t.nodeName != 'TD' && t.nodeName != 'TH';) {
    t =
            t.classList && t.classList.contains('ProseMirror')
              ? null
              : t.parentNode
  }
  return t
}
function $v (t, e, n, r) {
  const i = n == 'right' ? -r : r
  const o = t.posAtCoords({ left: e.clientX + i, top: e.clientY })
  if (!o) return -1
  const { pos: s } = o
  const l = Xo(t.state.doc.resolve(s))
  if (!l) return -1
  if (n == 'right') return l.pos
  const u = mt.get(l.node(-1))
  const d = l.start(-1)
  const f = u.map.indexOf(l.pos - d)
  return f % u.width == 0 ? -1 : d + u.map[f - 1]
}
function zv (t, e, n) {
  const r = e.clientX - t.startX
  return Math.max(n, t.startWidth + r)
}
function sw (t, e) {
  t.dispatch(t.state.tr.setMeta(On, { setHandle: e }))
}
function HP (t, e, n) {
  const r = t.state.doc.resolve(e)
  const i = r.node(-1)
  const o = mt.get(i)
  const s = r.start(-1)
  const l = o.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1
  const u = t.state.tr
  for (let d = 0; d < o.height; d++) {
    const f = d * o.width + l
    if (d && o.map[f] == o.map[f - o.width]) continue
    const h = o.map[f]
    const m = i.nodeAt(h).attrs
    const b = m.colspan == 1 ? 0 : l - o.colCount(h)
    if (m.colwidth && m.colwidth[b] == n) continue
    const g = m.colwidth ? m.colwidth.slice() : $P(m.colspan);
    (g[b] = n), u.setNodeMarkup(s + h, null, { ...m, colwidth: g })
  }
  u.docChanged && t.dispatch(u)
}
function Uv (t, e, n, r) {
  const i = t.state.doc.resolve(e)
  const o = i.node(-1)
  const s = i.start(-1)
  const l = mt.get(o).colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1
  let u = t.domAtPos(i.start(-1)).node
  for (; u && u.nodeName != 'TABLE';) u = u.parentNode
  u && Gp(o, u.firstChild, u, r, l, n)
}
function $P (t) {
  return Array(t).fill(0)
}
function zP (t, e) {
  let n
  const r = []
  const i = t.doc.resolve(e)
  const o = i.node(-1)
  if (!o) return ot.empty
  const s = mt.get(o)
  const l = i.start(-1)
  const u = s.colCount(i.pos - l) + i.nodeAfter.attrs.colspan - 1
  for (let d = 0; d < s.height; d++) {
    const f = u + d * s.width
    if (
      (u == s.width - 1 || s.map[f] != s.map[f + 1]) &&
            (d == 0 || s.map[f] != s.map[f - s.width])
    ) {
      const h = s.map[f]
      const m = l + h + o.nodeAt(h).nodeSize - 1
      const b = document.createElement('div');
      (b.className = 'column-resize-handle'),
      (n = On.getState(t)) != null &&
                    n.dragging &&
                    r.push(
                      wt.node(l + h, l + h + o.nodeAt(h).nodeSize, {
                        class: 'column-resize-dragging'
                      })
                    ),
      r.push(wt.widget(m, b))
    }
  }
  return ot.create(t.doc, r)
}
function aw ({ allowTableNodeSelection: t = !1 } = {}) {
  return new Oe({
    key: vi,
    state: {
      init () {
        return null
      },
      apply (e, n) {
        const r = e.getMeta(vi)
        if (r != null) return r == -1 ? null : r
        if (n == null || !e.docChanged) return n
        const { deleted: i, pos: o } = e.mapping.mapResult(n)
        return i ? null : o
      }
    },
    props: {
      decorations: dP,
      handleDOMEvents: { mousedown: OP },
      createSelectionBetween (e) {
        return vi.getState(e.state) != null ? e.state.selection : null
      },
      handleTripleClick: NP,
      handleKeyDown: MP,
      handlePaste: kP
    },
    appendTransaction (e, n, r) {
      return hP(r, Yp(r, n), t)
    }
  })
}
function jp (t, e) {
  return e ? ['width', `${Math.max(e, t)}px`] : ['min-width', `${t}px`]
}
function lw (t, e, n, r, i, o) {
  let s
  let l = 0
  let u = !0
  let d = e.firstChild
  const f = t.firstChild
  if (f !== null) {
    for (let h = 0, m = 0; h < f.childCount; h += 1) {
      const { colspan: b, colwidth: g } = f.child(h).attrs
      for (let E = 0; E < b; E += 1, m += 1) {
        const w = i === m ? o : g && g[E]
        const S = w ? `${w}px` : ''
        if (((l += w || r), w || (u = !1), d)) {
          if (d.style.width !== S) {
            const [O, k] = jp(r, w)
            d.style.setProperty(O, k)
          }
          d = d.nextSibling
        } else {
          const O = document.createElement('col')
          const [k, T] = jp(r, w)
          O.style.setProperty(k, T), e.appendChild(O)
        }
      }
    }
  }
  for (; d;) {
    const h = d.nextSibling;
    (s = d.parentNode) === null || s === void 0 || s.removeChild(d),
    (d = h)
  }
  u
    ? ((n.style.width = `${l}px`), (n.style.minWidth = ''))
    : ((n.style.width = ''), (n.style.minWidth = `${l}px`))
}
const Qp = class {
  constructor (e, n) {
    (this.node = e),
    (this.cellMinWidth = n),
    (this.dom = document.createElement('div')),
    (this.dom.className = 'tableWrapper'),
    (this.table = this.dom.appendChild(
      document.createElement('table')
    )),
    (this.colgroup = this.table.appendChild(
      document.createElement('colgroup')
    )),
    lw(e, this.colgroup, this.table, n),
    (this.contentDOM = this.table.appendChild(
      document.createElement('tbody')
    ))
  }

  update (e) {
    return e.type !== this.node.type
      ? !1
      : ((this.node = e),
        lw(e, this.colgroup, this.table, this.cellMinWidth),
        !0)
  }

  ignoreMutation (e) {
    return (
      e.type === 'attributes' &&
            (e.target === this.table || this.colgroup.contains(e.target))
    )
  }
}
function UP (t, e, n, r) {
  let i = 0
  let o = !0
  const s = []
  const l = t.firstChild
  if (!l) return {}
  for (let h = 0, m = 0; h < l.childCount; h += 1) {
    const { colspan: b, colwidth: g } = l.child(h).attrs
    for (let E = 0; E < b; E += 1, m += 1) {
      const w = n === m ? r : g && g[E];
      (i += w || e), w || (o = !1)
      const [S, O] = jp(e, w)
      s.push(['col', { style: `${S}: ${O}` }])
    }
  }
  const u = o ? `${i}px` : ''
  const d = o ? '' : `${i}px`
  return {
    colgroup: ['colgroup', {}, ...s],
    tableWidth: u,
    tableMinWidth: d
  }
}
function cw (t, e) {
  return e ? t.createChecked(null, e) : t.createAndFill()
}
function WP (t) {
  if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes
  const e = {}
  return (
    Object.keys(t.nodes).forEach((n) => {
      const r = t.nodes[n]
      r.spec.tableRole && (e[r.spec.tableRole] = r)
    }),
    (t.cached.tableNodeTypes = e),
    e
  )
}
function KP (t, e, n, r, i) {
  const o = WP(t)
  const s = []
  const l = []
  for (let d = 0; d < n; d += 1) {
    const f = cw(o.cell, i)
    if ((f && l.push(f), r)) {
      const h = cw(o.header_cell, i)
      h && s.push(h)
    }
  }
  const u = []
  for (let d = 0; d < e; d += 1) {
    u.push(o.row.createChecked(null, r && d === 0 ? s : l))
  }
  return o.table.createChecked(null, u)
}
function VP (t) {
  return t instanceof et
}
const Mc = ({ editor: t }) => {
  const { selection: e } = t.state
  if (!VP(e)) return !1
  let n = 0
  const r = Np(e.ranges[0].$from, (o) => o.type.name === 'table')
  return (
    r?.node.descendants((o) => {
      if (o.type.name === 'table') return !1;
      ['tableCell', 'tableHeader'].includes(o.type.name) && (n += 1)
    }),
    n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1
  )
}
const uw = ce.create({
  name: 'table',
  addOptions () {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      View: Qp,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    }
  },
  content: 'tableRow+',
  tableRole: 'table',
  isolating: !0,
  group: 'block',
  parseHTML () {
    return [{ tag: 'table' }]
  },
  renderHTML ({ node: t, HTMLAttributes: e }) {
    const {
      colgroup: n,
      tableWidth: r,
      tableMinWidth: i
    } = UP(t, this.options.cellMinWidth)
    return [
      'table',
      ee(this.options.HTMLAttributes, e, {
        style: r ? `width: ${r}` : `min-width: ${i}`
      }),
      n,
      ['tbody', 0]
    ]
  },
  addCommands () {
    return {
      insertTable:
                ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) =>
                  ({ tr: r, dispatch: i, editor: o }) => {
                    const s = KP(o.schema, t, e, n)
                    if (i) {
                      const l = r.selection.from + 1
                      r.replaceSelectionWith(s)
                        .scrollIntoView()
                        .setSelection(le.near(r.doc.resolve(l)))
                    }
                    return !0
                  },
      addColumnBefore:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Yv(t, e),
      addColumnAfter:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Jv(t, e),
      deleteColumn:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Xv(t, e),
      addRowBefore:
                () =>
                  ({ state: t, dispatch: e }) =>
                    jv(t, e),
      addRowAfter:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Qv(t, e),
      deleteRow:
                () =>
                  ({ state: t, dispatch: e }) =>
                    ew(t, e),
      deleteTable:
                () =>
                  ({ state: t, dispatch: e }) =>
                    rw(t, e),
      mergeCells:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Jp(t, e),
      splitCell:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Xp(t, e),
      toggleHeaderColumn:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Zo('column')(t, e),
      toggleHeaderRow:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Zo('row')(t, e),
      toggleHeaderCell:
                () =>
                  ({ state: t, dispatch: e }) =>
                    nw(t, e),
      mergeOrSplit:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Jp(t, e) ? !0 : Xp(t, e),
      setCellAttribute:
                (t, e) =>
                  ({ state: n, dispatch: r }) =>
                    tw(t, e)(n, r),
      goToNextCell:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Zp(1)(t, e),
      goToPreviousCell:
                () =>
                  ({ state: t, dispatch: e }) =>
                    Zp(-1)(t, e),
      fixTables:
                () =>
                  ({ state: t, dispatch: e }) => (e && Yp(t), !0),
      setCellSelection:
                (t) =>
                  ({ tr: e, dispatch: n }) => {
                    if (n) {
                      const r = et.create(e.doc, t.anchorCell, t.headCell)
                      e.setSelection(r)
                    }
                    return !0
                  }
    }
  },
  addKeyboardShortcuts () {
    return {
      Tab: () =>
        this.editor.commands.goToNextCell()
          ? !0
          : this.editor.can().addRowAfter()
            ? this.editor.chain().addRowAfter().goToNextCell().run()
            : !1,
      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),
      Backspace: Mc,
      'Mod-Backspace': Mc,
      Delete: Mc,
      'Mod-Delete': Mc
    }
  },
  addProseMirrorPlugins () {
    return [
      ...(this.options.resizable && this.editor.isEditable
        ? [
            ow({
              handleWidth: this.options.handleWidth,
              cellMinWidth: this.options.cellMinWidth,
              defaultCellMinWidth: this.options.cellMinWidth,
              View: this.options.View,
              lastColumnResizable: this.options.lastColumnResizable
            })
          ]
        : []),
      aw({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ]
  },
  extendNodeSchema (t) {
    const e = { name: t.name, options: t.options, storage: t.storage }
    return { tableRole: Te(re(t, 'tableRole', e)) }
  }
})
const dw = ce.create({
  name: 'tableCell',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  content: 'block+',
  addAttributes () {
    return {
      colspan: { default: 1 },
      rowspan: { default: 1 },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute('colwidth')
          return e ? e.split(',').map((r) => parseInt(r, 10)) : null
        }
      }
    }
  },
  tableRole: 'cell',
  isolating: !0,
  parseHTML () {
    return [{ tag: 'td' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['td', ee(this.options.HTMLAttributes, t), 0]
  }
})
const fw = ce.create({
  name: 'tableHeader',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  content: 'block+',
  addAttributes () {
    return {
      colspan: { default: 1 },
      rowspan: { default: 1 },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute('colwidth')
          return e ? e.split(',').map((r) => parseInt(r, 10)) : null
        }
      }
    }
  },
  tableRole: 'header_cell',
  isolating: !0,
  parseHTML () {
    return [{ tag: 'th' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['th', ee(this.options.HTMLAttributes, t), 0]
  }
})
const pw = ce.create({
  name: 'tableRow',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  content: '(tableCell | tableHeader)*',
  tableRole: 'row',
  parseHTML () {
    return [{ tag: 'tr' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['tr', ee(this.options.HTMLAttributes, t), 0]
  }
})
const hw = ce.create({ name: 'text', group: 'inline' })
const mw = st.create({
  name: 'underline',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [
      { tag: 'u' },
      {
        style: 'text-decoration',
        consuming: !1,
        getAttrs: (t) => (t.includes('underline') ? {} : !1)
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['u', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setUnderline:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleUnderline:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetUnderline:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-u': () => this.editor.commands.toggleUnderline(),
      'Mod-U': () => this.editor.commands.toggleUnderline()
    }
  }
})
const GP = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/
const qP = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g
const gw = st.create({
  name: 'highlight',
  addOptions () {
    return { multicolor: !1, HTMLAttributes: {} }
  },
  addAttributes () {
    return this.options.multicolor
      ? {
          color: {
            default: null,
            parseHTML: (t) =>
              t.getAttribute('data-color') ||
                          t.style.backgroundColor,
            renderHTML: (t) =>
              t.color
                ? {
                    'data-color': t.color,
                    style: `background-color: ${t.color}; color: inherit`
                  }
                : {}
          }
        }
      : {}
  },
  parseHTML () {
    return [{ tag: 'mark' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['mark', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setHighlight:
                (t) =>
                  ({ commands: e }) =>
                    e.setMark(this.name, t),
      toggleHighlight:
                (t) =>
                  ({ commands: e }) =>
                    e.toggleMark(this.name, t),
      unsetHighlight:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-Shift-h': () => this.editor.commands.toggleHighlight()
    }
  },
  addInputRules () {
    return [Vn({ find: GP, type: this.type })]
  },
  addPasteRules () {
    return [xn({ find: qP, type: this.type })]
  }
})
const gt = 'top'
const Dt = 'bottom'
const Mt = 'right'
const xt = 'left'
const Nc = 'auto'
const wi = [gt, Dt, Mt, xt]
const Kr = 'start'
const oo = 'end'
const bw = 'clippingParents'
const kc = 'viewport'
const jo = 'popper'
const yw = 'reference'
const eh = wi.reduce(function (t, e) {
  return t.concat([e + '-' + Kr, e + '-' + oo])
}, [])
const Oc = [].concat(wi, [Nc]).reduce(function (t, e) {
  return t.concat([e, e + '-' + Kr, e + '-' + oo])
}, [])
const YP = 'beforeRead'
const JP = 'read'
const XP = 'afterRead'
const ZP = 'beforeMain'
const jP = 'main'
const QP = 'afterMain'
const eB = 'beforeWrite'
const tB = 'write'
const nB = 'afterWrite'
const Ew = [YP, JP, XP, ZP, jP, QP, eB, tB, nB]
function Wt (t) {
  return t ? (t.nodeName || '').toLowerCase() : null
}
function ct (t) {
  if (t == null) return window
  if (t.toString() !== '[object Window]') {
    const e = t.ownerDocument
    return (e && e.defaultView) || window
  }
  return t
}
function Gn (t) {
  const e = ct(t).Element
  return t instanceof e || t instanceof Element
}
function Lt (t) {
  const e = ct(t).HTMLElement
  return t instanceof e || t instanceof HTMLElement
}
function Qo (t) {
  if (typeof ShadowRoot > 'u') return !1
  const e = ct(t).ShadowRoot
  return t instanceof e || t instanceof ShadowRoot
}
function rB (t) {
  const e = t.state
  Object.keys(e.elements).forEach(function (n) {
    const r = e.styles[n] || {}
    const i = e.attributes[n] || {}
    const o = e.elements[n]
    !Lt(o) ||
            !Wt(o) ||
            (Object.assign(o.style, r),
            Object.keys(i).forEach(function (s) {
              const l = i[s]
              l === !1
                ? o.removeAttribute(s)
                : o.setAttribute(s, l === !0 ? '' : l)
            }))
  })
}
function iB (t) {
  const e = t.state
  const n = {
    popper: {
      position: e.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: { position: 'absolute' },
    reference: {}
  }
  return (
    Object.assign(e.elements.popper.style, n.popper),
    (e.styles = n),
    e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
    function () {
      Object.keys(e.elements).forEach(function (r) {
        const i = e.elements[r]
        const o = e.attributes[r] || {}
        const s = Object.keys(
          e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]
        )
        const l = s.reduce(function (u, d) {
          return (u[d] = ''), u
        }, {})
        !Lt(i) ||
                    !Wt(i) ||
                    (Object.assign(i.style, l),
                    Object.keys(o).forEach(function (u) {
                      i.removeAttribute(u)
                    }))
      })
    }
  )
}
const aa = {
  name: 'applyStyles',
  enabled: !0,
  phase: 'write',
  fn: rB,
  effect: iB,
  requires: ['computeStyles']
}
function Kt (t) {
  return t.split('-')[0]
}
const sr = Math.max
const so = Math.min
const Vr = Math.round
function es () {
  const t = navigator.userAgentData
  return t != null && t.brands && Array.isArray(t.brands)
    ? t.brands
      .map(function (e) {
        return e.brand + '/' + e.version
      })
      .join(' ')
    : navigator.userAgent
}
function la () {
  return !/^((?!chrome|android).)*safari/i.test(es())
}
function qn (t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1)
  const r = t.getBoundingClientRect()
  let i = 1
  let o = 1
  e &&
        Lt(t) &&
        ((i = (t.offsetWidth > 0 && Vr(r.width) / t.offsetWidth) || 1),
        (o = (t.offsetHeight > 0 && Vr(r.height) / t.offsetHeight) || 1))
  const s = Gn(t) ? ct(t) : window
  const l = s.visualViewport
  const u = !la() && n
  const d = (r.left + (u && l ? l.offsetLeft : 0)) / i
  const f = (r.top + (u && l ? l.offsetTop : 0)) / o
  const h = r.width / i
  const m = r.height / o
  return {
    width: h,
    height: m,
    top: f,
    right: d + h,
    bottom: f + m,
    left: d,
    x: d,
    y: f
  }
}
function ao (t) {
  const e = qn(t)
  let n = t.offsetWidth
  let r = t.offsetHeight
  return (
    Math.abs(e.width - n) <= 1 && (n = e.width),
    Math.abs(e.height - r) <= 1 && (r = e.height),
    { x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
  )
}
function ca (t, e) {
  const n = e.getRootNode && e.getRootNode()
  if (t.contains(e)) return !0
  if (n && Qo(n)) {
    let r = e
    do {
      if (r && t.isSameNode(r)) return !0
      r = r.parentNode || r.host
    } while (r)
  }
  return !1
}
function gn (t) {
  return ct(t).getComputedStyle(t)
}
function th (t) {
  return ['table', 'td', 'th'].indexOf(Wt(t)) >= 0
}
function Jt (t) {
  return ((Gn(t) ? t.ownerDocument : t.document) || window.document)
    .documentElement
}
function Gr (t) {
  return Wt(t) === 'html'
    ? t
    : t.assignedSlot || t.parentNode || (Qo(t) ? t.host : null) || Jt(t)
}
function vw (t) {
  return !Lt(t) || gn(t).position === 'fixed' ? null : t.offsetParent
}
function oB (t) {
  const e = /firefox/i.test(es())
  const n = /Trident/i.test(es())
  if (n && Lt(t)) {
    const r = gn(t)
    if (r.position === 'fixed') return null
  }
  let i = Gr(t)
  for (
    Qo(i) && (i = i.host);
    Lt(i) && ['html', 'body'].indexOf(Wt(i)) < 0;

  ) {
    const o = gn(i)
    if (
      o.transform !== 'none' ||
            o.perspective !== 'none' ||
            o.contain === 'paint' ||
            ['transform', 'perspective'].indexOf(o.willChange) !== -1 ||
            (e && o.willChange === 'filter') ||
            (e && o.filter && o.filter !== 'none')
    ) {
      return i
    }
    i = i.parentNode
  }
  return null
}
function ar (t) {
  for (
    var e = ct(t), n = vw(t);
    n && th(n) && gn(n).position === 'static';

  ) {
    n = vw(n)
  }
  return n &&
        (Wt(n) === 'html' || (Wt(n) === 'body' && gn(n).position === 'static'))
    ? e
    : n || oB(t) || e
}
function lo (t) {
  return ['top', 'bottom'].indexOf(t) >= 0 ? 'x' : 'y'
}
function co (t, e, n) {
  return sr(t, so(e, n))
}
function ww (t, e, n) {
  const r = co(t, e, n)
  return r > n ? n : r
}
function ua () {
  return { top: 0, right: 0, bottom: 0, left: 0 }
}
function da (t) {
  return Object.assign({}, ua(), t)
}
function fa (t, e) {
  return e.reduce(function (n, r) {
    return (n[r] = t), n
  }, {})
}
const sB = function (e, n) {
  return (
    (e =
            typeof e === 'function'
              ? e(Object.assign({}, n.rects, { placement: n.placement }))
              : e),
    da(typeof e !== 'number' ? e : fa(e, wi))
  )
}
function aB (t) {
  let e
  const n = t.state
  const r = t.name
  const i = t.options
  const o = n.elements.arrow
  const s = n.modifiersData.popperOffsets
  const l = Kt(n.placement)
  const u = lo(l)
  const d = [xt, Mt].indexOf(l) >= 0
  const f = d ? 'height' : 'width'
  if (!(!o || !s)) {
    const h = sB(i.padding, n)
    const m = ao(o)
    const b = u === 'y' ? gt : xt
    const g = u === 'y' ? Dt : Mt
    const E =
            n.rects.reference[f] +
            n.rects.reference[u] -
            s[u] -
            n.rects.popper[f]
    const w = s[u] - n.rects.reference[u]
    const S = ar(o)
    const O = S
      ? u === 'y'
        ? S.clientHeight || 0
        : S.clientWidth || 0
      : 0
    const k = E / 2 - w / 2
    const T = h[b]
    const P = O - m[f] - h[g]
    const I = O / 2 - m[f] / 2 + k
    const Y = co(T, I, P)
    const ne = u
    n.modifiersData[r] =
            ((e = {}), (e[ne] = Y), (e.centerOffset = Y - I), e)
  }
}
function lB (t) {
  const e = t.state
  const n = t.options
  const r = n.element
  let i = r === void 0 ? '[data-popper-arrow]' : r
  i != null &&
        ((typeof i === 'string' &&
            ((i = e.elements.popper.querySelector(i)), !i)) ||
            (ca(e.elements.popper, i) && (e.elements.arrow = i)))
}
const xw = {
  name: 'arrow',
  enabled: !0,
  phase: 'main',
  fn: aB,
  effect: lB,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
}
function Yn (t) {
  return t.split('-')[1]
}
const cB = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }
function uB (t, e) {
  const n = t.x
  const r = t.y
  const i = e.devicePixelRatio || 1
  return { x: Vr(n * i) / i || 0, y: Vr(r * i) / i || 0 }
}
function _w (t) {
  let e
  const n = t.popper
  const r = t.popperRect
  const i = t.placement
  const o = t.variation
  const s = t.offsets
  const l = t.position
  const u = t.gpuAcceleration
  const d = t.adaptive
  const f = t.roundOffsets
  const h = t.isFixed
  const m = s.x
  let b = m === void 0 ? 0 : m
  const g = s.y
  let E = g === void 0 ? 0 : g
  const w = typeof f === 'function' ? f({ x: b, y: E }) : { x: b, y: E };
  (b = w.x), (E = w.y)
  const S = s.hasOwnProperty('x')
  const O = s.hasOwnProperty('y')
  let k = xt
  let T = gt
  const P = window
  if (d) {
    let I = ar(n)
    let Y = 'clientHeight'
    let ne = 'clientWidth'
    if (
      (I === ct(n) &&
                ((I = Jt(n)),
                gn(I).position !== 'static' &&
                    l === 'absolute' &&
                    ((Y = 'scrollHeight'), (ne = 'scrollWidth'))),
      (I = I),
      i === gt || ((i === xt || i === Mt) && o === oo))
    ) {
      T = Dt
      const q =
                h && I === P && P.visualViewport
                  ? P.visualViewport.height
                  : I[Y];
      (E -= q - r.height), (E *= u ? 1 : -1)
    }
    if (i === xt || ((i === gt || i === Dt) && o === oo)) {
      k = Mt
      const Q =
                h && I === P && P.visualViewport
                  ? P.visualViewport.width
                  : I[ne];
      (b -= Q - r.width), (b *= u ? 1 : -1)
    }
  }
  const fe = Object.assign({ position: l }, d && cB)
  const we = f === !0 ? uB({ x: b, y: E }, ct(n)) : { x: b, y: E }
  if (((b = we.x), (E = we.y), u)) {
    let me
    return Object.assign(
      {},
      fe,
      ((me = {}),
      (me[T] = O ? '0' : ''),
      (me[k] = S ? '0' : ''),
      (me.transform =
                (P.devicePixelRatio || 1) <= 1
                  ? 'translate(' + b + 'px, ' + E + 'px)'
                  : 'translate3d(' + b + 'px, ' + E + 'px, 0)'),
      me)
    )
  }
  return Object.assign(
    {},
    fe,
    ((e = {}),
    (e[T] = O ? E + 'px' : ''),
    (e[k] = S ? b + 'px' : ''),
    (e.transform = ''),
    e)
  )
}
function dB (t) {
  const e = t.state
  const n = t.options
  const r = n.gpuAcceleration
  const i = r === void 0 ? !0 : r
  const o = n.adaptive
  const s = o === void 0 ? !0 : o
  const l = n.roundOffsets
  const u = l === void 0 ? !0 : l
  const d = {
    placement: Kt(e.placement),
    variation: Yn(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === 'fixed'
  }
  e.modifiersData.popperOffsets != null &&
        (e.styles.popper = Object.assign(
          {},
          e.styles.popper,
          _w(
            Object.assign({}, d, {
              offsets: e.modifiersData.popperOffsets,
              position: e.options.strategy,
              adaptive: s,
              roundOffsets: u
            })
          )
        )),
  e.modifiersData.arrow != null &&
            (e.styles.arrow = Object.assign(
              {},
              e.styles.arrow,
              _w(
                Object.assign({}, d, {
                  offsets: e.modifiersData.arrow,
                  position: 'absolute',
                  adaptive: !1,
                  roundOffsets: u
                })
              )
            )),
  (e.attributes.popper = Object.assign({}, e.attributes.popper, {
    'data-popper-placement': e.placement
  }))
}
const Sw = {
  name: 'computeStyles',
  enabled: !0,
  phase: 'beforeWrite',
  fn: dB,
  data: {}
}
const Rc = { passive: !0 }
function fB (t) {
  const e = t.state
  const n = t.instance
  const r = t.options
  const i = r.scroll
  const o = i === void 0 ? !0 : i
  const s = r.resize
  const l = s === void 0 ? !0 : s
  const u = ct(e.elements.popper)
  const d = [].concat(e.scrollParents.reference, e.scrollParents.popper)
  return (
    o &&
            d.forEach(function (f) {
              f.addEventListener('scroll', n.update, Rc)
            }),
    l && u.addEventListener('resize', n.update, Rc),
    function () {
      o &&
                d.forEach(function (f) {
                  f.removeEventListener('scroll', n.update, Rc)
                }),
      l && u.removeEventListener('resize', n.update, Rc)
    }
  )
}
const Tw = {
  name: 'eventListeners',
  enabled: !0,
  phase: 'write',
  fn: function () {},
  effect: fB,
  data: {}
}
const pB = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }
function ts (t) {
  return t.replace(/left|right|bottom|top/g, function (e) {
    return pB[e]
  })
}
const hB = { start: 'end', end: 'start' }
function Ic (t) {
  return t.replace(/start|end/g, function (e) {
    return hB[e]
  })
}
function uo (t) {
  const e = ct(t)
  const n = e.pageXOffset
  const r = e.pageYOffset
  return { scrollLeft: n, scrollTop: r }
}
function fo (t) {
  return qn(Jt(t)).left + uo(t).scrollLeft
}
function nh (t, e) {
  const n = ct(t)
  const r = Jt(t)
  const i = n.visualViewport
  let o = r.clientWidth
  let s = r.clientHeight
  let l = 0
  let u = 0
  if (i) {
    (o = i.width), (s = i.height)
    const d = la();
    (d || (!d && e === 'fixed')) && ((l = i.offsetLeft), (u = i.offsetTop))
  }
  return { width: o, height: s, x: l + fo(t), y: u }
}
function rh (t) {
  let e
  const n = Jt(t)
  const r = uo(t)
  const i = (e = t.ownerDocument) == null ? void 0 : e.body
  const o = sr(
    n.scrollWidth,
    n.clientWidth,
    i ? i.scrollWidth : 0,
    i ? i.clientWidth : 0
  )
  const s = sr(
    n.scrollHeight,
    n.clientHeight,
    i ? i.scrollHeight : 0,
    i ? i.clientHeight : 0
  )
  let l = -r.scrollLeft + fo(t)
  const u = -r.scrollTop
  return (
    gn(i || n).direction === 'rtl' &&
            (l += sr(n.clientWidth, i ? i.clientWidth : 0) - o),
    { width: o, height: s, x: l, y: u }
  )
}
function po (t) {
  const e = gn(t)
  const n = e.overflow
  const r = e.overflowX
  const i = e.overflowY
  return /auto|scroll|overlay|hidden/.test(n + i + r)
}
function Dc (t) {
  return ['html', 'body', '#document'].indexOf(Wt(t)) >= 0
    ? t.ownerDocument.body
    : Lt(t) && po(t)
      ? t
      : Dc(Gr(t))
}
function xi (t, e) {
  let n
  e === void 0 && (e = [])
  const r = Dc(t)
  const i = r === ((n = t.ownerDocument) == null ? void 0 : n.body)
  const o = ct(r)
  const s = i ? [o].concat(o.visualViewport || [], po(r) ? r : []) : r
  const l = e.concat(s)
  return i ? l : l.concat(xi(Gr(s)))
}
function ns (t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  })
}
function mB (t, e) {
  const n = qn(t, !1, e === 'fixed')
  return (
    (n.top = n.top + t.clientTop),
    (n.left = n.left + t.clientLeft),
    (n.bottom = n.top + t.clientHeight),
    (n.right = n.left + t.clientWidth),
    (n.width = t.clientWidth),
    (n.height = t.clientHeight),
    (n.x = n.left),
    (n.y = n.top),
    n
  )
}
function Cw (t, e, n) {
  return e === kc ? ns(nh(t, n)) : Gn(e) ? mB(e, n) : ns(rh(Jt(t)))
}
function gB (t) {
  const e = xi(Gr(t))
  const n = ['absolute', 'fixed'].indexOf(gn(t).position) >= 0
  const r = n && Lt(t) ? ar(t) : t
  return Gn(r)
    ? e.filter(function (i) {
      return Gn(i) && ca(i, r) && Wt(i) !== 'body'
    })
    : []
}
function ih (t, e, n, r) {
  const i = e === 'clippingParents' ? gB(t) : [].concat(e)
  const o = [].concat(i, [n])
  const s = o[0]
  const l = o.reduce(
    function (u, d) {
      const f = Cw(t, d, r)
      return (
        (u.top = sr(f.top, u.top)),
        (u.right = so(f.right, u.right)),
        (u.bottom = so(f.bottom, u.bottom)),
        (u.left = sr(f.left, u.left)),
        u
      )
    },
    Cw(t, s, r)
  )
  return (
    (l.width = l.right - l.left),
    (l.height = l.bottom - l.top),
    (l.x = l.left),
    (l.y = l.top),
    l
  )
}
function pa (t) {
  const e = t.reference
  const n = t.element
  const r = t.placement
  const i = r ? Kt(r) : null
  const o = r ? Yn(r) : null
  const s = e.x + e.width / 2 - n.width / 2
  const l = e.y + e.height / 2 - n.height / 2
  let u
  switch (i) {
    case gt:
      u = { x: s, y: e.y - n.height }
      break
    case Dt:
      u = { x: s, y: e.y + e.height }
      break
    case Mt:
      u = { x: e.x + e.width, y: l }
      break
    case xt:
      u = { x: e.x - n.width, y: l }
      break
    default:
      u = { x: e.x, y: e.y }
  }
  const d = i ? lo(i) : null
  if (d != null) {
    const f = d === 'y' ? 'height' : 'width'
    switch (o) {
      case Kr:
        u[d] = u[d] - (e[f] / 2 - n[f] / 2)
        break
      case oo:
        u[d] = u[d] + (e[f] / 2 - n[f] / 2)
        break
      default:
    }
  }
  return u
}
function lr (t, e) {
  e === void 0 && (e = {})
  const n = e
  const r = n.placement
  const i = r === void 0 ? t.placement : r
  const o = n.strategy
  const s = o === void 0 ? t.strategy : o
  const l = n.boundary
  const u = l === void 0 ? bw : l
  const d = n.rootBoundary
  const f = d === void 0 ? kc : d
  const h = n.elementContext
  const m = h === void 0 ? jo : h
  const b = n.altBoundary
  const g = b === void 0 ? !1 : b
  const E = n.padding
  const w = E === void 0 ? 0 : E
  const S = da(typeof w !== 'number' ? w : fa(w, wi))
  const O = m === jo ? yw : jo
  const k = t.rects.popper
  const T = t.elements[g ? O : m]
  const P = ih(
    Gn(T) ? T : T.contextElement || Jt(t.elements.popper),
    u,
    f,
    s
  )
  const I = qn(t.elements.reference)
  const Y = pa({
    reference: I,
    element: k,
    strategy: 'absolute',
    placement: i
  })
  const ne = ns(Object.assign({}, k, Y))
  const q = m === jo ? ne : I
  const Q = {
    top: P.top - q.top + S.top,
    bottom: q.bottom - P.bottom + S.bottom,
    left: P.left - q.left + S.left,
    right: q.right - P.right + S.right
  }
  const fe = t.modifiersData.offset
  if (m === jo && fe) {
    const we = fe[i]
    Object.keys(Q).forEach(function (me) {
      const Ce = [Mt, Dt].indexOf(me) >= 0 ? 1 : -1
      const ge = [gt, Dt].indexOf(me) >= 0 ? 'y' : 'x'
      Q[me] += we[ge] * Ce
    })
  }
  return Q
}
function oh (t, e) {
  e === void 0 && (e = {})
  const n = e
  const r = n.placement
  const i = n.boundary
  const o = n.rootBoundary
  const s = n.padding
  const l = n.flipVariations
  const u = n.allowedAutoPlacements
  const d = u === void 0 ? Oc : u
  const f = Yn(r)
  const h = f
    ? l
      ? eh
      : eh.filter(function (g) {
        return Yn(g) === f
      })
    : wi
  let m = h.filter(function (g) {
    return d.indexOf(g) >= 0
  })
  m.length === 0 && (m = h)
  const b = m.reduce(function (g, E) {
    return (
      (g[E] = lr(t, {
        placement: E,
        boundary: i,
        rootBoundary: o,
        padding: s
      })[Kt(E)]),
      g
    )
  }, {})
  return Object.keys(b).sort(function (g, E) {
    return b[g] - b[E]
  })
}
function bB (t) {
  if (Kt(t) === Nc) return []
  const e = ts(t)
  return [Ic(t), e, Ic(e)]
}
function yB (t) {
  const e = t.state
  const n = t.options
  const r = t.name
  if (!e.modifiersData[r]._skip) {
    for (
      var i = n.mainAxis,
        o = i === void 0 ? !0 : i,
        s = n.altAxis,
        l = s === void 0 ? !0 : s,
        u = n.fallbackPlacements,
        d = n.padding,
        f = n.boundary,
        h = n.rootBoundary,
        m = n.altBoundary,
        b = n.flipVariations,
        g = b === void 0 ? !0 : b,
        E = n.allowedAutoPlacements,
        w = e.options.placement,
        S = Kt(w),
        O = S === w,
        k = u || (O || !g ? [ts(w)] : bB(w)),
        T = [w].concat(k).reduce(function (je, Ne) {
          return je.concat(
            Kt(Ne) === Nc
              ? oh(e, {
                placement: Ne,
                boundary: f,
                rootBoundary: h,
                padding: d,
                flipVariations: g,
                allowedAutoPlacements: E
              })
              : Ne
          )
        }, []),
        P = e.rects.reference,
        I = e.rects.popper,
        Y = new Map(),
        ne = !0,
        q = T[0],
        Q = 0;
      Q < T.length;
      Q++
    ) {
      const fe = T[Q]
      const we = Kt(fe)
      const me = Yn(fe) === Kr
      const Ce = [gt, Dt].indexOf(we) >= 0
      const ge = Ce ? 'width' : 'height'
      const ye = lr(e, {
        placement: fe,
        boundary: f,
        rootBoundary: h,
        altBoundary: m,
        padding: d
      })
      let A = Ce ? (me ? Mt : xt) : me ? Dt : gt
      P[ge] > I[ge] && (A = ts(A))
      const D = ts(A)
      const z = []
      if (
        (o && z.push(ye[we] <= 0),
        l && z.push(ye[A] <= 0, ye[D] <= 0),
        z.every(function (je) {
          return je
        }))
      ) {
        (q = fe), (ne = !1)
        break
      }
      Y.set(fe, z)
    }
    if (ne) {
      for (
        let j = g ? 3 : 1,
          ie = function (Ne) {
            const Be = T.find(function (_t) {
              const kt = Y.get(_t)
              if (kt) {
                return kt.slice(0, Ne).every(function (Re) {
                  return Re
                })
              }
            })
            if (Be) return (q = Be), 'break'
          },
          xe = j;
        xe > 0;
        xe--
      ) {
        const Ae = ie(xe)
        if (Ae === 'break') break
      }
    }
    e.placement !== q &&
            ((e.modifiersData[r]._skip = !0),
            (e.placement = q),
            (e.reset = !0))
  }
}
const Aw = {
  name: 'flip',
  enabled: !0,
  phase: 'main',
  fn: yB,
  requiresIfExists: ['offset'],
  data: { _skip: !1 }
}
function Mw (t, e, n) {
  return (
    n === void 0 && (n = { x: 0, y: 0 }),
    {
      top: t.top - e.height - n.y,
      right: t.right - e.width + n.x,
      bottom: t.bottom - e.height + n.y,
      left: t.left - e.width - n.x
    }
  )
}
function Nw (t) {
  return [gt, Mt, Dt, xt].some(function (e) {
    return t[e] >= 0
  })
}
function EB (t) {
  const e = t.state
  const n = t.name
  const r = e.rects.reference
  const i = e.rects.popper
  const o = e.modifiersData.preventOverflow
  const s = lr(e, { elementContext: 'reference' })
  const l = lr(e, { altBoundary: !0 })
  const u = Mw(s, r)
  const d = Mw(l, i, o)
  const f = Nw(u)
  const h = Nw(d);
  (e.modifiersData[n] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: d,
    isReferenceHidden: f,
    hasPopperEscaped: h
  }),
  (e.attributes.popper = Object.assign({}, e.attributes.popper, {
    'data-popper-reference-hidden': f,
    'data-popper-escaped': h
  }))
}
const kw = {
  name: 'hide',
  enabled: !0,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: EB
}
function vB (t, e, n) {
  const r = Kt(t)
  const i = [xt, gt].indexOf(r) >= 0 ? -1 : 1
  const o =
        typeof n === 'function' ? n(Object.assign({}, e, { placement: t })) : n
  let s = o[0]
  let l = o[1]
  return (
    (s = s || 0),
    (l = (l || 0) * i),
    [xt, Mt].indexOf(r) >= 0 ? { x: l, y: s } : { x: s, y: l }
  )
}
function wB (t) {
  const e = t.state
  const n = t.options
  const r = t.name
  const i = n.offset
  const o = i === void 0 ? [0, 0] : i
  const s = Oc.reduce(function (f, h) {
    return (f[h] = vB(h, e.rects, o)), f
  }, {})
  const l = s[e.placement]
  const u = l.x
  const d = l.y
  e.modifiersData.popperOffsets != null &&
        ((e.modifiersData.popperOffsets.x += u),
        (e.modifiersData.popperOffsets.y += d)),
  (e.modifiersData[r] = s)
}
const Ow = {
  name: 'offset',
  enabled: !0,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: wB
}
function xB (t) {
  const e = t.state
  const n = t.name
  e.modifiersData[n] = pa({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: 'absolute',
    placement: e.placement
  })
}
const Rw = {
  name: 'popperOffsets',
  enabled: !0,
  phase: 'read',
  fn: xB,
  data: {}
}
function sh (t) {
  return t === 'x' ? 'y' : 'x'
}
function _B (t) {
  const e = t.state
  const n = t.options
  const r = t.name
  const i = n.mainAxis
  const o = i === void 0 ? !0 : i
  const s = n.altAxis
  const l = s === void 0 ? !1 : s
  const u = n.boundary
  const d = n.rootBoundary
  const f = n.altBoundary
  const h = n.padding
  const m = n.tether
  const b = m === void 0 ? !0 : m
  const g = n.tetherOffset
  const E = g === void 0 ? 0 : g
  const w = lr(e, {
    boundary: u,
    rootBoundary: d,
    padding: h,
    altBoundary: f
  })
  const S = Kt(e.placement)
  const O = Yn(e.placement)
  const k = !O
  const T = lo(S)
  const P = sh(T)
  const I = e.modifiersData.popperOffsets
  const Y = e.rects.reference
  const ne = e.rects.popper
  const q =
        typeof E === 'function'
          ? E(Object.assign({}, e.rects, { placement: e.placement }))
          : E
  const Q =
        typeof q === 'number'
          ? { mainAxis: q, altAxis: q }
          : Object.assign({ mainAxis: 0, altAxis: 0 }, q)
  const fe = e.modifiersData.offset
    ? e.modifiersData.offset[e.placement]
    : null
  const we = { x: 0, y: 0 }
  if (I) {
    if (o) {
      let me
      const Ce = T === 'y' ? gt : xt
      const ge = T === 'y' ? Dt : Mt
      const ye = T === 'y' ? 'height' : 'width'
      const A = I[T]
      const D = A + w[Ce]
      const z = A - w[ge]
      const j = b ? -ne[ye] / 2 : 0
      const ie = O === Kr ? Y[ye] : ne[ye]
      const xe = O === Kr ? -ne[ye] : -Y[ye]
      const Ae = e.elements.arrow
      const je = b && Ae ? ao(Ae) : { width: 0, height: 0 }
      const Ne = e.modifiersData['arrow#persistent']
        ? e.modifiersData['arrow#persistent'].padding
        : ua()
      const Be = Ne[Ce]
      const _t = Ne[ge]
      const kt = co(0, Y[ye], je[ye])
      const Re = k
        ? Y[ye] / 2 - j - kt - Be - Q.mainAxis
        : ie - kt - Be - Q.mainAxis
      const St = k
        ? -Y[ye] / 2 + j + kt + _t + Q.mainAxis
        : xe + kt + _t + Q.mainAxis
      const Xt = e.elements.arrow && ar(e.elements.arrow)
      const pt = Xt
        ? T === 'y'
          ? Xt.clientTop || 0
          : Xt.clientLeft || 0
        : 0
      const an = (me = fe?.[T]) != null ? me : 0
      const Zt = A + Re - an - pt
      const Tt = A + St - an
      const Je = co(b ? so(D, Zt) : D, A, b ? sr(z, Tt) : z);
      (I[T] = Je), (we[T] = Je - A)
    }
    if (l) {
      let jn
      const Pt = T === 'x' ? gt : xt
      const V = T === 'x' ? Dt : Mt
      const yt = I[P]
      const _e = P === 'y' ? 'height' : 'width'
      const pe = yt + w[Pt]
      const ut = yt - w[V]
      const dt = [gt, xt].indexOf(S) !== -1
      const Bt = (jn = fe?.[P]) != null ? jn : 0
      const Ot = dt ? pe : yt - Y[_e] - ne[_e] - Bt + Q.altAxis
      const L = dt ? yt + Y[_e] + ne[_e] - Bt - Q.altAxis : ut
      const H = b && dt ? ww(Ot, yt, L) : co(b ? Ot : pe, yt, b ? L : ut);
      (I[P] = H), (we[P] = H - yt)
    }
    e.modifiersData[r] = we
  }
}
const Iw = {
  name: 'preventOverflow',
  enabled: !0,
  phase: 'main',
  fn: _B,
  requiresIfExists: ['offset']
}
function ah (t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
}
function lh (t) {
  return t === ct(t) || !Lt(t) ? uo(t) : ah(t)
}
function SB (t) {
  const e = t.getBoundingClientRect()
  const n = Vr(e.width) / t.offsetWidth || 1
  const r = Vr(e.height) / t.offsetHeight || 1
  return n !== 1 || r !== 1
}
function ch (t, e, n) {
  n === void 0 && (n = !1)
  const r = Lt(e)
  const i = Lt(e) && SB(e)
  const o = Jt(e)
  const s = qn(t, i, n)
  let l = { scrollLeft: 0, scrollTop: 0 }
  let u = { x: 0, y: 0 }
  return (
    (r || (!r && !n)) &&
            ((Wt(e) !== 'body' || po(o)) && (l = lh(e)),
            Lt(e)
              ? ((u = qn(e, !0)), (u.x += e.clientLeft), (u.y += e.clientTop))
              : o && (u.x = fo(o))),
    {
      x: s.left + l.scrollLeft - u.x,
      y: s.top + l.scrollTop - u.y,
      width: s.width,
      height: s.height
    }
  )
}
function TB (t) {
  const e = new Map()
  const n = new Set()
  const r = []
  t.forEach(function (o) {
    e.set(o.name, o)
  })
  function i (o) {
    n.add(o.name)
    const s = [].concat(o.requires || [], o.requiresIfExists || [])
    s.forEach(function (l) {
      if (!n.has(l)) {
        const u = e.get(l)
        u && i(u)
      }
    }),
    r.push(o)
  }
  return (
    t.forEach(function (o) {
      n.has(o.name) || i(o)
    }),
    r
  )
}
function uh (t) {
  const e = TB(t)
  return Ew.reduce(function (n, r) {
    return n.concat(
      e.filter(function (i) {
        return i.phase === r
      })
    )
  }, [])
}
function dh (t) {
  let e
  return function () {
    return (
      e ||
                (e = new Promise(function (n) {
                  Promise.resolve().then(function () {
                    (e = void 0), n(t())
                  })
                })),
      e
    )
  }
}
function fh (t) {
  const e = t.reduce(function (n, r) {
    const i = n[r.name]
    return (
      (n[r.name] = i
        ? Object.assign({}, i, r, {
          options: Object.assign({}, i.options, r.options),
          data: Object.assign({}, i.data, r.data)
        })
        : r),
      n
    )
  }, {})
  return Object.keys(e).map(function (n) {
    return e[n]
  })
}
const Dw = { placement: 'bottom', modifiers: [], strategy: 'absolute' }
function Lw () {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {
    e[n] = arguments[n]
  }
  return !e.some(function (r) {
    return !(r && typeof r.getBoundingClientRect === 'function')
  })
}
function Pw (t) {
  t === void 0 && (t = {})
  const e = t
  const n = e.defaultModifiers
  const r = n === void 0 ? [] : n
  const i = e.defaultOptions
  const o = i === void 0 ? Dw : i
  return function (l, u, d) {
    d === void 0 && (d = o)
    let f = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, Dw, o),
      modifiersData: {},
      elements: { reference: l, popper: u },
      attributes: {},
      styles: {}
    }
    let h = []
    let m = !1
    var b = {
      state: f,
      setOptions: function (S) {
        const O = typeof S === 'function' ? S(f.options) : S
        E(),
        (f.options = Object.assign({}, o, f.options, O)),
        (f.scrollParents = {
          reference: Gn(l)
            ? xi(l)
            : l.contextElement
              ? xi(l.contextElement)
              : [],
          popper: xi(u)
        })
        const k = uh(fh([].concat(r, f.options.modifiers)))
        return (
          (f.orderedModifiers = k.filter(function (T) {
            return T.enabled
          })),
          g(),
          b.update()
        )
      },
      forceUpdate: function () {
        if (!m) {
          const S = f.elements
          const O = S.reference
          const k = S.popper
          if (Lw(O, k)) {
            (f.rects = {
              reference: ch(
                O,
                ar(k),
                f.options.strategy === 'fixed'
              ),
              popper: ao(k)
            }),
            (f.reset = !1),
            (f.placement = f.options.placement),
            f.orderedModifiers.forEach(function (Q) {
              return (f.modifiersData[Q.name] = Object.assign(
                {},
                Q.data
              ))
            })
            for (let T = 0; T < f.orderedModifiers.length; T++) {
              if (f.reset === !0) {
                (f.reset = !1), (T = -1)
                continue
              }
              const P = f.orderedModifiers[T]
              const I = P.fn
              const Y = P.options
              const ne = Y === void 0 ? {} : Y
              const q = P.name
              typeof I === 'function' &&
                                (f =
                                    I({
                                      state: f,
                                      options: ne,
                                      name: q,
                                      instance: b
                                    }) || f)
            }
          }
        }
      },
      update: dh(function () {
        return new Promise(function (w) {
          b.forceUpdate(), w(f)
        })
      }),
      destroy: function () {
        E(), (m = !0)
      }
    }
    if (!Lw(l, u)) return b
    b.setOptions(d).then(function (w) {
      !m && d.onFirstUpdate && d.onFirstUpdate(w)
    })
    function g () {
      f.orderedModifiers.forEach(function (w) {
        const S = w.name
        const O = w.options
        const k = O === void 0 ? {} : O
        const T = w.effect
        if (typeof T === 'function') {
          const P = T({ state: f, name: S, instance: b, options: k })
          const I = function () {}
          h.push(P || I)
        }
      })
    }
    function E () {
      h.forEach(function (w) {
        return w()
      }),
      (h = [])
    }
    return b
  }
}
const CB = [Tw, Rw, Sw, aa, Ow, Aw, Iw, xw, kw]
const ph = Pw({ defaultModifiers: CB })
const AB = 'tippy-box'
const Gw = 'tippy-content'
const MB = 'tippy-backdrop'
const qw = 'tippy-arrow'
const Yw = 'tippy-svg-arrow'
const ho = { passive: !0, capture: !0 }
const Jw = function () {
  return document.body
}
function hh (t, e, n) {
  if (Array.isArray(t)) {
    const r = t[e]
    return r ?? (Array.isArray(n) ? n[e] : n)
  }
  return t
}
function vh (t, e) {
  const n = {}.toString.call(t)
  return n.indexOf('[object') === 0 && n.indexOf(e + ']') > -1
}
function Xw (t, e) {
  return typeof t === 'function' ? t.apply(void 0, e) : t
}
function Bw (t, e) {
  if (e === 0) return t
  let n
  return function (r) {
    clearTimeout(n),
    (n = setTimeout(function () {
      t(r)
    }, e))
  }
}
function NB (t) {
  return t.split(/\s+/).filter(Boolean)
}
function rs (t) {
  return [].concat(t)
}
function Fw (t, e) {
  t.indexOf(e) === -1 && t.push(e)
}
function kB (t) {
  return t.filter(function (e, n) {
    return t.indexOf(e) === n
  })
}
function OB (t) {
  return t.split('-')[0]
}
function Pc (t) {
  return [].slice.call(t)
}
function Hw (t) {
  return Object.keys(t).reduce(function (e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e
  }, {})
}
function ha () {
  return document.createElement('div')
}
function Bc (t) {
  return ['Element', 'Fragment'].some(function (e) {
    return vh(t, e)
  })
}
function RB (t) {
  return vh(t, 'NodeList')
}
function IB (t) {
  return vh(t, 'MouseEvent')
}
function DB (t) {
  return !!(t && t._tippy && t._tippy.reference === t)
}
function LB (t) {
  return Bc(t)
    ? [t]
    : RB(t)
      ? Pc(t)
      : Array.isArray(t)
        ? t
        : Pc(document.querySelectorAll(t))
}
function mh (t, e) {
  t.forEach(function (n) {
    n && (n.style.transitionDuration = e + 'ms')
  })
}
function $w (t, e) {
  t.forEach(function (n) {
    n && n.setAttribute('data-state', e)
  })
}
function PB (t) {
  let e
  const n = rs(t)
  const r = n[0]
  return r != null && (e = r.ownerDocument) != null && e.body
    ? r.ownerDocument
    : document
}
function BB (t, e) {
  const n = e.clientX
  const r = e.clientY
  return t.every(function (i) {
    const o = i.popperRect
    const s = i.popperState
    const l = i.props
    const u = l.interactiveBorder
    const d = OB(s.placement)
    const f = s.modifiersData.offset
    if (!f) return !0
    const h = d === 'bottom' ? f.top.y : 0
    const m = d === 'top' ? f.bottom.y : 0
    const b = d === 'right' ? f.left.x : 0
    const g = d === 'left' ? f.right.x : 0
    const E = o.top - r + h > u
    const w = r - o.bottom - m > u
    const S = o.left - n + b > u
    const O = n - o.right - g > u
    return E || w || S || O
  })
}
function gh (t, e, n) {
  const r = e + 'EventListener';
  ['transitionend', 'webkitTransitionEnd'].forEach(function (i) {
    t[r](i, n)
  })
}
function zw (t, e) {
  for (let n = e; n;) {
    var r
    if (t.contains(n)) return !0
    n =
            n.getRootNode == null || (r = n.getRootNode()) == null
              ? void 0
              : r.host
  }
  return !1
}
const yr = { isTouch: !1 }
let Uw = 0
function FB () {
  yr.isTouch ||
        ((yr.isTouch = !0),
        window.performance && document.addEventListener('mousemove', Zw))
}
function Zw () {
  const t = performance.now()
  t - Uw < 20 &&
        ((yr.isTouch = !1), document.removeEventListener('mousemove', Zw)),
  (Uw = t)
}
function HB () {
  const t = document.activeElement
  if (DB(t)) {
    const e = t._tippy
    t.blur && !e.state.isVisible && t.blur()
  }
}
function $B () {
  document.addEventListener('touchstart', FB, ho),
  window.addEventListener('blur', HB)
}
const zB = typeof window < 'u' && typeof document < 'u'
const UB = zB ? !!window.msCrypto : !1
const WB = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}
const KB = {
  allowHTML: !1,
  animation: 'fade',
  arrow: !0,
  content: '',
  inertia: !1,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
}
const cr = Object.assign(
  {
    appendTo: Jw,
    aria: { content: 'auto', expanded: 'auto' },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: !0,
    ignoreAttributes: !1,
    interactive: !1,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: '',
    offset: [0, 10],
    onAfterUpdate: function () {},
    onBeforeUpdate: function () {},
    onCreate: function () {},
    onDestroy: function () {},
    onHidden: function () {},
    onHide: function () {},
    onMount: function () {},
    onShow: function () {},
    onShown: function () {},
    onTrigger: function () {},
    onUntrigger: function () {},
    onClickOutside: function () {},
    placement: 'top',
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: !1,
    touch: !0,
    trigger: 'mouseenter focus',
    triggerTarget: null
  },
  WB,
  KB
)
const VB = Object.keys(cr)
const GB = function (e) {
  const n = Object.keys(e)
  n.forEach(function (r) {
    cr[r] = e[r]
  })
}
function jw (t) {
  const e = t.plugins || []
  const n = e.reduce(function (r, i) {
    const o = i.name
    const s = i.defaultValue
    if (o) {
      let l
      r[o] = t[o] !== void 0 ? t[o] : (l = cr[o]) != null ? l : s
    }
    return r
  }, {})
  return Object.assign({}, t, n)
}
function qB (t, e) {
  const n = e ? Object.keys(jw(Object.assign({}, cr, { plugins: e }))) : VB
  const r = n.reduce(function (i, o) {
    const s = (t.getAttribute('data-tippy-' + o) || '').trim()
    if (!s) return i
    if (o === 'content') i[o] = s
    else {
      try {
        i[o] = JSON.parse(s)
      } catch {
        i[o] = s
      }
    }
    return i
  }, {})
  return r
}
function Ww (t, e) {
  const n = Object.assign(
    {},
    e,
    { content: Xw(e.content, [t]) },
    e.ignoreAttributes ? {} : qB(t, e.plugins)
  )
  return (
    (n.aria = Object.assign({}, cr.aria, n.aria)),
    (n.aria = {
      expanded:
                n.aria.expanded === 'auto' ? e.interactive : n.aria.expanded,
      content:
                n.aria.content === 'auto'
                  ? e.interactive
                    ? null
                    : 'describedby'
                  : n.aria.content
    }),
    n
  )
}
const YB = function () {
  return 'innerHTML'
}
function yh (t, e) {
  t[YB()] = e
}
function Kw (t) {
  const e = ha()
  return (
    t === !0
      ? (e.className = qw)
      : ((e.className = Yw), Bc(t) ? e.appendChild(t) : yh(e, t)),
    e
  )
}
function Vw (t, e) {
  Bc(e.content)
    ? (yh(t, ''), t.appendChild(e.content))
    : typeof e.content !== 'function' &&
          (e.allowHTML ? yh(t, e.content) : (t.textContent = e.content))
}
function Eh (t) {
  const e = t.firstElementChild
  const n = Pc(e.children)
  return {
    box: e,
    content: n.find(function (r) {
      return r.classList.contains(Gw)
    }),
    arrow: n.find(function (r) {
      return r.classList.contains(qw) || r.classList.contains(Yw)
    }),
    backdrop: n.find(function (r) {
      return r.classList.contains(MB)
    })
  }
}
function Qw (t) {
  const e = ha()
  const n = ha();
  (n.className = AB),
  n.setAttribute('data-state', 'hidden'),
  n.setAttribute('tabindex', '-1')
  const r = ha();
  (r.className = Gw),
  r.setAttribute('data-state', 'hidden'),
  Vw(r, t.props),
  e.appendChild(n),
  n.appendChild(r),
  i(t.props, t.props)
  function i (o, s) {
    const l = Eh(e)
    const u = l.box
    const d = l.content
    const f = l.arrow
    s.theme
      ? u.setAttribute('data-theme', s.theme)
      : u.removeAttribute('data-theme'),
    typeof s.animation === 'string'
      ? u.setAttribute('data-animation', s.animation)
      : u.removeAttribute('data-animation'),
    s.inertia
      ? u.setAttribute('data-inertia', '')
      : u.removeAttribute('data-inertia'),
    (u.style.maxWidth =
                typeof s.maxWidth === 'number'
                  ? s.maxWidth + 'px'
                  : s.maxWidth),
    s.role ? u.setAttribute('role', s.role) : u.removeAttribute('role'),
    (o.content !== s.content || o.allowHTML !== s.allowHTML) &&
                Vw(d, t.props),
    s.arrow
      ? f
        ? o.arrow !== s.arrow &&
                      (u.removeChild(f), u.appendChild(Kw(s.arrow)))
        : u.appendChild(Kw(s.arrow))
      : f && u.removeChild(f)
  }
  return { popper: e, onUpdate: i }
}
Qw.$$tippy = !0
let JB = 1
let Lc = []
let bh = []
function XB (t, e) {
  const n = Ww(t, Object.assign({}, cr, jw(Hw(e))))
  let r
  let i
  let o
  let s = !1
  let l = !1
  let u = !1
  let d = !1
  let f
  let h
  let m
  let b = []
  let g = Bw(Zt, n.interactiveDebounce)
  let E
  const w = JB++
  const S = null
  const O = kB(n.plugins)
  const k = {
    isEnabled: !0,
    isVisible: !1,
    isDestroyed: !1,
    isMounted: !1,
    isShown: !1
  }
  const T = {
    id: w,
    reference: t,
    popper: ha(),
    popperInstance: S,
    props: n,
    state: k,
    plugins: O,
    clearDelayTimeouts: Ot,
    setProps: L,
    setContent: H,
    show: X,
    hide: se,
    hideWithInteractivity: Fe,
    enable: dt,
    disable: Bt,
    unmount: rt,
    destroy: wr
  }
  if (!n.render) return T
  const P = n.render(T)
  const I = P.popper
  const Y = P.onUpdate
  I.setAttribute('data-tippy-root', ''),
  (I.id = 'tippy-' + T.id),
  (T.popper = I),
  (t._tippy = T),
  (I._tippy = T)
  const ne = O.map(function (F) {
    return F.fn(T)
  })
  const q = t.hasAttribute('aria-expanded')
  return (
    Xt(),
    j(),
    A(),
    D('onCreate', [T]),
    n.showOnCreate && pe(),
    I.addEventListener('mouseenter', function () {
      T.props.interactive && T.state.isVisible && T.clearDelayTimeouts()
    }),
    I.addEventListener('mouseleave', function () {
      T.props.interactive &&
                T.props.trigger.indexOf('mouseenter') >= 0 &&
                Ce().addEventListener('mousemove', g)
    }),
    T
  )
  function Q () {
    const F = T.props.touch
    return Array.isArray(F) ? F : [F, 0]
  }
  function fe () {
    return Q()[0] === 'hold'
  }
  function we () {
    let F
    return !!((F = T.props.render) != null && F.$$tippy)
  }
  function me () {
    return E || t
  }
  function Ce () {
    const F = me().parentNode
    return F ? PB(F) : document
  }
  function ge () {
    return Eh(I)
  }
  function ye (F) {
    return (T.state.isMounted && !T.state.isVisible) ||
            yr.isTouch ||
            (f && f.type === 'focus')
      ? 0
      : hh(T.props.delay, F ? 0 : 1, cr.delay)
  }
  function A (F) {
    F === void 0 && (F = !1),
    (I.style.pointerEvents = T.props.interactive && !F ? '' : 'none'),
    (I.style.zIndex = '' + T.props.zIndex)
  }
  function D (F, ae, Se) {
    if (
      (Se === void 0 && (Se = !0),
      ne.forEach(function (Ke) {
        Ke[F] && Ke[F].apply(Ke, ae)
      }),
      Se)
    ) {
      let qe;
      (qe = T.props)[F].apply(qe, ae)
    }
  }
  function z () {
    const F = T.props.aria
    if (F.content) {
      const ae = 'aria-' + F.content
      const Se = I.id
      const qe = rs(T.props.triggerTarget || t)
      qe.forEach(function (Ke) {
        const Ft = Ke.getAttribute(ae)
        if (T.state.isVisible) {
          Ke.setAttribute(ae, Ft ? Ft + ' ' + Se : Se)
        } else {
          const ln = Ft && Ft.replace(Se, '').trim()
          ln ? Ke.setAttribute(ae, ln) : Ke.removeAttribute(ae)
        }
      })
    }
  }
  function j () {
    if (!(q || !T.props.aria.expanded)) {
      const F = rs(T.props.triggerTarget || t)
      F.forEach(function (ae) {
        T.props.interactive
          ? ae.setAttribute(
            'aria-expanded',
            T.state.isVisible && ae === me() ? 'true' : 'false'
          )
          : ae.removeAttribute('aria-expanded')
      })
    }
  }
  function ie () {
    Ce().removeEventListener('mousemove', g),
    (Lc = Lc.filter(function (F) {
      return F !== g
    }))
  }
  function xe (F) {
    if (!(yr.isTouch && (u || F.type === 'mousedown'))) {
      const ae = (F.composedPath && F.composedPath()[0]) || F.target
      if (!(T.props.interactive && zw(I, ae))) {
        if (
          rs(T.props.triggerTarget || t).some(function (Se) {
            return zw(Se, ae)
          })
        ) {
          if (
            yr.isTouch ||
                        (T.state.isVisible &&
                            T.props.trigger.indexOf('click') >= 0)
          ) {
            return
          }
        } else D('onClickOutside', [T, F])
        T.props.hideOnClick === !0 &&
                    (T.clearDelayTimeouts(),
                    T.hide(),
                    (l = !0),
                    setTimeout(function () {
                      l = !1
                    }),
                    T.state.isMounted || Be())
      }
    }
  }
  function Ae () {
    u = !0
  }
  function je () {
    u = !1
  }
  function Ne () {
    const F = Ce()
    F.addEventListener('mousedown', xe, !0),
    F.addEventListener('touchend', xe, ho),
    F.addEventListener('touchstart', je, ho),
    F.addEventListener('touchmove', Ae, ho)
  }
  function Be () {
    const F = Ce()
    F.removeEventListener('mousedown', xe, !0),
    F.removeEventListener('touchend', xe, ho),
    F.removeEventListener('touchstart', je, ho),
    F.removeEventListener('touchmove', Ae, ho)
  }
  function _t (F, ae) {
    Re(F, function () {
      !T.state.isVisible &&
                I.parentNode &&
                I.parentNode.contains(I) &&
                ae()
    })
  }
  function kt (F, ae) {
    Re(F, ae)
  }
  function Re (F, ae) {
    const Se = ge().box
    function qe (Ke) {
      Ke.target === Se && (gh(Se, 'remove', qe), ae())
    }
    if (F === 0) return ae()
    gh(Se, 'remove', h), gh(Se, 'add', qe), (h = qe)
  }
  function St (F, ae, Se) {
    Se === void 0 && (Se = !1)
    const qe = rs(T.props.triggerTarget || t)
    qe.forEach(function (Ke) {
      Ke.addEventListener(F, ae, Se),
      b.push({ node: Ke, eventType: F, handler: ae, options: Se })
    })
  }
  function Xt () {
    fe() &&
            (St('touchstart', an, { passive: !0 }),
            St('touchend', Tt, { passive: !0 })),
    NB(T.props.trigger).forEach(function (F) {
      if (F !== 'manual') {
        switch ((St(F, an), F)) {
          case 'mouseenter':
            St('mouseleave', Tt)
            break
          case 'focus':
            St(UB ? 'focusout' : 'blur', Je)
            break
          case 'focusin':
            St('focusout', Je)
            break
        }
      }
    })
  }
  function pt () {
    b.forEach(function (F) {
      const ae = F.node
      const Se = F.eventType
      const qe = F.handler
      const Ke = F.options
      ae.removeEventListener(Se, qe, Ke)
    }),
    (b = [])
  }
  function an (F) {
    let ae
    let Se = !1
    if (!(!T.state.isEnabled || jn(F) || l)) {
      const qe = ((ae = f) == null ? void 0 : ae.type) === 'focus';
      (f = F),
      (E = F.currentTarget),
      j(),
      !T.state.isVisible &&
                    IB(F) &&
                    Lc.forEach(function (Ke) {
                      return Ke(F)
                    }),
      F.type === 'click' &&
                (T.props.trigger.indexOf('mouseenter') < 0 || s) &&
                T.props.hideOnClick !== !1 &&
                T.state.isVisible
        ? (Se = !0)
        : pe(F),
      F.type === 'click' && (s = !Se),
      Se && !qe && ut(F)
    }
  }
  function Zt (F) {
    const ae = F.target
    const Se = me().contains(ae) || I.contains(ae)
    if (!(F.type === 'mousemove' && Se)) {
      const qe = _e()
        .concat(I)
        .map(function (Ke) {
          let Ft
          const ln = Ke._tippy
          const Zr =
                        (Ft = ln.popperInstance) == null ? void 0 : Ft.state
          return Zr
            ? {
                popperRect: Ke.getBoundingClientRect(),
                popperState: Zr,
                props: n
              }
            : null
        })
        .filter(Boolean)
      BB(qe, F) && (ie(), ut(F))
    }
  }
  function Tt (F) {
    const ae = jn(F) || (T.props.trigger.indexOf('click') >= 0 && s)
    if (!ae) {
      if (T.props.interactive) {
        T.hideWithInteractivity(F)
        return
      }
      ut(F)
    }
  }
  function Je (F) {
    (T.props.trigger.indexOf('focusin') < 0 && F.target !== me()) ||
            (T.props.interactive &&
                F.relatedTarget &&
                I.contains(F.relatedTarget)) ||
            ut(F)
  }
  function jn (F) {
    return yr.isTouch ? fe() !== F.type.indexOf('touch') >= 0 : !1
  }
  function Pt () {
    V()
    const F = T.props
    const ae = F.popperOptions
    const Se = F.placement
    const qe = F.offset
    const Ke = F.getReferenceClientRect
    const Ft = F.moveTransition
    const ln = we() ? Eh(I).arrow : null
    const Zr = Ke
      ? {
          getBoundingClientRect: Ke,
          contextElement: Ke.contextElement || me()
        }
      : t
    const Da = {
      name: '$$tippy',
      enabled: !0,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function (Ni) {
        const jr = Ni.state
        if (we()) {
          const zu = ge()
          const ys = zu.box;
          ['placement', 'reference-hidden', 'escaped'].forEach(
            function (Qr) {
              Qr === 'placement'
                ? ys.setAttribute(
                  'data-placement',
                  jr.placement
                )
                : jr.attributes.popper['data-popper-' + Qr]
                  ? ys.setAttribute('data-' + Qr, '')
                  : ys.removeAttribute('data-' + Qr)
            }
          ),
          (jr.attributes.popper = {})
        }
      }
    }
    const xr = [
      { name: 'offset', options: { offset: qe } },
      {
        name: 'preventOverflow',
        options: {
          padding: { top: 2, bottom: 2, left: 5, right: 5 }
        }
      },
      { name: 'flip', options: { padding: 5 } },
      { name: 'computeStyles', options: { adaptive: !Ft } },
      Da
    ]
    we() &&
            ln &&
            xr.push({ name: 'arrow', options: { element: ln, padding: 3 } }),
    xr.push.apply(xr, ae?.modifiers || []),
    (T.popperInstance = ph(
      Zr,
      I,
      Object.assign({}, ae, {
        placement: Se,
        onFirstUpdate: m,
        modifiers: xr
      })
    ))
  }
  function V () {
    T.popperInstance &&
            (T.popperInstance.destroy(), (T.popperInstance = null))
  }
  function yt () {
    const F = T.props.appendTo
    let ae
    const Se = me();
    (T.props.interactive && F === Jw) || F === 'parent'
      ? (ae = Se.parentNode)
      : (ae = Xw(F, [Se])),
    ae.contains(I) || ae.appendChild(I),
    (T.state.isMounted = !0),
    Pt()
  }
  function _e () {
    return Pc(I.querySelectorAll('[data-tippy-root]'))
  }
  function pe (F) {
    T.clearDelayTimeouts(), F && D('onTrigger', [T, F]), Ne()
    let ae = ye(!0)
    const Se = Q()
    const qe = Se[0]
    const Ke = Se[1]
    yr.isTouch && qe === 'hold' && Ke && (ae = Ke),
    ae
      ? (r = setTimeout(function () {
          T.show()
        }, ae))
      : T.show()
  }
  function ut (F) {
    if (
      (T.clearDelayTimeouts(),
      D('onUntrigger', [T, F]),
      !T.state.isVisible)
    ) {
      Be()
      return
    }
    if (
      !(
        T.props.trigger.indexOf('mouseenter') >= 0 &&
                T.props.trigger.indexOf('click') >= 0 &&
                ['mouseleave', 'mousemove'].indexOf(F.type) >= 0 &&
                s
      )
    ) {
      const ae = ye(!1)
      ae
        ? (i = setTimeout(function () {
            T.state.isVisible && T.hide()
          }, ae))
        : (o = requestAnimationFrame(function () {
            T.hide()
          }))
    }
  }
  function dt () {
    T.state.isEnabled = !0
  }
  function Bt () {
    T.hide(), (T.state.isEnabled = !1)
  }
  function Ot () {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(o)
  }
  function L (F) {
    if (!T.state.isDestroyed) {
      D('onBeforeUpdate', [T, F]), pt()
      const ae = T.props
      const Se = Ww(
        t,
        Object.assign({}, ae, Hw(F), { ignoreAttributes: !0 })
      );
      (T.props = Se),
      Xt(),
      ae.interactiveDebounce !== Se.interactiveDebounce &&
                    (ie(), (g = Bw(Zt, Se.interactiveDebounce))),
      ae.triggerTarget && !Se.triggerTarget
        ? rs(ae.triggerTarget).forEach(function (qe) {
          qe.removeAttribute('aria-expanded')
        })
        : Se.triggerTarget && t.removeAttribute('aria-expanded'),
      j(),
      A(),
      Y && Y(ae, Se),
      T.popperInstance &&
                    (Pt(),
                    _e().forEach(function (qe) {
                      requestAnimationFrame(
                        qe._tippy.popperInstance.forceUpdate
                      )
                    })),
      D('onAfterUpdate', [T, F])
    }
  }
  function H (F) {
    T.setProps({ content: F })
  }
  function X () {
    const F = T.state.isVisible
    const ae = T.state.isDestroyed
    const Se = !T.state.isEnabled
    const qe = yr.isTouch && !T.props.touch
    const Ke = hh(T.props.duration, 0, cr.duration)
    if (
      !(F || ae || Se || qe) &&
            !me().hasAttribute('disabled') &&
            (D('onShow', [T], !1), T.props.onShow(T) !== !1)
    ) {
      if (
        ((T.state.isVisible = !0),
        we() && (I.style.visibility = 'visible'),
        A(),
        Ne(),
        T.state.isMounted || (I.style.transition = 'none'),
        we())
      ) {
        const Ft = ge()
        const ln = Ft.box
        const Zr = Ft.content
        mh([ln, Zr], 0)
      }
      (m = function () {
        let xr
        if (!(!T.state.isVisible || d)) {
          if (
            ((d = !0),
            I.offsetHeight,
            (I.style.transition = T.props.moveTransition),
            we() && T.props.animation)
          ) {
            const bs = ge()
            const Ni = bs.box
            const jr = bs.content
            mh([Ni, jr], Ke), $w([Ni, jr], 'visible')
          }
          z(),
          j(),
          Fw(bh, T),
          (xr = T.popperInstance) == null || xr.forceUpdate(),
          D('onMount', [T]),
          T.props.animation &&
                            we() &&
                            kt(Ke, function () {
                              (T.state.isShown = !0), D('onShown', [T])
                            })
        }
      }),
      yt()
    }
  }
  function se () {
    const F = !T.state.isVisible
    const ae = T.state.isDestroyed
    const Se = !T.state.isEnabled
    const qe = hh(T.props.duration, 1, cr.duration)
    if (
      !(F || ae || Se) &&
            (D('onHide', [T], !1), T.props.onHide(T) !== !1)
    ) {
      if (
        ((T.state.isVisible = !1),
        (T.state.isShown = !1),
        (d = !1),
        (s = !1),
        we() && (I.style.visibility = 'hidden'),
        ie(),
        Be(),
        A(!0),
        we())
      ) {
        const Ke = ge()
        const Ft = Ke.box
        const ln = Ke.content
        T.props.animation && (mh([Ft, ln], qe), $w([Ft, ln], 'hidden'))
      }
      z(),
      j(),
      T.props.animation ? we() && _t(qe, T.unmount) : T.unmount()
    }
  }
  function Fe (F) {
    Ce().addEventListener('mousemove', g), Fw(Lc, g), g(F)
  }
  function rt () {
    T.state.isVisible && T.hide(),
    T.state.isMounted &&
                (V(),
                _e().forEach(function (F) {
                  F._tippy.unmount()
                }),
                I.parentNode && I.parentNode.removeChild(I),
                (bh = bh.filter(function (F) {
                  return F !== T
                })),
                (T.state.isMounted = !1),
                D('onHidden', [T]))
  }
  function wr () {
    T.state.isDestroyed ||
            (T.clearDelayTimeouts(),
            T.unmount(),
            pt(),
            delete t._tippy,
            (T.state.isDestroyed = !0),
            D('onDestroy', [T]))
  }
}
function ma (t, e) {
  e === void 0 && (e = {})
  const n = cr.plugins.concat(e.plugins || [])
  $B()
  const r = Object.assign({}, e, { plugins: n })
  const i = LB(t)
  if (0) var o, s
  const l = i.reduce(function (u, d) {
    const f = d && XB(d, r)
    return f && u.push(f), u
  }, [])
  return Bc(t) ? l[0] : l
}
ma.defaultProps = cr
ma.setDefaultProps = GB
ma.currentInput = yr
const JV = Object.assign({}, aa, {
  effect: function (e) {
    const n = e.state
    const r = {
      popper: {
        position: n.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: { position: 'absolute' },
      reference: {}
    }
    Object.assign(n.elements.popper.style, r.popper),
    (n.styles = r),
    n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow)
  }
})
ma.setDefaultProps({ render: Qw })
const is = ma
const wh = class {
  constructor ({
    editor: e,
    element: n,
    view: r,
    tippyOptions: i = {},
    updateDelay: o = 250,
    shouldShow: s
  }) {
    (this.preventHide = !1),
    (this.shouldShow = ({ view: l, state: u, from: d, to: f }) => {
      const { doc: h, selection: m } = u
      const { empty: b } = m
      const g = !h.textBetween(d, f).length && dc(u.selection)
      const E = this.element.contains(document.activeElement)
      return !(
        !(l.hasFocus() || E) ||
                    b ||
                    g ||
                    !this.editor.isEditable
      )
    }),
    (this.mousedownHandler = () => {
      this.preventHide = !0
    }),
    (this.dragstartHandler = () => {
      this.hide()
    }),
    (this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view))
    }),
    (this.blurHandler = ({ event: l }) => {
      let u
      if (this.preventHide) {
        this.preventHide = !1
        return
      }
      (l?.relatedTarget &&
                    !((u = this.element.parentNode) === null || u === void 0) &&
                    u.contains(l.relatedTarget)) ||
                    (l?.relatedTarget !== this.editor.view.dom && this.hide())
    }),
    (this.tippyBlurHandler = (l) => {
      this.blurHandler({ event: l })
    }),
    (this.handleDebouncedUpdate = (l, u) => {
      const d = !u?.selection.eq(l.state.selection)
      const f = !u?.doc.eq(l.state.doc);
      (!d && !f) ||
                    (this.updateDebounceTimer &&
                        clearTimeout(this.updateDebounceTimer),
                    (this.updateDebounceTimer = window.setTimeout(() => {
                      this.updateHandler(l, d, f, u)
                    }, this.updateDelay)))
    }),
    (this.updateHandler = (l, u, d, f) => {
      let h, m, b
      const { state: g, composing: E } = l
      const { selection: w } = g
      if (E || (!u && !d)) return
      this.createTooltip()
      const { ranges: O } = w
      const k = Math.min(...O.map((I) => I.$from.pos))
      const T = Math.max(...O.map((I) => I.$to.pos))
      if (
        !((h = this.shouldShow) === null || h === void 0
          ? void 0
          : h.call(this, {
            editor: this.editor,
            element: this.element,
            view: l,
            state: g,
            oldState: f,
            from: k,
            to: T
          }))
      ) {
        this.hide()
        return
      }
      (m = this.tippy) === null ||
                    m === void 0 ||
                    m.setProps({
                      getReferenceClientRect:
                            ((b = this.tippyOptions) === null || b === void 0
                              ? void 0
                              : b.getReferenceClientRect) ||
                            (() => {
                              if (hc(g.selection)) {
                                let I = l.nodeDOM(k)
                                if (I) {
                                  const Y = I.dataset.nodeViewWrapper
                                    ? I
                                    : I.querySelector(
                                      '[data-node-view-wrapper]'
                                    )
                                  if ((Y && (I = Y.firstChild), I)) {
                                    return I.getBoundingClientRect()
                                  }
                                }
                              }
                              return mc(l, k, T)
                            })
                    }),
      this.show()
    }),
    (this.editor = e),
    (this.element = n),
    (this.view = r),
    (this.updateDelay = o),
    s && (this.shouldShow = s),
    this.element.addEventListener('mousedown', this.mousedownHandler, {
      capture: !0
    }),
    this.view.dom.addEventListener('dragstart', this.dragstartHandler),
    this.editor.on('focus', this.focusHandler),
    this.editor.on('blur', this.blurHandler),
    (this.tippyOptions = i),
    this.element.remove(),
    (this.element.style.visibility = 'visible')
  }

  createTooltip () {
    const { element: e } = this.editor.options
    const n = !!e.parentElement
    this.tippy ||
            !n ||
            ((this.tippy = is(e, {
              duration: 0,
              getReferenceClientRect: null,
              content: this.element,
              interactive: !0,
              trigger: 'manual',
              placement: 'top',
              hideOnClick: 'toggle',
              ...this.tippyOptions
            })),
            this.tippy.popper.firstChild &&
                this.tippy.popper.firstChild.addEventListener(
                  'blur',
                  this.tippyBlurHandler
                ))
  }

  update (e, n) {
    const { state: r } = e
    const i = r.selection.from !== r.selection.to
    if (this.updateDelay > 0 && i) {
      this.handleDebouncedUpdate(e, n)
      return
    }
    const o = !n?.selection.eq(e.state.selection)
    const s = !n?.doc.eq(e.state.doc)
    this.updateHandler(e, o, s, n)
  }

  show () {
    let e;
    (e = this.tippy) === null || e === void 0 || e.show()
  }

  hide () {
    let e;
    (e = this.tippy) === null || e === void 0 || e.hide()
  }

  destroy () {
    let e, n
    !((e = this.tippy) === null || e === void 0) &&
            e.popper.firstChild &&
            this.tippy.popper.firstChild.removeEventListener(
              'blur',
              this.tippyBlurHandler
            ),
    (n = this.tippy) === null || n === void 0 || n.destroy(),
    this.element.removeEventListener(
      'mousedown',
      this.mousedownHandler,
      { capture: !0 }
    ),
    this.view.dom.removeEventListener(
      'dragstart',
      this.dragstartHandler
    ),
    this.editor.off('focus', this.focusHandler),
    this.editor.off('blur', this.blurHandler)
  }
}
const ZB = (t) =>
  new Oe({
    key:
            typeof t.pluginKey === 'string' ? new ze(t.pluginKey) : t.pluginKey,
    view: (e) => new wh({ view: e, ...t })
  })
const ex = We.create({
  name: 'bubbleMenu',
  addOptions () {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: 'bubbleMenu',
      updateDelay: void 0,
      shouldShow: null
    }
  },
  addProseMirrorPlugins () {
    return this.options.element
      ? [
          ZB({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow
          })
        ]
      : []
  }
})
const xh = class {
  getTextContent (e) {
    return kp(e, { textSerializers: uc(this.editor.schema) })
  }

  constructor ({
    editor: e,
    element: n,
    view: r,
    tippyOptions: i = {},
    shouldShow: o
  }) {
    (this.preventHide = !1),
    (this.shouldShow = ({ view: s, state: l }) => {
      const { selection: u } = l
      const { $anchor: d, empty: f } = u
      const h = d.depth === 1
      const m =
                    d.parent.isTextblock &&
                    !d.parent.type.spec.code &&
                    !d.parent.textContent &&
                    d.parent.childCount === 0 &&
                    !this.getTextContent(d.parent)
      return !(
        !s.hasFocus() ||
                    !f ||
                    !h ||
                    !m ||
                    !this.editor.isEditable
      )
    }),
    (this.mousedownHandler = () => {
      this.preventHide = !0
    }),
    (this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view))
    }),
    (this.blurHandler = ({ event: s }) => {
      let l
      if (this.preventHide) {
        this.preventHide = !1
        return
      }
      (s?.relatedTarget &&
                    !((l = this.element.parentNode) === null || l === void 0) &&
                    l.contains(s.relatedTarget)) ||
                    (s?.relatedTarget !== this.editor.view.dom && this.hide())
    }),
    (this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s })
    }),
    (this.editor = e),
    (this.element = n),
    (this.view = r),
    o && (this.shouldShow = o),
    this.element.addEventListener('mousedown', this.mousedownHandler, {
      capture: !0
    }),
    this.editor.on('focus', this.focusHandler),
    this.editor.on('blur', this.blurHandler),
    (this.tippyOptions = i),
    this.element.remove(),
    (this.element.style.visibility = 'visible')
  }

  createTooltip () {
    const { element: e } = this.editor.options
    const n = !!e.parentElement
    this.tippy ||
            !n ||
            ((this.tippy = is(e, {
              duration: 0,
              getReferenceClientRect: null,
              content: this.element,
              interactive: !0,
              trigger: 'manual',
              placement: 'right',
              hideOnClick: 'toggle',
              ...this.tippyOptions
            })),
            this.tippy.popper.firstChild &&
                this.tippy.popper.firstChild.addEventListener(
                  'blur',
                  this.tippyBlurHandler
                ))
  }

  update (e, n) {
    let r, i, o
    const { state: s } = e
    const { doc: l, selection: u } = s
    const { from: d, to: f } = u
    if (n && n.doc.eq(l) && n.selection.eq(u)) return
    if (
      (this.createTooltip(),
      !((r = this.shouldShow) === null || r === void 0
        ? void 0
        : r.call(this, {
          editor: this.editor,
          view: e,
          state: s,
          oldState: n
        })))
    ) {
      this.hide()
      return
    }
    (i = this.tippy) === null ||
            i === void 0 ||
            i.setProps({
              getReferenceClientRect:
                    ((o = this.tippyOptions) === null || o === void 0
                      ? void 0
                      : o.getReferenceClientRect) || (() => mc(e, d, f))
            }),
    this.show()
  }

  show () {
    let e;
    (e = this.tippy) === null || e === void 0 || e.show()
  }

  hide () {
    let e;
    (e = this.tippy) === null || e === void 0 || e.hide()
  }

  destroy () {
    let e, n
    !((e = this.tippy) === null || e === void 0) &&
            e.popper.firstChild &&
            this.tippy.popper.firstChild.removeEventListener(
              'blur',
              this.tippyBlurHandler
            ),
    (n = this.tippy) === null || n === void 0 || n.destroy(),
    this.element.removeEventListener(
      'mousedown',
      this.mousedownHandler,
      { capture: !0 }
    ),
    this.editor.off('focus', this.focusHandler),
    this.editor.off('blur', this.blurHandler)
  }
}
const jB = (t) =>
  new Oe({
    key:
            typeof t.pluginKey === 'string' ? new ze(t.pluginKey) : t.pluginKey,
    view: (e) => new xh({ view: e, ...t })
  })
const tx = We.create({
  name: 'floatingMenu',
  addOptions () {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: 'floatingMenu',
      shouldShow: null
    }
  },
  addProseMirrorPlugins () {
    return this.options.element
      ? [
          jB({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            shouldShow: this.options.shouldShow
          })
        ]
      : []
  }
})
const _h = ce.create({
  name: 'checkedList',
  priority: 50,
  addOptions () {
    return {
      itemTypeName: 'listItem',
      HTMLAttributes: { class: 'checked-list' }
    }
  },
  group: 'block list',
  content () {
    return `${this.options.itemTypeName}+`
  },
  parseHTML () {
    return [
      {
        tag: 'ul',
        getAttrs: (t) => t.classList.contains('checked-list'),
        priority: 1e3
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['ul', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      toggleCheckedList:
                () =>
                  ({ commands: t }) =>
                    t.toggleList(this.name, this.options.itemTypeName)
    }
  }
})
const Sh = ce.create({
  name: 'lead',
  group: 'block',
  content: 'block+',
  addOptions () {
    return { HTMLAttributes: { class: 'lead' } }
  },
  parseHTML () {
    return [{ tag: 'div', getAttrs: (t) => t.classList.contains('lead') }]
  },
  renderHTML ({ node: t, HTMLAttributes: e }) {
    return ['div', ee(this.options.HTMLAttributes, e), 0]
  },
  addCommands () {
    return {
      toggleLead:
                () =>
                  ({ commands: t }) =>
                    t.toggleWrap(this.name)
    }
  }
})
const QB =
    'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2'
const e2 =
    '\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2'
const as = (t, e) => {
  for (const n in e) t[n] = e[n]
  return t
}
const Oh = 'numeric'
const Rh = 'ascii'
const Ih = 'alpha'
const ya = 'asciinumeric'
const ba = 'alphanumeric'
const Dh = 'domain'
const lx = 'emoji'
const t2 = 'scheme'
const n2 = 'slashscheme'
const Th = 'whitespace'
function r2 (t, e) {
  return t in e || (e[t] = []), e[t]
}
function mo (t, e, n) {
  e[Oh] && ((e[ya] = !0), (e[ba] = !0)),
  e[Rh] && ((e[ya] = !0), (e[Ih] = !0)),
  e[ya] && (e[ba] = !0),
  e[Ih] && (e[ba] = !0),
  e[ba] && (e[Dh] = !0),
  e[lx] && (e[Dh] = !0)
  for (const r in e) {
    const i = r2(r, n)
    i.indexOf(t) < 0 && i.push(t)
  }
}
function i2 (t, e) {
  const n = {}
  for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0)
  return n
}
function _n (t = null) {
  (this.j = {}), (this.jr = []), (this.jd = null), (this.t = t)
}
_n.groups = {}
_n.prototype = {
  accepts () {
    return !!this.t
  },
  go (t) {
    const e = this
    const n = e.j[t]
    if (n) return n
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0]
      const o = e.jr[r][1]
      if (o && i.test(t)) return o
    }
    return e.jd
  },
  has (t, e = !1) {
    return e ? t in this.j : !!this.go(t)
  },
  ta (t, e, n, r) {
    for (let i = 0; i < t.length; i++) this.tt(t[i], e, n, r)
  },
  tr (t, e, n, r) {
    r = r || _n.groups
    let i
    return (
      e && e.j ? (i = e) : ((i = new _n(e)), n && r && mo(e, n, r)),
      this.jr.push([t, i]),
      i
    )
  },
  ts (t, e, n, r) {
    let i = this
    const o = t.length
    if (!o) return i
    for (let s = 0; s < o - 1; s++) i = i.tt(t[s])
    return i.tt(t[o - 1], e, n, r)
  },
  tt (t, e, n, r) {
    r = r || _n.groups
    const i = this
    if (e && e.j) return (i.j[t] = e), e
    const o = e
    let s
    const l = i.go(t)
    if (
      (l
        ? ((s = new _n()),
          as(s.j, l.j),
          s.jr.push.apply(s.jr, l.jr),
          (s.jd = l.jd),
          (s.t = l.t))
        : (s = new _n()),
      o)
    ) {
      if (r) {
        if (s.t && typeof s.t === 'string') {
          const u = as(i2(s.t, r), n)
          mo(o, u, r)
        } else n && mo(o, n, r)
      }
      s.t = o
    }
    return (i.j[t] = s), s
  }
}
const Pe = (t, e, n, r, i) => t.ta(e, n, r, i)
const bt = (t, e, n, r, i) => t.tr(e, n, r, i)
const nx = (t, e, n, r, i) => t.ts(e, n, r, i)
const J = (t, e, n, r, i) => t.tt(e, n, r, i)
const Jr = 'WORD'
const Lh = 'UWORD'
const cx = 'ASCIINUMERICAL'
const ux = 'ALPHANUMERICAL'
const Sa = 'LOCALHOST'
const Ph = 'TLD'
const Bh = 'UTLD'
const zc = 'SCHEME'
const ss = 'SLASH_SCHEME'
const Hh = 'NUM'
const Fh = 'WS'
const $h = 'NL'
const Ea = 'OPENBRACE'
const va = 'CLOSEBRACE'
const Uc = 'OPENBRACKET'
const Wc = 'CLOSEBRACKET'
const Kc = 'OPENPAREN'
const Vc = 'CLOSEPAREN'
const Gc = 'OPENANGLEBRACKET'
const qc = 'CLOSEANGLEBRACKET'
const Yc = 'FULLWIDTHLEFTPAREN'
const Jc = 'FULLWIDTHRIGHTPAREN'
const Xc = 'LEFTCORNERBRACKET'
const Zc = 'RIGHTCORNERBRACKET'
const jc = 'LEFTWHITECORNERBRACKET'
const Qc = 'RIGHTWHITECORNERBRACKET'
const eu = 'FULLWIDTHLESSTHAN'
const tu = 'FULLWIDTHGREATERTHAN'
const nu = 'AMPERSAND'
const zh = 'APOSTROPHE'
const ru = 'ASTERISK'
const Si = 'AT'
const iu = 'BACKSLASH'
const ou = 'BACKTICK'
const su = 'CARET'
const Ti = 'COLON'
const Uh = 'COMMA'
const au = 'DOLLAR'
const Er = 'DOT'
const lu = 'EQUALS'
const Wh = 'EXCLAMATION'
const Xn = 'HYPHEN'
const wa = 'PERCENT'
const cu = 'PIPE'
const uu = 'PLUS'
const du = 'POUND'
const xa = 'QUERY'
const Kh = 'QUOTE'
const dx = 'FULLWIDTHMIDDLEDOT'
const Vh = 'SEMI'
const vr = 'SLASH'
const _a = 'TILDE'
const fu = 'UNDERSCORE'
const fx = 'EMOJI'
const pu = 'SYM'
const px = Object.freeze({
  __proto__: null,
  WORD: Jr,
  UWORD: Lh,
  ASCIINUMERICAL: cx,
  ALPHANUMERICAL: ux,
  LOCALHOST: Sa,
  TLD: Ph,
  UTLD: Bh,
  SCHEME: zc,
  SLASH_SCHEME: ss,
  NUM: Hh,
  WS: Fh,
  NL: $h,
  OPENBRACE: Ea,
  CLOSEBRACE: va,
  OPENBRACKET: Uc,
  CLOSEBRACKET: Wc,
  OPENPAREN: Kc,
  CLOSEPAREN: Vc,
  OPENANGLEBRACKET: Gc,
  CLOSEANGLEBRACKET: qc,
  FULLWIDTHLEFTPAREN: Yc,
  FULLWIDTHRIGHTPAREN: Jc,
  LEFTCORNERBRACKET: Xc,
  RIGHTCORNERBRACKET: Zc,
  LEFTWHITECORNERBRACKET: jc,
  RIGHTWHITECORNERBRACKET: Qc,
  FULLWIDTHLESSTHAN: eu,
  FULLWIDTHGREATERTHAN: tu,
  AMPERSAND: nu,
  APOSTROPHE: zh,
  ASTERISK: ru,
  AT: Si,
  BACKSLASH: iu,
  BACKTICK: ou,
  CARET: su,
  COLON: Ti,
  COMMA: Uh,
  DOLLAR: au,
  DOT: Er,
  EQUALS: lu,
  EXCLAMATION: Wh,
  HYPHEN: Xn,
  PERCENT: wa,
  PIPE: cu,
  PLUS: uu,
  POUND: du,
  QUERY: xa,
  QUOTE: Kh,
  FULLWIDTHMIDDLEDOT: dx,
  SEMI: Vh,
  SLASH: vr,
  TILDE: _a,
  UNDERSCORE: fu,
  EMOJI: fx,
  SYM: pu
})
const qr = /[a-z]/
const ga = /\p{L}/u
const Ch = /\p{Emoji}/u
const Yr = /\d/
const Ah = /\s/
const rx = '\r'
const Mh = `
`
const o2 = '\uFE0F'
const s2 = '\u200D'
const Nh = '\uFFFC'
let Fc = null
let Hc = null
function a2 (t = []) {
  const e = {}
  _n.groups = e
  const n = new _n()
  Fc == null && (Fc = ix(QB)),
  Hc == null && (Hc = ix(e2)),
  J(n, "'", zh),
  J(n, '{', Ea),
  J(n, '}', va),
  J(n, '[', Uc),
  J(n, ']', Wc),
  J(n, '(', Kc),
  J(n, ')', Vc),
  J(n, '<', Gc),
  J(n, '>', qc),
  J(n, '\uFF08', Yc),
  J(n, '\uFF09', Jc),
  J(n, '\u300C', Xc),
  J(n, '\u300D', Zc),
  J(n, '\u300E', jc),
  J(n, '\u300F', Qc),
  J(n, '\uFF1C', eu),
  J(n, '\uFF1E', tu),
  J(n, '&', nu),
  J(n, '*', ru),
  J(n, '@', Si),
  J(n, '`', ou),
  J(n, '^', su),
  J(n, ':', Ti),
  J(n, ',', Uh),
  J(n, '$', au),
  J(n, '.', Er),
  J(n, '=', lu),
  J(n, '!', Wh),
  J(n, '-', Xn),
  J(n, '%', wa),
  J(n, '|', cu),
  J(n, '+', uu),
  J(n, '#', du),
  J(n, '?', xa),
  J(n, '"', Kh),
  J(n, '/', vr),
  J(n, ';', Vh),
  J(n, '~', _a),
  J(n, '_', fu),
  J(n, '\\', iu),
  J(n, '\u30FB', dx)
  const r = bt(n, Yr, Hh, { [Oh]: !0 })
  bt(r, Yr, r)
  const i = bt(r, qr, cx, { [ya]: !0 })
  const o = bt(r, ga, ux, { [ba]: !0 })
  const s = bt(n, qr, Jr, { [Rh]: !0 })
  bt(s, Yr, i), bt(s, qr, s), bt(i, Yr, i), bt(i, qr, i)
  const l = bt(n, ga, Lh, { [Ih]: !0 })
  bt(l, qr),
  bt(l, Yr, o),
  bt(l, ga, l),
  bt(o, Yr, o),
  bt(o, qr),
  bt(o, ga, o)
  const u = J(n, Mh, $h, { [Th]: !0 })
  const d = J(n, rx, Fh, { [Th]: !0 })
  const f = bt(n, Ah, Fh, { [Th]: !0 })
  J(n, Nh, f),
  J(d, Mh, u),
  J(d, Nh, f),
  bt(d, Ah, f),
  J(f, rx),
  J(f, Mh),
  bt(f, Ah, f),
  J(f, Nh, f)
  const h = bt(n, Ch, fx, { [lx]: !0 })
  J(h, '#'), bt(h, Ch, h), J(h, o2, h)
  const m = J(h, s2)
  J(m, '#'), bt(m, Ch, h)
  const b = [
    [qr, s],
    [Yr, i]
  ]
  const g = [
    [qr, null],
    [ga, l],
    [Yr, o]
  ]
  for (let E = 0; E < Fc.length; E++) _i(n, Fc[E], Ph, Jr, b)
  for (let E = 0; E < Hc.length; E++) _i(n, Hc[E], Bh, Lh, g)
  mo(Ph, { tld: !0, ascii: !0 }, e),
  mo(Bh, { utld: !0, alpha: !0 }, e),
  _i(n, 'file', zc, Jr, b),
  _i(n, 'mailto', zc, Jr, b),
  _i(n, 'http', ss, Jr, b),
  _i(n, 'https', ss, Jr, b),
  _i(n, 'ftp', ss, Jr, b),
  _i(n, 'ftps', ss, Jr, b),
  mo(zc, { scheme: !0, ascii: !0 }, e),
  mo(ss, { slashscheme: !0, ascii: !0 }, e),
  (t = t.sort((E, w) => (E[0] > w[0] ? 1 : -1)))
  for (let E = 0; E < t.length; E++) {
    const w = t[E][0]
    const O = t[E][1] ? { [t2]: !0 } : { [n2]: !0 }
    w.indexOf('-') >= 0
      ? (O[Dh] = !0)
      : qr.test(w)
        ? Yr.test(w)
          ? (O[ya] = !0)
          : (O[Rh] = !0)
        : (O[Oh] = !0),
    nx(n, w, w, O)
  }
  return (
    nx(n, 'localhost', Sa, { ascii: !0 }),
    (n.jd = new _n(pu)),
    { start: n, tokens: as({ groups: e }, px) }
  )
}
function hx (t, e) {
  const n = l2(e.replace(/[A-Z]/g, (l) => l.toLowerCase()))
  const r = n.length
  const i = []
  let o = 0
  let s = 0
  for (; s < r;) {
    let l = t
    let u = null
    let d = 0
    let f = null
    let h = -1
    let m = -1
    for (; s < r && (u = l.go(n[s]));) {
      (l = u),
      l.accepts()
        ? ((h = 0), (m = 0), (f = l))
        : h >= 0 && ((h += n[s].length), m++),
      (d += n[s].length),
      (o += n[s].length),
      s++
    }
    (o -= h),
    (s -= m),
    (d -= h),
    i.push({ t: f.t, v: e.slice(o - d, o), s: o - d, e: o })
  }
  return i
}
function l2 (t) {
  const e = []
  const n = t.length
  let r = 0
  for (; r < n;) {
    const i = t.charCodeAt(r)
    let o
    const s =
            i < 55296 ||
            i > 56319 ||
            r + 1 === n ||
            (o = t.charCodeAt(r + 1)) < 56320 ||
            o > 57343
              ? t[r]
              : t.slice(r, r + 2)
    e.push(s), (r += s.length)
  }
  return e
}
function _i (t, e, n, r, i) {
  let o
  const s = e.length
  for (let l = 0; l < s - 1; l++) {
    const u = e[l]
    t.j[u]
      ? (o = t.j[u])
      : ((o = new _n(r)), (o.jr = i.slice()), (t.j[u] = o)),
    (t = o)
  }
  return (o = new _n(n)), (o.jr = i.slice()), (t.j[e[s - 1]] = o), o
}
function ix (t) {
  const e = []
  const n = []
  let r = 0
  const i = '0123456789'
  for (; r < t.length;) {
    let o = 0
    for (; i.indexOf(t[r + o]) >= 0;) o++
    if (o > 0) {
      e.push(n.join(''))
      for (let s = parseInt(t.substring(r, r + o), 10); s > 0; s--) {
        n.pop()
      }
      r += o
    } else n.push(t[r]), r++
  }
  return e
}
const Ta = {
  defaultProtocol: 'http',
  events: null,
  format: ox,
  formatHref: ox,
  nl2br: !1,
  tagName: 'a',
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
}
function Gh (t, e = null) {
  let n = as({}, Ta)
  t && (n = as(n, t instanceof Gh ? t.o : t))
  const r = n.ignoreTags
  const i = []
  for (let o = 0; o < r.length; o++) i.push(r[o].toUpperCase());
  (this.o = n), e && (this.defaultRender = e), (this.ignoreTags = i)
}
Gh.prototype = {
  o: Ta,
  ignoreTags: [],
  defaultRender (t) {
    return t
  },
  check (t) {
    return this.get('validate', t.toString(), t)
  },
  get (t, e, n) {
    const r = e != null
    let i = this.o[t]
    return (
      i &&
            (typeof i === 'object'
              ? ((i = n.t in i ? i[n.t] : Ta[t]),
                typeof i === 'function' && r && (i = i(e, n)))
              : typeof i === 'function' && r && (i = i(e, n.t, n)),
            i)
    )
  },
  getObj (t, e, n) {
    let r = this.o[t]
    return typeof r === 'function' && e != null && (r = r(e, n.t, n)), r
  },
  render (t) {
    const e = t.render(this)
    return (this.get('render', null, t) || this.defaultRender)(e, t.t, t)
  }
}
function ox (t) {
  return t
}
function mx (t, e) {
  (this.t = 'token'), (this.v = t), (this.tk = e)
}
mx.prototype = {
  isLink: !1,
  toString () {
    return this.v
  },
  toHref (t) {
    return this.toString()
  },
  toFormattedString (t) {
    const e = this.toString()
    const n = t.get('truncate', e, this)
    const r = t.get('format', e, this)
    return n && r.length > n ? r.substring(0, n) + '\u2026' : r
  },
  toFormattedHref (t) {
    return t.get('formatHref', this.toHref(t.get('defaultProtocol')), this)
  },
  startIndex () {
    return this.tk[0].s
  },
  endIndex () {
    return this.tk[this.tk.length - 1].e
  },
  toObject (t = Ta.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    }
  },
  toFormattedObject (t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    }
  },
  validate (t) {
    return t.get('validate', this.toString(), this)
  },
  render (t) {
    const e = this
    const n = this.toHref(t.get('defaultProtocol'))
    const r = t.get('formatHref', n, this)
    const i = t.get('tagName', n, e)
    const o = this.toFormattedString(t)
    const s = {}
    const l = t.get('className', n, e)
    const u = t.get('target', n, e)
    const d = t.get('rel', n, e)
    const f = t.getObj('attributes', n, e)
    const h = t.getObj('events', n, e)
    return (
      (s.href = r),
      l && (s.class = l),
      u && (s.target = u),
      d && (s.rel = d),
      f && as(s, f),
      { tagName: i, attributes: s, content: o, eventListeners: h }
    )
  }
}
function hu (t, e) {
  class n extends mx {
    constructor (i, o) {
      super(i, o), (this.t = t)
    }
  }
  for (const r in e) n.prototype[r] = e[r]
  return (n.t = t), n
}
const sx = hu('email', {
  isLink: !0,
  toHref () {
    return 'mailto:' + this.toString()
  }
})
const ax = hu('text')
const c2 = hu('nl')
const $c = hu('url', {
  isLink: !0,
  toHref (t = Ta.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`
  },
  hasProtocol () {
    const t = this.tk
    return t.length >= 2 && t[0].t !== Sa && t[1].t === Ti
  }
})
const Jn = (t) => new _n(t)
function u2 ({ groups: t }) {
  const e = t.domain.concat([
    nu,
    ru,
    Si,
    iu,
    ou,
    su,
    au,
    lu,
    Xn,
    Hh,
    wa,
    cu,
    uu,
    du,
    vr,
    pu,
    _a,
    fu
  ])
  const n = [
    Ti,
    Uh,
    Er,
    Wh,
    wa,
    xa,
    Kh,
    Vh,
    Gc,
    qc,
    Ea,
    va,
    Wc,
    Uc,
    Kc,
    Vc,
    Yc,
    Jc,
    Xc,
    Zc,
    jc,
    Qc,
    eu,
    tu
  ]
  const r = [
    nu,
    zh,
    ru,
    iu,
    ou,
    su,
    au,
    lu,
    Xn,
    Ea,
    va,
    wa,
    cu,
    uu,
    du,
    xa,
    vr,
    pu,
    _a,
    fu
  ]
  const i = Jn()
  const o = J(i, _a)
  Pe(o, r, o), Pe(o, t.domain, o)
  const s = Jn()
  const l = Jn()
  const u = Jn()
  Pe(i, t.domain, s),
  Pe(i, t.scheme, l),
  Pe(i, t.slashscheme, u),
  Pe(s, r, o),
  Pe(s, t.domain, s)
  const d = J(s, Si)
  J(o, Si, d), J(l, Si, d), J(u, Si, d)
  const f = J(o, Er)
  Pe(f, r, o), Pe(f, t.domain, o)
  const h = Jn()
  Pe(d, t.domain, h), Pe(h, t.domain, h)
  const m = J(h, Er)
  Pe(m, t.domain, h)
  const b = Jn(sx)
  Pe(m, t.tld, b), Pe(m, t.utld, b), J(d, Sa, b)
  const g = J(h, Xn)
  J(g, Xn, g),
  Pe(g, t.domain, h),
  Pe(b, t.domain, h),
  J(b, Er, m),
  J(b, Xn, g)
  const E = J(b, Ti)
  Pe(E, t.numeric, sx)
  const w = J(s, Xn)
  const S = J(s, Er)
  J(w, Xn, w), Pe(w, t.domain, s), Pe(S, r, o), Pe(S, t.domain, s)
  const O = Jn($c)
  Pe(S, t.tld, O),
  Pe(S, t.utld, O),
  Pe(O, t.domain, s),
  Pe(O, r, o),
  J(O, Er, S),
  J(O, Xn, w),
  J(O, Si, d)
  const k = J(O, Ti)
  const T = Jn($c)
  Pe(k, t.numeric, T)
  const P = Jn($c)
  const I = Jn()
  Pe(P, e, P),
  Pe(P, n, I),
  Pe(I, e, P),
  Pe(I, n, I),
  J(O, vr, P),
  J(T, vr, P)
  const Y = J(l, Ti)
  const ne = J(u, Ti)
  const q = J(ne, vr)
  const Q = J(q, vr)
  Pe(l, t.domain, s),
  J(l, Er, S),
  J(l, Xn, w),
  Pe(u, t.domain, s),
  J(u, Er, S),
  J(u, Xn, w),
  Pe(Y, t.domain, P),
  J(Y, vr, P),
  J(Y, xa, P),
  Pe(Q, t.domain, P),
  Pe(Q, e, P),
  J(Q, vr, P)
  const fe = [
    [Ea, va],
    [Uc, Wc],
    [Kc, Vc],
    [Gc, qc],
    [Yc, Jc],
    [Xc, Zc],
    [jc, Qc],
    [eu, tu]
  ]
  for (let we = 0; we < fe.length; we++) {
    const [me, Ce] = fe[we]
    const ge = J(P, me)
    J(I, me, ge), J(ge, Ce, P)
    const ye = Jn($c)
    Pe(ge, e, ye)
    const A = Jn()
    Pe(ge, n),
    Pe(ye, e, ye),
    Pe(ye, n, A),
    Pe(A, e, ye),
    Pe(A, n, A),
    J(ye, Ce, P),
    J(A, Ce, P)
  }
  return J(i, Sa, O), J(i, $h, c2), { start: i, tokens: px }
}
function d2 (t, e, n) {
  const r = n.length
  let i = 0
  const o = []
  let s = []
  for (; i < r;) {
    let l = t
    let u = null
    let d = null
    let f = 0
    let h = null
    let m = -1
    for (; i < r && !(u = l.go(n[i].t));) s.push(n[i++])
    for (; i < r && (d = u || l.go(n[i].t));) {
      (u = null),
      (l = d),
      l.accepts() ? ((m = 0), (h = l)) : m >= 0 && m++,
      i++,
      f++
    }
    if (m < 0) (i -= f), i < r && (s.push(n[i]), i++)
    else {
      s.length > 0 && (o.push(kh(ax, e, s)), (s = [])),
      (i -= m),
      (f -= m)
      const b = h.t
      const g = n.slice(i - f, i)
      o.push(kh(b, e, g))
    }
  }
  return s.length > 0 && o.push(kh(ax, e, s)), o
}
function kh (t, e, n) {
  const r = n[0].s
  const i = n[n.length - 1].e
  const o = e.slice(r, i)
  return new t(o, n)
}
const f2 = (typeof console < 'u' && console && console.warn) || (() => {})
const p2 =
    'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.'
const at = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
}
function gx () {
  return (
    (_n.groups = {}),
    (at.scanner = null),
    (at.parser = null),
    (at.tokenQueue = []),
    (at.pluginQueue = []),
    (at.customSchemes = []),
    (at.initialized = !1),
    at
  )
}
function qh (t, e = !1) {
  if (
    (at.initialized &&
            f2(
                `linkifyjs: already initialized - will not register custom scheme "${t}" ${p2}`
            ),
    !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
  ) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`)
  }
  at.customSchemes.push([t, e])
}
function h2 () {
  at.scanner = a2(at.customSchemes)
  for (let t = 0; t < at.tokenQueue.length; t++) {
    at.tokenQueue[t][1]({ scanner: at.scanner })
  }
  at.parser = u2(at.scanner.tokens)
  for (let t = 0; t < at.pluginQueue.length; t++) {
    at.pluginQueue[t][1]({ scanner: at.scanner, parser: at.parser })
  }
  return (at.initialized = !0), at
}
function mu (t) {
  return (
    at.initialized || h2(), d2(at.parser.start, t, hx(at.scanner.start, t))
  )
}
mu.scan = hx
function Yh (t, e = null, n = null) {
  if (e && typeof e === 'object') {
    if (n) {
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`)
    }
    (n = e), (e = null)
  }
  const r = new Gh(n)
  const i = mu(t)
  const o = []
  for (let s = 0; s < i.length; s++) {
    const l = i[s]
    l.isLink &&
            (!e || l.t === e) &&
            r.check(l) &&
            o.push(l.toFormattedObject(r))
  }
  return o
}
function m2 (t) {
  return t.length === 1
    ? t[0].isLink
    : t.length === 3 && t[1].isLink
      ? ['()', '[]'].includes(t[0].value + t[2].value)
      : !1
}
function g2 (t) {
  return new Oe({
    key: new ze('autolink'),
    appendTransaction: (e, n, r) => {
      const i = e.some((d) => d.docChanged) && !n.doc.eq(r.doc)
      const o = e.some((d) => d.getMeta('preventAutolink'))
      if (!i || o) return
      const { tr: s } = r
      const l = nv(n.doc, [...e])
      if (
        (iv(l).forEach(({ newRange: d }) => {
          const f = rv(r.doc, d, (b) => b.isTextblock)
          let h
          let m
          if (
            (f.length > 1
              ? ((h = f[0]),
                (m = r.doc.textBetween(
                  h.pos,
                  h.pos + h.node.nodeSize,
                  void 0,
                  ' '
                )))
              : f.length &&
                              r.doc
                                .textBetween(d.from, d.to, ' ', ' ')
                                .endsWith(' ') &&
                              ((h = f[0]),
                              (m = r.doc.textBetween(
                                h.pos,
                                d.to,
                                void 0,
                                ' '
                              ))),
            h && m)
          ) {
            const b = m.split(' ').filter((S) => S !== '')
            if (b.length <= 0) return !1
            const g = b[b.length - 1]
            const E = h.pos + m.lastIndexOf(g)
            if (!g) return !1
            const w = mu(g).map((S) =>
              S.toObject(t.defaultProtocol)
            )
            if (!m2(w)) return !1
            w.filter((S) => S.isLink)
              .map((S) => ({
                ...S,
                from: E + S.start + 1,
                to: E + S.end + 1
              }))
              .filter((S) =>
                r.schema.marks.code
                  ? !r.doc.rangeHasMark(
                      S.from,
                      S.to,
                      r.schema.marks.code
                    )
                  : !0
              )
              .filter((S) => t.validate(S.value))
              .filter((S) => t.shouldAutoLink(S.value))
              .forEach((S) => {
                pc(S.from, S.to, r.doc).some(
                  (O) => O.mark.type === t.type
                ) ||
                                    s.addMark(
                                      S.from,
                                      S.to,
                                      t.type.create({ href: S.href })
                                    )
              })
          }
        }),
        !!s.steps.length)
      ) {
        return s
      }
    }
  })
}
function b2 (t) {
  return new Oe({
    key: new ze('handleClickLink'),
    props: {
      handleClick: (e, n, r) => {
        let i, o
        if (r.button !== 0 || !e.editable) return !1
        let s = r.target
        const l = []
        for (; s.nodeName !== 'DIV';) l.push(s), (s = s.parentNode)
        if (!l.find((m) => m.nodeName === 'A')) return !1
        const u = Op(e.state, t.type.name)
        const d = r.target
        const f = (i = d?.href) !== null && i !== void 0 ? i : u.href
        const h =
                    (o = d?.target) !== null && o !== void 0 ? o : u.target
        return d && f ? (window.open(f, h), !0) : !1
      }
    }
  })
}
function y2 (t) {
  return new Oe({
    key: new ze('handlePasteLink'),
    props: {
      handlePaste: (e, n, r) => {
        const { state: i } = e
        const { selection: o } = i
        const { empty: s } = o
        if (s) return !1
        let l = ''
        r.content.forEach((d) => {
          l += d.textContent
        })
        const u = Yh(l, { defaultProtocol: t.defaultProtocol }).find(
          (d) => d.isLink && d.value === l
        )
        return !l || !u
          ? !1
          : t.editor.commands.setMark(t.type, { href: u.href })
      }
    }
  })
}
const E2 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
function go (t, e) {
  const n = [
    'http',
    'https',
    'ftp',
    'ftps',
    'mailto',
    'tel',
    'callto',
    'sms',
    'cid',
    'xmpp'
  ]
  return (
    e &&
            e.forEach((r) => {
              const i = typeof r === 'string' ? r : r.scheme
              i && n.push(i)
            }),
    !t ||
            t
              .replace(E2, '')
              .match(
                new RegExp(
                        `^(?:(?:${n.join('|')}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`,
                        'i'
                )
              )
  )
}
const bx = st.create({
  name: 'link',
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate () {
    this.options.validate &&
            !this.options.shouldAutoLink &&
            ((this.options.shouldAutoLink = this.options.validate),
            console.warn(
              'The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.'
            )),
    this.options.protocols.forEach((t) => {
      if (typeof t === 'string') {
        qh(t)
        return
      }
      qh(t.scheme, t.optionalSlashes)
    })
  },
  onDestroy () {
    gx()
  },
  inclusive () {
    return this.options.autolink
  },
  addOptions () {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: 'http',
      HTMLAttributes: {
        target: '_blank',
        rel: 'noopener noreferrer nofollow',
        class: null
      },
      isAllowedUri: (t, e) => !!go(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    }
  },
  addAttributes () {
    return {
      href: {
        default: null,
        parseHTML (t) {
          return t.getAttribute('href')
        }
      },
      target: { default: this.options.HTMLAttributes.target },
      rel: { default: this.options.HTMLAttributes.rel },
      class: { default: this.options.HTMLAttributes.class }
    }
  },
  parseHTML () {
    return [
      {
        tag: 'a[href]',
        getAttrs: (t) => {
          const e = t.getAttribute('href')
          return !e ||
                        !this.options.isAllowedUri(e, {
                          defaultValidate: (n) =>
                            !!go(n, this.options.protocols),
                          protocols: this.options.protocols,
                          defaultProtocol: this.options.defaultProtocol
                        })
            ? !1
            : null
        }
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!go(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })
      ? ['a', ee(this.options.HTMLAttributes, t), 0]
      : ['a', ee(this.options.HTMLAttributes, { ...t, href: '' }), 0]
  },
  addCommands () {
    return {
      setLink:
                (t) =>
                  ({ chain: e }) => {
                    const { href: n } = t
                    return this.options.isAllowedUri(n, {
                      defaultValidate: (r) => !!go(r, this.options.protocols),
                      protocols: this.options.protocols,
                      defaultProtocol: this.options.defaultProtocol
                    })
                      ? e()
                        .setMark(this.name, t)
                        .setMeta('preventAutolink', !0)
                        .run()
                      : !1
                  },
      toggleLink:
                (t) =>
                  ({ chain: e }) => {
                    const { href: n } = t
                    return this.options.isAllowedUri(n, {
                      defaultValidate: (r) => !!go(r, this.options.protocols),
                      protocols: this.options.protocols,
                      defaultProtocol: this.options.defaultProtocol
                    })
                      ? e()
                        .toggleMark(this.name, t, {
                          extendEmptyMarkRange: !0
                        })
                        .setMeta('preventAutolink', !0)
                        .run()
                      : !1
                  },
      unsetLink:
                () =>
                  ({ chain: t }) =>
                    t()
                      .unsetMark(this.name, { extendEmptyMarkRange: !0 })
                      .setMeta('preventAutolink', !0)
                      .run()
    }
  },
  addPasteRules () {
    return [
      xn({
        find: (t) => {
          const e = []
          if (t) {
            const { protocols: n, defaultProtocol: r } =
                            this.options
            const i = Yh(t).filter(
              (o) =>
                o.isLink &&
                                this.options.isAllowedUri(o.value, {
                                  defaultValidate: (s) => !!go(s, n),
                                  protocols: n,
                                  defaultProtocol: r
                                })
            )
            i.length &&
                            i.forEach((o) =>
                              e.push({
                                text: o.value,
                                data: { href: o.href },
                                index: o.start
                              })
                            )
          }
          return e
        },
        type: this.type,
        getAttributes: (t) => {
          let e
          return {
            href:
                            (e = t.data) === null || e === void 0
                              ? void 0
                              : e.href
          }
        }
      })
    ]
  },
  addProseMirrorPlugins () {
    const t = []
    const { protocols: e, defaultProtocol: n } = this.options
    return (
      this.options.autolink &&
                t.push(
                  g2({
                    type: this.type,
                    defaultProtocol: this.options.defaultProtocol,
                    validate: (r) =>
                      this.options.isAllowedUri(r, {
                        defaultValidate: (i) => !!go(i, e),
                        protocols: e,
                        defaultProtocol: n
                      }),
                    shouldAutoLink: this.options.shouldAutoLink
                  })
                ),
      this.options.openOnClick === !0 && t.push(b2({ type: this.type })),
      this.options.linkOnPaste &&
                t.push(
                  y2({
                    editor: this.editor,
                    defaultProtocol: this.options.defaultProtocol,
                    type: this.type
                  })
                ),
      t
    )
  }
})
const Jh = bx.extend({
  addOptions () {
    return {
      ...this.parent?.(),
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      HTMLAttributes: {}
    }
  },
  addAttributes () {
    return {
      href: { default: null },
      id: { default: null },
      target: { default: this.options.HTMLAttributes.target },
      hreflang: { default: null },
      rel: { default: null },
      referrerpolicy: { default: null },
      class: { default: null },
      as_button: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-as-button'),
        renderHTML: (t) => ({ 'data-as-button': t.as_button })
      },
      button_theme: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-as-button-theme'),
        renderHTML: (t) => ({ 'data-as-button-theme': t.button_theme })
      }
    }
  }
})
const v2 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/
const yx = ce.create({
  name: 'image',
  addOptions () {
    return { inline: !1, allowBase64: !1, HTMLAttributes: {} }
  },
  inline () {
    return this.options.inline
  },
  group () {
    return this.options.inline ? 'inline' : 'block'
  },
  draggable: !0,
  addAttributes () {
    return {
      src: { default: null },
      alt: { default: null },
      title: { default: null }
    }
  },
  parseHTML () {
    return [
      {
        tag: this.options.allowBase64
          ? 'img[src]'
          : 'img[src]:not([src^="data:"])'
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['img', ee(this.options.HTMLAttributes, t)]
  },
  addCommands () {
    return {
      setImage:
                (t) =>
                  ({ commands: e }) =>
                    e.insertContent({ type: this.name, attrs: t })
    }
  },
  addInputRules () {
    return [
      gc({
        find: v2,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, r] = t
          return { src: n, alt: e, title: r }
        }
      })
    ]
  }
})
const Xh = yx.extend({
  addAttributes () {
    return {
      src: { default: null },
      alt: { default: null },
      title: { default: null },
      width: { default: null },
      height: { default: null },
      lazy: {
        default: null,
        parseHTML: (t) =>
          t.getAttribute('loading') === 'lazy'
            ? t.getAttribute('data-lazy')
            : null,
        renderHTML: (t) => {
          if (t.lazy) return { 'data-lazy': t.lazy, loading: 'lazy' }
        }
      },
      srcset: { default: null },
      sizes: { default: null },
      media: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-media-id'),
        renderHTML: (t) =>
          t.media ? { 'data-media-id': t.media } : {}
      }
    }
  }
})
const w2 = wc.extend({
  addAttributes () {
    return { class: { default: null } }
  }
})
const Zh = st.create({
  name: 'small',
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [{ tag: 'small' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['small', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      setSmall:
                () =>
                  ({ commands: t }) =>
                    t.setMark(this.name),
      toggleSmall:
                () =>
                  ({ commands: t }) =>
                    t.toggleMark(this.name),
      unsetSmall:
                () =>
                  ({ commands: t }) =>
                    t.unsetMark(this.name)
    }
  }
})
function Ex (t, e = null) {
  return e ? t.createChecked(null, e) : t.createAndFill()
}
function vx (t) {
  if (t.cached.gridNodeTypes) return t.cached.gridNodeTypes
  const e = {}
  return (
    Object.keys(t.nodes).forEach((n) => {
      const r = t.nodes[n]
      r.spec.gridRole && (e[r.spec.gridRole] = r)
    }),
    (t.cached.gridNodeTypes = e),
    e
  )
}
function wx (t, e, n, r) {
  const i = vx(t)
  const o = []
  for (let s = 0; s < e; s += 1) {
    const l = Ex(i.column, r)
    l && o.push(l)
  }
  return i.grid.createChecked({ cols: e, type: n }, o)
}
const jh = ce.create({
  name: 'grid',
  group: 'block',
  defining: !0,
  isolating: !0,
  allowGapCursor: !1,
  content: 'gridColumn+',
  gridRole: 'grid',
  addOptions () {
    return { HTMLAttributes: { class: 'filament-tiptap-grid' } }
  },
  addAttributes () {
    return {
      type: {
        default: 'responsive',
        parseHTML: (t) => t.getAttribute('type')
      },
      cols: { default: 2, parseHTML: (t) => t.getAttribute('cols') }
    }
  },
  parseHTML () {
    return [
      {
        tag: 'div',
        getAttrs: (t) =>
          t.classList.contains('filament-tiptap-grid') && null
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['div', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      insertGrid:
                ({ cols: t = 3, type: e = 'responsive' } = {}) =>
                  ({ tr: n, dispatch: r, editor: i }) => {
                    const o = wx(i.schema, t, e)
                    if (r) {
                      const s = n.selection.anchor + 1
                      n.replaceSelectionWith(o)
                        .scrollIntoView()
                        .setSelection(le.near(n.doc.resolve(s)))
                    }
                    return !0
                  }
    }
  },
  addKeyboardShortcuts () {
    return { 'Mod-Alt-G': () => this.editor.commands.insertGrid() }
  },
  extendNodeSchema (t) {
    const e = { name: t.name, options: t.options, storage: t.storage }
    return { gridRole: Te(re(t, 'gridRole', e)) }
  }
})
const Qh = ce.create({
  name: 'gridColumn',
  content: 'block+',
  gridRole: 'column',
  isolating: !0,
  addOptions () {
    return { HTMLAttributes: { class: 'filament-tiptap-grid__column' } }
  },
  parseHTML () {
    return [
      {
        tag: 'div',
        getAttrs: (t) =>
          t.classList.contains('filament-tiptap-grid__column') &&
                    null
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['div', ee(this.options.HTMLAttributes, t), 0]
  }
})
const xx = (t) => t.match(/(youtube\.com|youtu\.be)(.+)?$/)
const x2 = (t = !1) =>
  t
    ? 'https://www.youtube-nocookie.com/embed/'
    : 'https://www.youtube.com/embed/'
const em = (t) => {
  const { url: e, controls: n, nocookie: r, startAt: i } = t
  let o = null
  if (e.includes('/embed/')) return e
  if (
    (e.includes('youtu.be') && (o = e.split('/').pop()),
    e.includes('/shorts/') && (o = e.split('/shorts/').pop()),
    !o)
  ) {
    const d = /v=([-\w]+)/gm.exec(e)
    d && d[1] && (o = d[1])
  }
  if (!o) return null
  let s = `${x2(r)}${o}`
  const l = []
  return (
    n ? l.push('controls=1') : l.push('controls=0'),
    i && l.push(`start=${i}`),
    l.length && (s += `?${l.join('&')}`),
    s
  )
}
const tm = ce.create({
  name: 'youtube',
  selectable: !0,
  draggable: !0,
  atom: !0,
  addOptions () {
    return { inline: !1, HTMLAttributes: {}, width: 640, height: 480 }
  },
  inline () {
    return this.options.inline
  },
  group () {
    return this.options.inline ? 'inline' : 'block'
  },
  addAttributes () {
    return {
      style: { default: null, parseHTML: (t) => t.getAttribute('style') },
      src: { default: null },
      width: {
        default: this.options.width,
        parseHTML: (t) => t.getAttribute('width')
      },
      height: {
        default: this.options.height,
        parseHTML: (t) => t.getAttribute('height')
      },
      responsive: {
        default: !0,
        parseHTML: (t) => t.classList.contains('responsive') ?? !1
      },
      start: { default: 0 },
      controls: { default: !0 },
      nocookie: { default: !1 },
      'data-aspect-width': {
        default: null,
        parseHTML: (t) => t.getAttribute('data-aspect-width')
      },
      'data-aspect-height': {
        default: null,
        parseHTML: (t) => t.getAttribute('data-aspect-height')
      }
    }
  },
  parseHTML () {
    return [{ tag: 'div[data-youtube-video] iframe' }]
  },
  addCommands () {
    return {
      setYoutubeVideo:
                (t) =>
                  ({ commands: e }) => {
                    if (!xx(t.src)) return !1
                    const n = em({
                      url: t.src,
                      controls: t.controls,
                      nocookie: t.nocookie,
                      startAt: t.start || 0
                    })
                    return e.insertContent({
                      type: this.name,
                      attrs: { ...t, src: n }
                    })
                  }
    }
  },
  renderHTML ({ HTMLAttributes: t }) {
    const e = em({
      url: t.src,
      controls: t.controls,
      nocookie: t.nocookie,
      startAt: t.start || 0
    })
    return [
      'div',
      {
        'data-youtube-video': '',
        class: t.responsive ? 'responsive' : null
      },
      [
        'iframe',
        {
          src: e,
          width: t.width,
          height: t.height,
          allowfullscreen: this.options.allowFullscreen,
          style: t.responsive
            ? `aspect-ratio: ${t['data-aspect-width']} / ${t['data-aspect-height']}; width: 100%; height: auto;`
            : null,
          'data-aspect-width': t.responsive
            ? t['data-aspect-width']
            : null,
          'data-aspect-height': t.responsive
            ? t['data-aspect-height']
            : null
        }
      ]
    ]
  }
})
const _x = (t) => t.match(/(vimeo\.com)(.+)?$/)
const nm = (t) => {
  const {
    url: e,
    autoplay: n,
    loop: r,
    title: i,
    byline: o,
    portrait: s
  } = t
  if (e.includes('/video/')) return e
  const u = /\.com\/([0-9]+)/gm.exec(e)
  if (!u || !u[1]) return null
  let d = `https://player.vimeo.com/video/${u[1]}`
  const f = [
        `autoplay=${n}`,
        `loop=${r}`,
        `title=${i}`,
        `byline=${o}`,
        `portrait=${s}`
  ]
  return (d += `?${f.join('&')}`), d
}
const rm = ce.create({
  name: 'vimeo',
  selectable: !0,
  draggable: !0,
  atom: !0,
  addOptions () {
    return {
      inline: !1,
      HTMLAttributes: {},
      allowFullscreen: !0,
      width: 640,
      height: 480
    }
  },
  inline () {
    return this.options.inline
  },
  group () {
    return this.options.inline ? 'inline' : 'block'
  },
  addAttributes () {
    return {
      style: { default: null, parseHTML: (t) => t.getAttribute('style') },
      src: { default: null },
      width: {
        default: this.options.width,
        parseHTML: (t) => t.getAttribute('width')
      },
      height: {
        default: this.options.height,
        parseHTML: (t) => t.getAttribute('height')
      },
      autoplay: { default: 0 },
      loop: { default: 0 },
      title: { default: 0 },
      byline: { default: 0 },
      portrait: { default: 0 },
      responsive: {
        default: !0,
        parseHTML: (t) => t.classList.contains('responsive') ?? !1
      },
      'data-aspect-width': {
        default: null,
        parseHTML: (t) => t.getAttribute('data-aspect-width')
      },
      'data-aspect-height': {
        default: null,
        parseHTML: (t) => t.getAttribute('data-aspect-height')
      }
    }
  },
  parseHTML () {
    return [{ tag: 'div[data-vimeo-video] iframe' }]
  },
  addCommands () {
    return {
      setVimeoVideo:
                (t) =>
                  ({ commands: e }) => {
                    if (!_x(t.src)) return !1
                    const n = nm({
                      url: t.src,
                      autoplay: t?.autoplay || 0,
                      loop: t?.loop || 0,
                      title: t?.title || 0,
                      byline: t?.byline || 0,
                      portrait: t?.portrait || 0
                    })
                    return e.insertContent({
                      type: this.name,
                      attrs: { ...t, src: n }
                    })
                  }
    }
  },
  renderHTML ({ HTMLAttributes: t }) {
    const e = nm({
      url: t.src,
      autoplay: t?.autoplay || 0,
      loop: t?.loop || 0,
      title: t?.title || 0,
      byline: t?.byline || 0,
      portrait: t?.portrait || 0
    })
    return [
      'div',
      {
        'data-vimeo-video': '',
        class: t.responsive ? 'responsive' : null
      },
      [
        'iframe',
        {
          src: e,
          width: t.width,
          height: t.height,
          allowfullscreen: this.options.allowfullscreen,
          frameborder: 0,
          allow: 'autoplay; fullscreen; picture-in-picture',
          style: t.responsive
            ? `aspect-ratio: ${t['data-aspect-width']} / ${t['data-aspect-height']}; width: 100%; height: auto;`
            : null,
          'data-aspect-width': t.responsive
            ? t['data-aspect-width']
            : null,
          'data-aspect-height': t.responsive
            ? t['data-aspect-height']
            : null
        }
      ]
    ]
  }
})
const im = ce.create({
  name: 'video',
  selectable: !0,
  draggable: !0,
  atom: !0,
  inline () {
    return this.options.inline
  },
  group () {
    return this.options.inline ? 'inline' : 'block'
  },
  addOptions () {
    return {
      inline: !1,
      HTMLAttributes: { autoplay: null, controls: null, loop: null },
      width: 640,
      height: 480
    }
  },
  addAttributes () {
    return {
      style: { default: null, parseHTML: (t) => t.getAttribute('style') },
      responsive: {
        default: !0,
        parseHTML: (t) => t.classList.contains('responsive') ?? !1
      },
      src: { default: null },
      width: {
        default: this.options.width,
        parseHTML: (t) => t.getAttribute('width')
      },
      height: {
        default: this.options.height,
        parseHTML: (t) => t.getAttribute('height')
      },
      autoplay: {
        default: null,
        parseHTML: (t) => t.getAttribute('autoplay')
      },
      controls: {
        default: null,
        parseHTML: (t) => t.getAttribute('controls')
      },
      loop: { default: null, parseHTML: (t) => t.getAttribute('loop') },
      'data-aspect-width': {
        default: null,
        parseHTML: (t) => t.getAttribute('data-aspect-width')
      },
      'data-aspect-height': {
        default: null,
        parseHTML: (t) => t.getAttribute('data-aspect-height')
      }
    }
  },
  parseHTML () {
    return [{ tag: 'div[data-native-video] video' }]
  },
  addCommands () {
    return {
      setVideo:
                (t) =>
                  ({ commands: e }) =>
                    e.insertContent({ type: this.name, attrs: t })
    }
  },
  renderHTML ({ HTMLAttributes: t }) {
    return [
      'div',
      {
        'data-native-video': '',
        class: t.responsive ? 'responsive' : null
      },
      [
        'video',
        {
          src: t.src,
          width: t.width,
          height: t.height,
          autoplay: t.autoplay ? 'true' : null,
          controls: t.controls ? 'true' : null,
          loop: t.loop ? 'true' : null,
          style: t.responsive
            ? `aspect-ratio: ${t['data-aspect-width']} / ${t['data-aspect-height']}; width: 100%; height: auto;`
            : null,
          'data-aspect-width': t.responsive
            ? t['data-aspect-width']
            : null,
          'data-aspect-height': t.responsive
            ? t['data-aspect-height']
            : null
        }
      ]
    ]
  }
})
const om = ce.create({
  name: 'details',
  content: 'detailsSummary detailsContent',
  group: 'block',
  defining: !0,
  isolating: !0,
  allowGapCursor: !1,
  addOptions () {
    return { HTMLAttributes: {} }
  },
  addAttributes () {
    return {}
  },
  parseHTML () {
    return [{ tag: 'details' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['details', ee(this.options.HTMLAttributes, t), 0]
  },
  addNodeView () {
    return ({ editor: t, getPos: e, node: n, HTMLAttributes: r }) => {
      const i = document.createElement('div')
      const o = document.createElement('div')
      const s = ee(this.options.HTMLAttributes, r, {
        'data-type': this.name
      })
      return (
        Object.entries(s).forEach(([l, u]) => i.setAttribute(l, u)),
        {
          dom: i,
          contentDOM: i,
          ignoreMutation (l) {
            return l.type === 'selection'
              ? !1
              : !i.contains(l.target) || i === l.target
          },
          update: (l) => l.type === this.type
        }
      )
    }
  },
  addCommands () {
    return {
      setDetails:
                () =>
                  ({ state: t, chain: e }) => {
                    let n
                    const { schema: r, selection: i } = t
                    const { $from: o, $to: s } = i
                    const l = o.blockRange(s)
                    if (!l) return !1
                    const u = t.doc.slice(l.start, l.end)
                    if (
                      !r.nodes.detailsContent.contentMatch.matchFragment(
                        u.content
                      )
                    ) {
                      return !1
                    }
                    const f =
                        ((n = u.toJSON()) === null || n === void 0
                          ? void 0
                          : n.content) || []
                    return e()
                      .insertContentAt(
                        { from: l.start, to: l.end },
                        {
                          type: this.name,
                          content: [
                            { type: 'detailsSummary' },
                            { type: 'detailsContent', content: f }
                          ]
                        }
                      )
                      .setTextSelection(l.start + 2)
                      .run()
                  },
      unsetDetails:
                () =>
                  ({ state: t, chain: e }) => {
                    const { selection: n, schema: r } = t
                    const i = to((S) => S.type === this.type)(n)
                    if (!i) return !1
                    const o = eo(
                      i.node,
                      (S) => S.type === r.nodes.detailsSummary
                    )
                    const s = eo(
                      i.node,
                      (S) => S.type === r.nodes.detailsContent
                    )
                    if (!o.length || !s.length) return !1
                    const l = o[0]
                    const u = s[0]
                    const d = i.pos
                    const f = t.doc.resolve(d)
                    const h = d + i.node.nodeSize
                    const m = { from: d, to: h }
                    const b = u.node.content.toJSON() || []
                    const g = f.parent.type.contentMatch.defaultType
                    const w = [g?.create(null, l.node.content).toJSON(), ...b]
                    return e()
                      .insertContentAt(m, w)
                      .setTextSelection(d + 1)
                      .run()
                  }
    }
  },
  addKeyboardShortcuts () {
    return {
      Backspace: () => {
        const { schema: t, selection: e } = this.editor.state
        const { empty: n, $anchor: r } = e
        return !n || r.parent.type !== t.nodes.detailsSummary
          ? !1
          : r.parentOffset !== 0
            ? this.editor.commands.command(({ tr: i }) => {
              const o = r.pos - 1
              const s = r.pos
              return i.delete(o, s), !0
            })
            : this.editor.commands.unsetDetails()
      }
    }
  }
})
const sm = ce.create({
  name: 'detailsSummary',
  content: 'text*',
  defining: !0,
  selectable: !1,
  isolating: !0,
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [{ tag: 'summary' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['summary', ee(this.options.HTMLAttributes, t), 0]
  }
})
const am = ce.create({
  name: 'detailsContent',
  content: 'block+',
  defining: !0,
  selectable: !1,
  addOptions () {
    return { HTMLAttributes: {} }
  },
  parseHTML () {
    return [{ tag: 'div[data-type="details-content"]' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return [
      'div',
      ee(this.options.HTMLAttributes, t, {
        'data-type': 'details-content'
      }),
      0
    ]
  },
  addKeyboardShortcuts () {
    return {
      Enter: ({ editor: t }) => {
        const { state: e, view: n } = t
        const { selection: r } = e
        const { $from: i, empty: o } = r
        const s = to((fe) => fe.type === this.type)(r)
        if (!o || !s || !s.node.childCount) return !1
        const l = i.index(s.depth)
        const { childCount: u } = s.node
        if (!(u === l + 1)) return !1
        const f = s.node.type.contentMatch.defaultType
        const h = f?.createAndFill()
        if (!h) return !1
        const m = e.doc.resolve(s.pos + 1)
        const b = u - 1
        const g = s.node.child(b)
        const E = m.posAtIndex(b, s.depth)
        if (!g.eq(h)) return !1
        const S = i.node(-3)
        if (!S) return !1
        const O = i.indexAfter(-3)
        const k = Mp(S.contentMatchAt(O))
        if (!k || !S.canReplaceWith(O, O, k)) return !1
        const T = k.createAndFill()
        if (!T) return !1
        const { tr: P } = e
        const I = i.after(-2)
        P.replaceWith(I, I, T)
        const Y = P.doc.resolve(I)
        const ne = ue.near(Y, 1)
        P.setSelection(ne)
        const q = E
        const Q = E + g.nodeSize
        return P.delete(q, Q), P.scrollIntoView(), n.dispatch(P), !0
      }
    }
  }
})
const _2 = /^```([a-z]+)?[\s\n]$/
const S2 = /^~~~([a-z]+)?[\s\n]$/
const Sx = ce.create({
  name: 'codeBlock',
  addOptions () {
    return {
      languageClassPrefix: 'language-',
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    }
  },
  content: 'text*',
  marks: '',
  group: 'block',
  code: !0,
  defining: !0,
  addAttributes () {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          let e
          const { languageClassPrefix: n } = this.options
          const o = [
            ...(((e = t.firstElementChild) === null || e === void 0
              ? void 0
              : e.classList) || [])
          ]
            .filter((s) => s.startsWith(n))
            .map((s) => s.replace(n, ''))[0]
          return o || null
        },
        rendered: !1
      }
    }
  },
  parseHTML () {
    return [{ tag: 'pre', preserveWhitespace: 'full' }]
  },
  renderHTML ({ node: t, HTMLAttributes: e }) {
    return [
      'pre',
      ee(this.options.HTMLAttributes, e),
      [
        'code',
        {
          class: t.attrs.language
            ? this.options.languageClassPrefix + t.attrs.language
            : null
        },
        0
      ]
    ]
  },
  addCommands () {
    return {
      setCodeBlock:
                (t) =>
                  ({ commands: e }) =>
                    e.setNode(this.name, t),
      toggleCodeBlock:
                (t) =>
                  ({ commands: e }) =>
                    e.toggleNode(this.name, 'paragraph', t)
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection
        const n = e.pos === 1
        return !t || e.parent.type.name !== this.name
          ? !1
          : n || !e.parent.textContent.length
            ? this.editor.commands.clearNodes()
            : !1
      },
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter) return !1
        const { state: e } = t
        const { selection: n } = e
        const { $from: r, empty: i } = n
        if (!i || r.parent.type !== this.type) return !1
        const o = r.parentOffset === r.parent.nodeSize - 2
        const s = r.parent.textContent.endsWith(`

`)
        return !o || !s
          ? !1
          : t
            .chain()
            .command(
              ({ tr: l }) => (l.delete(r.pos - 2, r.pos), !0)
            )
            .exitCode()
            .run()
      },
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown) return !1
        const { state: e } = t
        const { selection: n, doc: r } = e
        const { $from: i, empty: o } = n
        if (
          !o ||
                    i.parent.type !== this.type ||
                    !(i.parentOffset === i.parent.nodeSize - 2)
        ) {
          return !1
        }
        const l = i.after()
        return l === void 0
          ? !1
          : r.nodeAt(l)
            ? t.commands.command(
              ({ tr: d }) => (
                d.setSelection(ue.near(r.resolve(l))), !0
              )
            )
            : t.commands.exitCode()
      }
    }
  },
  addInputRules () {
    return [
      sa({
        find: _2,
        type: this.type,
        getAttributes: (t) => ({ language: t[1] })
      }),
      sa({
        find: S2,
        type: this.type,
        getAttributes: (t) => ({ language: t[1] })
      })
    ]
  },
  addProseMirrorPlugins () {
    return [
      new Oe({
        key: new ze('codeBlockVSCodeHandler'),
        props: {
          handlePaste: (t, e) => {
            if (
              !e.clipboardData ||
                            this.editor.isActive(this.type.name)
            ) {
              return !1
            }
            const n = e.clipboardData.getData('text/plain')
            const r = e.clipboardData.getData('vscode-editor-data')
            const i = r ? JSON.parse(r) : void 0
            const o = i?.mode
            if (!n || !o) return !1
            const { tr: s, schema: l } = t.state
            const u = l.text(
              n.replace(
                /\r\n?/g,
                                `
`
              )
            )
            return (
              s.replaceSelectionWith(
                this.type.create({ language: o }, u)
              ),
              s.selection.$from.parent.type !== this.type &&
                                s.setSelection(
                                  le.near(
                                    s.doc.resolve(
                                      Math.max(0, s.selection.from - 2)
                                    )
                                  )
                                ),
              s.setMeta('paste', !0),
              t.dispatch(s),
              !0
            )
          }
        }
      })
    ]
  }
})
function T2 (t) {
  return t &&
        t.__esModule &&
        Object.prototype.hasOwnProperty.call(t, 'default')
    ? t.default
    : t
}
function Ix (t) {
  return (
    t instanceof Map
      ? (t.clear =
                  t.delete =
                  t.set =
                      function () {
                        throw new Error('map is read-only')
                      })
      : t instanceof Set &&
              (t.add =
                  t.clear =
                  t.delete =
                      function () {
                        throw new Error('set is read-only')
                      }),
    Object.freeze(t),
    Object.getOwnPropertyNames(t).forEach((e) => {
      const n = t[e]
      const r = typeof n;
      (r === 'object' || r === 'function') &&
                !Object.isFrozen(n) &&
                Ix(n)
    }),
    t
  )
}
const bu = class {
  constructor (e) {
    e.data === void 0 && (e.data = {}),
    (this.data = e.data),
    (this.isMatchIgnored = !1)
  }

  ignoreMatch () {
    this.isMatchIgnored = !0
  }
}
function Dx (t) {
  return t
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
}
function Ci (t, ...e) {
  const n = Object.create(null)
  for (const r in t) n[r] = t[r]
  return (
    e.forEach(function (r) {
      for (const i in r) n[i] = r[i]
    }),
    n
  )
}
const C2 = '</span>'
const Tx = (t) => !!t.scope
const A2 = (t, { prefix: e }) => {
  if (t.startsWith('language:')) {
    return t.replace('language:', 'language-')
  }
  if (t.includes('.')) {
    const n = t.split('.')
    return [
            `${e}${n.shift()}`,
            ...n.map((r, i) => `${r}${'_'.repeat(i + 1)}`)
    ].join(' ')
  }
  return `${e}${t}`
}
const cm = class {
  constructor (e, n) {
    (this.buffer = ''), (this.classPrefix = n.classPrefix), e.walk(this)
  }

  addText (e) {
    this.buffer += Dx(e)
  }

  openNode (e) {
    if (!Tx(e)) return
    const n = A2(e.scope, { prefix: this.classPrefix })
    this.span(n)
  }

  closeNode (e) {
    Tx(e) && (this.buffer += C2)
  }

  value () {
    return this.buffer
  }

  span (e) {
    this.buffer += `<span class="${e}">`
  }
}
const Cx = (t = {}) => {
  const e = { children: [] }
  return Object.assign(e, t), e
}
const um = class t {
  constructor () {
    (this.rootNode = Cx()), (this.stack = [this.rootNode])
  }

  get top () {
    return this.stack[this.stack.length - 1]
  }

  get root () {
    return this.rootNode
  }

  add (e) {
    this.top.children.push(e)
  }

  openNode (e) {
    const n = Cx({ scope: e })
    this.add(n), this.stack.push(n)
  }

  closeNode () {
    if (this.stack.length > 1) return this.stack.pop()
  }

  closeAllNodes () {
    for (; this.closeNode(););
  }

  toJSON () {
    return JSON.stringify(this.rootNode, null, 4)
  }

  walk (e) {
    return this.constructor._walk(e, this.rootNode)
  }

  static _walk (e, n) {
    return (
      typeof n === 'string'
        ? e.addText(n)
        : n.children &&
                  (e.openNode(n),
                  n.children.forEach((r) => this._walk(e, r)),
                  e.closeNode(n)),
      e
    )
  }

  static _collapse (e) {
    typeof e !== 'string' &&
            e.children &&
            (e.children.every((n) => typeof n === 'string')
              ? (e.children = [e.children.join('')])
              : e.children.forEach((n) => {
                t._collapse(n)
              }))
  }
}
const dm = class extends um {
  constructor (e) {
    super(), (this.options = e)
  }

  addText (e) {
    e !== '' && this.add(e)
  }

  startScope (e) {
    this.openNode(e)
  }

  endScope () {
    this.closeNode()
  }

  __addSublanguage (e, n) {
    const r = e.root
    n && (r.scope = `language:${n}`), this.add(r)
  }

  toHTML () {
    return new cm(this, this.options).value()
  }

  finalize () {
    return this.closeAllNodes(), !0
  }
}
function Ca (t) {
  return t ? (typeof t === 'string' ? t : t.source) : null
}
function Lx (t) {
  return yo('(?=', t, ')')
}
function M2 (t) {
  return yo('(?:', t, ')*')
}
function N2 (t) {
  return yo('(?:', t, ')?')
}
function yo (...t) {
  return t.map((n) => Ca(n)).join('')
}
function k2 (t) {
  const e = t[t.length - 1]
  return typeof e === 'object' && e.constructor === Object
    ? (t.splice(t.length - 1, 1), e)
    : {}
}
function pm (...t) {
  return (
    '(' + (k2(t).capture ? '' : '?:') + t.map((r) => Ca(r)).join('|') + ')'
  )
}
function Px (t) {
  return new RegExp(t.toString() + '|').exec('').length - 1
}
function O2 (t, e) {
  const n = t && t.exec(e)
  return n && n.index === 0
}
const R2 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
function hm (t, { joinWith: e }) {
  let n = 0
  return t
    .map((r) => {
      n += 1
      const i = n
      let o = Ca(r)
      let s = ''
      for (; o.length > 0;) {
        const l = R2.exec(o)
        if (!l) {
          s += o
          break
        }
        (s += o.substring(0, l.index)),
        (o = o.substring(l.index + l[0].length)),
        l[0][0] === '\\' && l[1]
          ? (s += '\\' + String(Number(l[1]) + i))
          : ((s += l[0]), l[0] === '(' && n++)
      }
      return s
    })
    .map((r) => `(${r})`)
    .join(e)
}
const I2 = /\b\B/
const Bx = '[a-zA-Z]\\w*'
const mm = '[a-zA-Z_]\\w*'
const Fx = '\\b\\d+(\\.\\d+)?'
const Hx =
    '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'
const $x = '\\b(0b[01]+)'
const D2 =
    '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~'
const L2 = (t = {}) => {
  const e = /^#![ ]*\//
  return (
    t.binary && (t.begin = yo(e, /.*\b/, t.binary, /\b.*/)),
    Ci(
      {
        scope: 'meta',
        begin: e,
        end: /$/,
        relevance: 0,
        'on:begin': (n, r) => {
          n.index !== 0 && r.ignoreMatch()
        }
      },
      t
    )
  )
}
const Aa = { begin: '\\\\[\\s\\S]', relevance: 0 }
const P2 = {
  scope: 'string',
  begin: "'",
  end: "'",
  illegal: '\\n',
  contains: [Aa]
}
const B2 = {
  scope: 'string',
  begin: '"',
  end: '"',
  illegal: '\\n',
  contains: [Aa]
}
const F2 = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}
const Eu = function (t, e, n = {}) {
  const r = Ci({ scope: 'comment', begin: t, end: e, contains: [] }, n)
  r.contains.push({
    scope: 'doctag',
    begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  })
  const i = pm(
    'I',
    'a',
    'is',
    'so',
    'us',
    'to',
    'at',
    'if',
    'in',
    'it',
    'on',
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    /[A-Za-z]+[-][a-z]+/,
    /[A-Za-z][a-z]{2,}/
  )
  return (
    r.contains.push({
      begin: yo(/[ ]+/, '(', i, /[.]?[:]?([.][ ]|[ ])/, '){3}')
    }),
    r
  )
}
const H2 = Eu('//', '$')
const $2 = Eu('/\\*', '\\*/')
const z2 = Eu('#', '$')
const U2 = { scope: 'number', begin: Fx, relevance: 0 }
const W2 = { scope: 'number', begin: Hx, relevance: 0 }
const K2 = { scope: 'number', begin: $x, relevance: 0 }
const V2 = {
  scope: 'regexp',
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [Aa, { begin: /\[/, end: /\]/, relevance: 0, contains: [Aa] }]
}
const G2 = { scope: 'title', begin: Bx, relevance: 0 }
const q2 = { scope: 'title', begin: mm, relevance: 0 }
const Y2 = { begin: '\\.\\s*' + mm, relevance: 0 }
const J2 = function (t) {
  return Object.assign(t, {
    'on:begin': (e, n) => {
      n.data._beginMatch = e[1]
    },
    'on:end': (e, n) => {
      n.data._beginMatch !== e[1] && n.ignoreMatch()
    }
  })
}
const gu = Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: P2,
  BACKSLASH_ESCAPE: Aa,
  BINARY_NUMBER_MODE: K2,
  BINARY_NUMBER_RE: $x,
  COMMENT: Eu,
  C_BLOCK_COMMENT_MODE: $2,
  C_LINE_COMMENT_MODE: H2,
  C_NUMBER_MODE: W2,
  C_NUMBER_RE: Hx,
  END_SAME_AS_BEGIN: J2,
  HASH_COMMENT_MODE: z2,
  IDENT_RE: Bx,
  MATCH_NOTHING_RE: I2,
  METHOD_GUARD: Y2,
  NUMBER_MODE: U2,
  NUMBER_RE: Fx,
  PHRASAL_WORDS_MODE: F2,
  QUOTE_STRING_MODE: B2,
  REGEXP_MODE: V2,
  RE_STARTERS_RE: D2,
  SHEBANG: L2,
  TITLE_MODE: G2,
  UNDERSCORE_IDENT_RE: mm,
  UNDERSCORE_TITLE_MODE: q2
})
function X2 (t, e) {
  t.input[t.index - 1] === '.' && e.ignoreMatch()
}
function Z2 (t, e) {
  t.className !== void 0 && ((t.scope = t.className), delete t.className)
}
function j2 (t, e) {
  e &&
        t.beginKeywords &&
        ((t.begin =
            '\\b(' +
            t.beginKeywords.split(' ').join('|') +
            ')(?!\\.)(?=\\b|\\s)'),
        (t.__beforeBegin = X2),
        (t.keywords = t.keywords || t.beginKeywords),
        delete t.beginKeywords,
        t.relevance === void 0 && (t.relevance = 0))
}
function Q2 (t, e) {
  Array.isArray(t.illegal) && (t.illegal = pm(...t.illegal))
}
function eF (t, e) {
  if (t.match) {
    if (t.begin || t.end) {
      throw new Error('begin & end are not supported with match')
    }
    (t.begin = t.match), delete t.match
  }
}
function tF (t, e) {
  t.relevance === void 0 && (t.relevance = 1)
}
const nF = (t, e) => {
  if (!t.beforeMatch) return
  if (t.starts) throw new Error('beforeMatch cannot be used with starts')
  const n = Object.assign({}, t)
  Object.keys(t).forEach((r) => {
    delete t[r]
  }),
  (t.keywords = n.keywords),
  (t.begin = yo(n.beforeMatch, Lx(n.begin))),
  (t.starts = {
    relevance: 0,
    contains: [Object.assign(n, { endsParent: !0 })]
  }),
  (t.relevance = 0),
  delete n.beforeMatch
}
const rF = [
  'of',
  'and',
  'for',
  'in',
  'not',
  'or',
  'if',
  'then',
  'parent',
  'list',
  'value'
]
const iF = 'keyword'
function zx (t, e, n = iF) {
  const r = Object.create(null)
  return (
    typeof t === 'string'
      ? i(n, t.split(' '))
      : Array.isArray(t)
        ? i(n, t)
        : Object.keys(t).forEach(function (o) {
          Object.assign(r, zx(t[o], e, o))
        }),
    r
  )
  function i (o, s) {
    e && (s = s.map((l) => l.toLowerCase())),
    s.forEach(function (l) {
      const u = l.split('|')
      r[u[0]] = [o, oF(u[0], u[1])]
    })
  }
}
function oF (t, e) {
  return e ? Number(e) : sF(t) ? 0 : 1
}
function sF (t) {
  return rF.includes(t.toLowerCase())
}
const Ax = {}
const bo = (t) => {
  console.error(t)
}
const Mx = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e)
}
const ls = (t, e) => {
  Ax[`${t}/${e}`] ||
        (console.log(`Deprecated as of ${t}. ${e}`), (Ax[`${t}/${e}`] = !0))
}
const yu = new Error()
function Ux (t, e, { key: n }) {
  let r = 0
  const i = t[n]
  const o = {}
  const s = {}
  for (let l = 1; l <= e.length; l++) {
    (s[l + r] = i[l]), (o[l + r] = !0), (r += Px(e[l - 1]))
  }
  (t[n] = s), (t[n]._emit = o), (t[n]._multi = !0)
}
function aF (t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin) {
      throw (
        (bo(
          'skip, excludeBegin, returnBegin not compatible with beginScope: {}'
        ),
        yu)
      )
    }
    if (typeof t.beginScope !== 'object' || t.beginScope === null) {
      throw (bo('beginScope must be object'), yu)
    }
    Ux(t, t.begin, { key: 'beginScope' }),
    (t.begin = hm(t.begin, { joinWith: '' }))
  }
}
function lF (t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd) {
      throw (
        (bo(
          'skip, excludeEnd, returnEnd not compatible with endScope: {}'
        ),
        yu)
      )
    }
    if (typeof t.endScope !== 'object' || t.endScope === null) {
      throw (bo('endScope must be object'), yu)
    }
    Ux(t, t.end, { key: 'endScope' }),
    (t.end = hm(t.end, { joinWith: '' }))
  }
}
function cF (t) {
  t.scope &&
        typeof t.scope === 'object' &&
        t.scope !== null &&
        ((t.beginScope = t.scope), delete t.scope)
}
function uF (t) {
  cF(t),
  typeof t.beginScope === 'string' &&
            (t.beginScope = { _wrap: t.beginScope }),
  typeof t.endScope === 'string' && (t.endScope = { _wrap: t.endScope }),
  aF(t),
  lF(t)
}
function dF (t) {
  function e (s, l) {
    return new RegExp(
      Ca(s),
      'm' +
                (t.case_insensitive ? 'i' : '') +
                (t.unicodeRegex ? 'u' : '') +
                (l ? 'g' : '')
    )
  }
  class n {
    constructor () {
      (this.matchIndexes = {}),
      (this.regexes = []),
      (this.matchAt = 1),
      (this.position = 0)
    }

    addRule (l, u) {
      (u.position = this.position++),
      (this.matchIndexes[this.matchAt] = u),
      this.regexes.push([u, l]),
      (this.matchAt += Px(l) + 1)
    }

    compile () {
      this.regexes.length === 0 && (this.exec = () => null)
      const l = this.regexes.map((u) => u[1]);
      (this.matcherRe = e(hm(l, { joinWith: '|' }), !0)),
      (this.lastIndex = 0)
    }

    exec (l) {
      this.matcherRe.lastIndex = this.lastIndex
      const u = this.matcherRe.exec(l)
      if (!u) return null
      const d = u.findIndex((h, m) => m > 0 && h !== void 0)
      const f = this.matchIndexes[d]
      return u.splice(0, d), Object.assign(u, f)
    }
  }
  class r {
    constructor () {
      (this.rules = []),
      (this.multiRegexes = []),
      (this.count = 0),
      (this.lastIndex = 0),
      (this.regexIndex = 0)
    }

    getMatcher (l) {
      if (this.multiRegexes[l]) return this.multiRegexes[l]
      const u = new n()
      return (
        this.rules.slice(l).forEach(([d, f]) => u.addRule(d, f)),
        u.compile(),
        (this.multiRegexes[l] = u),
        u
      )
    }

    resumingScanAtSamePosition () {
      return this.regexIndex !== 0
    }

    considerAll () {
      this.regexIndex = 0
    }

    addRule (l, u) {
      this.rules.push([l, u]), u.type === 'begin' && this.count++
    }

    exec (l) {
      const u = this.getMatcher(this.regexIndex)
      u.lastIndex = this.lastIndex
      let d = u.exec(l)
      if (
        this.resumingScanAtSamePosition() &&
                !(d && d.index === this.lastIndex)
      ) {
        const f = this.getMatcher(0);
        (f.lastIndex = this.lastIndex + 1), (d = f.exec(l))
      }
      return (
        d &&
                    ((this.regexIndex += d.position + 1),
                    this.regexIndex === this.count && this.considerAll()),
        d
      )
    }
  }
  function i (s) {
    const l = new r()
    return (
      s.contains.forEach((u) =>
        l.addRule(u.begin, { rule: u, type: 'begin' })
      ),
      s.terminatorEnd && l.addRule(s.terminatorEnd, { type: 'end' }),
      s.illegal && l.addRule(s.illegal, { type: 'illegal' }),
      l
    )
  }
  function o (s, l) {
    const u = s
    if (s.isCompiled) return u;
    [Z2, eF, uF, nF].forEach((f) => f(s, l)),
    t.compilerExtensions.forEach((f) => f(s, l)),
    (s.__beforeBegin = null),
    [j2, Q2, tF].forEach((f) => f(s, l)),
    (s.isCompiled = !0)
    let d = null
    return (
      typeof s.keywords === 'object' &&
                s.keywords.$pattern &&
                ((s.keywords = Object.assign({}, s.keywords)),
                (d = s.keywords.$pattern),
                delete s.keywords.$pattern),
      (d = d || /\w+/),
      s.keywords && (s.keywords = zx(s.keywords, t.case_insensitive)),
      (u.keywordPatternRe = e(d, !0)),
      l &&
                (s.begin || (s.begin = /\B|\b/),
                (u.beginRe = e(u.begin)),
                !s.end && !s.endsWithParent && (s.end = /\B|\b/),
                s.end && (u.endRe = e(u.end)),
                (u.terminatorEnd = Ca(u.end) || ''),
                s.endsWithParent &&
                    l.terminatorEnd &&
                    (u.terminatorEnd += (s.end ? '|' : '') + l.terminatorEnd)),
      s.illegal && (u.illegalRe = e(s.illegal)),
      s.contains || (s.contains = []),
      (s.contains = [].concat(
        ...s.contains.map(function (f) {
          return fF(f === 'self' ? s : f)
        })
      )),
      s.contains.forEach(function (f) {
        o(f, u)
      }),
      s.starts && o(s.starts, l),
      (u.matcher = i(u)),
      u
    )
  }
  if (
    (t.compilerExtensions || (t.compilerExtensions = []),
    t.contains && t.contains.includes('self'))
  ) {
    throw new Error(
      'ERR: contains `self` is not supported at the top-level of a language.  See documentation.'
    )
  }
  return (t.classNameAliases = Ci(t.classNameAliases || {})), o(t)
}
function Wx (t) {
  return t ? t.endsWithParent || Wx(t.starts) : !1
}
function fF (t) {
  return (
    t.variants &&
            !t.cachedVariants &&
            (t.cachedVariants = t.variants.map(function (e) {
              return Ci(t, { variants: null }, e)
            })),
    t.cachedVariants
      ? t.cachedVariants
      : Wx(t)
        ? Ci(t, { starts: t.starts ? Ci(t.starts) : null })
        : Object.isFrozen(t)
          ? Ci(t)
          : t
  )
}
const pF = '11.10.0'
const fm = class extends Error {
  constructor (e, n) {
    super(e), (this.name = 'HTMLInjectionError'), (this.html = n)
  }
}
const lm = Dx
const Nx = Ci
const kx = Symbol('nomatch')
const hF = 7
const Kx = function (t) {
  const e = Object.create(null)
  const n = Object.create(null)
  const r = []
  let i = !0
  const o =
        "Could not find the language '{}', did you forget to load/include a language module?"
  const s = { disableAutodetect: !0, name: 'Plain text', contains: [] }
  let l = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: 'hljs-',
    cssSelector: 'pre code',
    languages: null,
    __emitter: dm
  }
  function u (A) {
    return l.noHighlightRe.test(A)
  }
  function d (A) {
    let D = A.className + ' '
    D += A.parentNode ? A.parentNode.className : ''
    const z = l.languageDetectRe.exec(D)
    if (z) {
      const j = q(z[1])
      return (
        j ||
                    (Mx(o.replace('{}', z[1])),
                    Mx('Falling back to no-highlight mode for this block.', A)),
        j ? z[1] : 'no-highlight'
      )
    }
    return D.split(/\s+/).find((j) => u(j) || q(j))
  }
  function f (A, D, z) {
    let j = ''
    let ie = ''
    typeof D === 'object'
      ? ((j = A), (z = D.ignoreIllegals), (ie = D.language))
      : (ls(
          '10.7.0',
          'highlight(lang, code, ...args) has been deprecated.'
        ),
        ls(
          '10.7.0',
                  `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`
        ),
        (ie = A),
        (j = D)),
    z === void 0 && (z = !0)
    const xe = { code: j, language: ie }
    ge('before:highlight', xe)
    const Ae = xe.result ? xe.result : h(xe.language, xe.code, z)
    return (Ae.code = xe.code), ge('after:highlight', Ae), Ae
  }
  function h (A, D, z, j) {
    const ie = Object.create(null)
    function xe (L, H) {
      return L.keywords[H]
    }
    function Ae () {
      if (!V.keywords) {
        _e.addText(pe)
        return
      }
      let L = 0
      V.keywordPatternRe.lastIndex = 0
      let H = V.keywordPatternRe.exec(pe)
      let X = ''
      for (; H;) {
        X += pe.substring(L, H.index)
        const se = Je.case_insensitive ? H[0].toLowerCase() : H[0]
        const Fe = xe(V, se)
        if (Fe) {
          const [rt, wr] = Fe
          if (
            (_e.addText(X),
            (X = ''),
            (ie[se] = (ie[se] || 0) + 1),
            ie[se] <= hF && (ut += wr),
            rt.startsWith('_'))
          ) {
            X += H[0]
          } else {
            const F = Je.classNameAliases[rt] || rt
            Be(H[0], F)
          }
        } else X += H[0];
        (L = V.keywordPatternRe.lastIndex),
        (H = V.keywordPatternRe.exec(pe))
      }
      (X += pe.substring(L)), _e.addText(X)
    }
    function je () {
      if (pe === '') return
      let L = null
      if (typeof V.subLanguage === 'string') {
        if (!e[V.subLanguage]) {
          _e.addText(pe)
          return
        }
        (L = h(V.subLanguage, pe, !0, yt[V.subLanguage])),
        (yt[V.subLanguage] = L._top)
      } else L = b(pe, V.subLanguage.length ? V.subLanguage : null)
      V.relevance > 0 && (ut += L.relevance),
      _e.__addSublanguage(L._emitter, L.language)
    }
    function Ne () {
      V.subLanguage != null ? je() : Ae(), (pe = '')
    }
    function Be (L, H) {
      L !== '' && (_e.startScope(H), _e.addText(L), _e.endScope())
    }
    function _t (L, H) {
      let X = 1
      const se = H.length - 1
      for (; X <= se;) {
        if (!L._emit[X]) {
          X++
          continue
        }
        const Fe = Je.classNameAliases[L[X]] || L[X]
        const rt = H[X]
        Fe ? Be(rt, Fe) : ((pe = rt), Ae(), (pe = '')), X++
      }
    }
    function kt (L, H) {
      return (
        L.scope &&
                    typeof L.scope === 'string' &&
                    _e.openNode(Je.classNameAliases[L.scope] || L.scope),
        L.beginScope &&
                    (L.beginScope._wrap
                      ? (Be(
                          pe,
                          Je.classNameAliases[L.beginScope._wrap] ||
                                  L.beginScope._wrap
                        ),
                        (pe = ''))
                      : L.beginScope._multi &&
                          (_t(L.beginScope, H), (pe = ''))),
        (V = Object.create(L, { parent: { value: V } })),
        V
      )
    }
    function Re (L, H, X) {
      let se = O2(L.endRe, X)
      if (se) {
        if (L['on:end']) {
          const Fe = new bu(L)
          L['on:end'](H, Fe), Fe.isMatchIgnored && (se = !1)
        }
        if (se) {
          for (; L.endsParent && L.parent;) L = L.parent
          return L
        }
      }
      if (L.endsWithParent) return Re(L.parent, H, X)
    }
    function St (L) {
      return V.matcher.regexIndex === 0
        ? ((pe += L[0]), 1)
        : ((Ot = !0), 0)
    }
    function Xt (L) {
      const H = L[0]
      const X = L.rule
      const se = new bu(X)
      const Fe = [X.__beforeBegin, X['on:begin']]
      for (const rt of Fe) {
        if (rt && (rt(L, se), se.isMatchIgnored)) return St(H)
      }
      return (
        X.skip
          ? (pe += H)
          : (X.excludeBegin && (pe += H),
            Ne(),
            !X.returnBegin && !X.excludeBegin && (pe = H)),
        kt(X, L),
        X.returnBegin ? 0 : H.length
      )
    }
    function pt (L) {
      const H = L[0]
      const X = D.substring(L.index)
      const se = Re(V, L, X)
      if (!se) return kx
      const Fe = V
      V.endScope && V.endScope._wrap
        ? (Ne(), Be(H, V.endScope._wrap))
        : V.endScope && V.endScope._multi
          ? (Ne(), _t(V.endScope, L))
          : Fe.skip
            ? (pe += H)
            : (Fe.returnEnd || Fe.excludeEnd || (pe += H),
              Ne(),
              Fe.excludeEnd && (pe = H))
      do {
        V.scope && _e.closeNode(),
        !V.skip && !V.subLanguage && (ut += V.relevance),
        (V = V.parent)
      } while (V !== se.parent)
      return se.starts && kt(se.starts, L), Fe.returnEnd ? 0 : H.length
    }
    function an () {
      const L = []
      for (let H = V; H !== Je; H = H.parent) {
        H.scope && L.unshift(H.scope)
      }
      L.forEach((H) => _e.openNode(H))
    }
    let Zt = {}
    function Tt (L, H) {
      const X = H && H[0]
      if (((pe += L), X == null)) return Ne(), 0
      if (
        Zt.type === 'begin' &&
                H.type === 'end' &&
                Zt.index === H.index &&
                X === ''
      ) {
        if (((pe += D.slice(H.index, H.index + 1)), !i)) {
          const se = new Error(`0 width match regex (${A})`)
          throw ((se.languageName = A), (se.badRule = Zt.rule), se)
        }
        return 1
      }
      if (((Zt = H), H.type === 'begin')) return Xt(H)
      if (H.type === 'illegal' && !z) {
        const se = new Error(
          'Illegal lexeme "' +
                        X +
                        '" for mode "' +
                        (V.scope || '<unnamed>') +
                        '"'
        )
        throw ((se.mode = V), se)
      } else if (H.type === 'end') {
        const se = pt(H)
        if (se !== kx) return se
      }
      if (H.type === 'illegal' && X === '') return 1
      if (Bt > 1e5 && Bt > H.index * 3) {
        throw new Error(
          'potential infinite loop, way more iterations than matches'
        )
      }
      return (pe += X), X.length
    }
    const Je = q(A)
    if (!Je) {
      throw (
        (bo(o.replace('{}', A)),
        new Error('Unknown language: "' + A + '"'))
      )
    }
    const jn = dF(Je)
    let Pt = ''
    let V = j || jn
    const yt = {}
    const _e = new l.__emitter(l)
    an()
    let pe = ''
    let ut = 0
    let dt = 0
    let Bt = 0
    let Ot = !1
    try {
      if (Je.__emitTokens) Je.__emitTokens(D, _e)
      else {
        for (V.matcher.considerAll(); ;) {
          Bt++,
          Ot ? (Ot = !1) : V.matcher.considerAll(),
          (V.matcher.lastIndex = dt)
          const L = V.matcher.exec(D)
          if (!L) break
          const H = D.substring(dt, L.index)
          const X = Tt(H, L)
          dt = L.index + X
        }
        Tt(D.substring(dt))
      }
      return (
        _e.finalize(),
        (Pt = _e.toHTML()),
        {
          language: A,
          value: Pt,
          relevance: ut,
          illegal: !1,
          _emitter: _e,
          _top: V
        }
      )
    } catch (L) {
      if (L.message && L.message.includes('Illegal')) {
        return {
          language: A,
          value: lm(D),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: L.message,
            index: dt,
            context: D.slice(dt - 100, dt + 100),
            mode: L.mode,
            resultSoFar: Pt
          },
          _emitter: _e
        }
      }
      if (i) {
        return {
          language: A,
          value: lm(D),
          illegal: !1,
          relevance: 0,
          errorRaised: L,
          _emitter: _e,
          _top: V
        }
      }
      throw L
    }
  }
  function m (A) {
    const D = {
      value: lm(A),
      illegal: !1,
      relevance: 0,
      _top: s,
      _emitter: new l.__emitter(l)
    }
    return D._emitter.addText(A), D
  }
  function b (A, D) {
    D = D || l.languages || Object.keys(e)
    const z = m(A)
    const j = D.filter(q)
      .filter(fe)
      .map((Ne) => h(Ne, A, !1))
    j.unshift(z)
    const ie = j.sort((Ne, Be) => {
      if (Ne.relevance !== Be.relevance) {
        return Be.relevance - Ne.relevance
      }
      if (Ne.language && Be.language) {
        if (q(Ne.language).supersetOf === Be.language) return 1
        if (q(Be.language).supersetOf === Ne.language) {
          return -1
        }
      }
      return 0
    })
    const [xe, Ae] = ie
    const je = xe
    return (je.secondBest = Ae), je
  }
  function g (A, D, z) {
    const j = (D && n[D]) || z
    A.classList.add('hljs'), A.classList.add(`language-${j}`)
  }
  function E (A) {
    let D = null
    const z = d(A)
    if (u(z)) return
    if (
      (ge('before:highlightElement', { el: A, language: z }),
      A.dataset.highlighted)
    ) {
      console.log(
        'Element previously highlighted. To highlight again, first unset `dataset.highlighted`.',
        A
      )
      return
    }
    if (
      A.children.length > 0 &&
            (l.ignoreUnescapedHTML ||
                (console.warn(
                  'One of your code blocks includes unescaped HTML. This is a potentially serious security risk.'
                ),
                console.warn(
                  'https://github.com/highlightjs/highlight.js/wiki/security'
                ),
                console.warn('The element with unescaped HTML:'),
                console.warn(A)),
            l.throwUnescapedHTML)
    ) {
      throw new fm(
        'One of your code blocks includes unescaped HTML.',
        A.innerHTML
      )
    }
    D = A
    const j = D.textContent
    const ie = z ? f(j, { language: z, ignoreIllegals: !0 }) : b(j);
    (A.innerHTML = ie.value),
    (A.dataset.highlighted = 'yes'),
    g(A, z, ie.language),
    (A.result = {
      language: ie.language,
      re: ie.relevance,
      relevance: ie.relevance
    }),
    ie.secondBest &&
                (A.secondBest = {
                  language: ie.secondBest.language,
                  relevance: ie.secondBest.relevance
                }),
    ge('after:highlightElement', { el: A, result: ie, text: j })
  }
  function w (A) {
    l = Nx(l, A)
  }
  const S = () => {
    T(),
    ls(
      '10.6.0',
      'initHighlighting() deprecated.  Use highlightAll() now.'
    )
  }
  function O () {
    T(),
    ls(
      '10.6.0',
      'initHighlightingOnLoad() deprecated.  Use highlightAll() now.'
    )
  }
  let k = !1
  function T () {
    if (document.readyState === 'loading') {
      k = !0
      return
    }
    document.querySelectorAll(l.cssSelector).forEach(E)
  }
  function P () {
    k && T()
  }
  typeof window < 'u' &&
        window.addEventListener &&
        window.addEventListener('DOMContentLoaded', P, !1)
  function I (A, D) {
    let z = null
    try {
      z = D(t)
    } catch (j) {
      if (
        (bo(
          "Language definition for '{}' could not be registered.".replace(
            '{}',
            A
          )
        ),
        i)
      ) {
        bo(j)
      } else throw j
      z = s
    }
    z.name || (z.name = A),
    (e[A] = z),
    (z.rawDefinition = D.bind(null, t)),
    z.aliases && Q(z.aliases, { languageName: A })
  }
  function Y (A) {
    delete e[A]
    for (const D of Object.keys(n)) n[D] === A && delete n[D]
  }
  function ne () {
    return Object.keys(e)
  }
  function q (A) {
    return (A = (A || '').toLowerCase()), e[A] || e[n[A]]
  }
  function Q (A, { languageName: D }) {
    typeof A === 'string' && (A = [A]),
    A.forEach((z) => {
      n[z.toLowerCase()] = D
    })
  }
  function fe (A) {
    const D = q(A)
    return D && !D.disableAutodetect
  }
  function we (A) {
    A['before:highlightBlock'] &&
            !A['before:highlightElement'] &&
            (A['before:highlightElement'] = (D) => {
              A['before:highlightBlock'](Object.assign({ block: D.el }, D))
            }),
    A['after:highlightBlock'] &&
                !A['after:highlightElement'] &&
                (A['after:highlightElement'] = (D) => {
                  A['after:highlightBlock'](
                    Object.assign({ block: D.el }, D)
                  )
                })
  }
  function me (A) {
    we(A), r.push(A)
  }
  function Ce (A) {
    const D = r.indexOf(A)
    D !== -1 && r.splice(D, 1)
  }
  function ge (A, D) {
    const z = A
    r.forEach(function (j) {
      j[z] && j[z](D)
    })
  }
  function ye (A) {
    return (
      ls('10.7.0', 'highlightBlock will be removed entirely in v12.0'),
      ls('10.7.0', 'Please use highlightElement now.'),
      E(A)
    )
  }
  Object.assign(t, {
    highlight: f,
    highlightAuto: b,
    highlightAll: T,
    highlightElement: E,
    highlightBlock: ye,
    configure: w,
    initHighlighting: S,
    initHighlightingOnLoad: O,
    registerLanguage: I,
    unregisterLanguage: Y,
    listLanguages: ne,
    getLanguage: q,
    registerAliases: Q,
    autoDetection: fe,
    inherit: Nx,
    addPlugin: me,
    removePlugin: Ce
  }),
  (t.debugMode = function () {
    i = !1
  }),
  (t.safeMode = function () {
    i = !0
  }),
  (t.versionString = pF),
  (t.regex = {
    concat: yo,
    lookahead: Lx,
    either: pm,
    optional: N2,
    anyNumberOfTimes: M2
  })
  for (const A in gu) typeof gu[A] === 'object' && Ix(gu[A])
  return Object.assign(t, gu), t
}
const cs = Kx({})
cs.newInstance = () => Kx({})
const mF = cs
cs.HighlightJS = cs
cs.default = cs
const gF = T2(mF)
function Vx (t, e = []) {
  return t
    .map((n) => {
      const r = [...e, ...(n.properties ? n.properties.className : [])]
      return n.children
        ? Vx(n.children, r)
        : { text: n.value, classes: r }
    })
    .flat()
}
function Ox (t) {
  return t.value || t.children || []
}
function bF (t) {
  return !!gF.getLanguage(t)
}
function Rx ({ doc: t, name: e, lowlight: n, defaultLanguage: r }) {
  const i = []
  return (
    eo(t, (o) => o.type.name === e).forEach((o) => {
      let s
      let l = o.pos + 1
      const u = o.node.attrs.language || r
      const d = n.listLanguages()
      const f =
                u &&
                (d.includes(u) ||
                    bF(u) ||
                    (!((s = n.registered) === null || s === void 0) &&
                        s.call(n, u)))
                  ? Ox(n.highlight(u, o.node.textContent))
                  : Ox(n.highlightAuto(o.node.textContent))
      Vx(f).forEach((h) => {
        const m = l + h.text.length
        if (h.classes.length) {
          const b = wt.inline(l, m, { class: h.classes.join(' ') })
          i.push(b)
        }
        l = m
      })
    }),
    ot.create(t, i)
  )
}
function yF (t) {
  return typeof t === 'function'
}
function EF ({ name: t, lowlight: e, defaultLanguage: n }) {
  if (
    !['highlight', 'highlightAuto', 'listLanguages'].every((i) => yF(e[i]))
  ) {
    throw Error(
      'You should provide an instance of lowlight to use the code-block-lowlight extension'
    )
  }
  const r = new Oe({
    key: new ze('lowlight'),
    state: {
      init: (i, { doc: o }) =>
        Rx({ doc: o, name: t, lowlight: e, defaultLanguage: n }),
      apply: (i, o, s, l) => {
        const u = s.selection.$head.parent.type.name
        const d = l.selection.$head.parent.type.name
        const f = eo(s.doc, (m) => m.type.name === t)
        const h = eo(l.doc, (m) => m.type.name === t)
        return i.docChanged &&
                    ([u, d].includes(t) ||
                        h.length !== f.length ||
                        i.steps.some(
                          (m) =>
                            m.from !== void 0 &&
                                m.to !== void 0 &&
                                f.some(
                                  (b) =>
                                    b.pos >= m.from &&
                                        b.pos + b.node.nodeSize <= m.to
                                )
                        ))
          ? Rx({
            doc: i.doc,
            name: t,
            lowlight: e,
            defaultLanguage: n
          })
          : o.map(i.mapping, i.doc)
      }
    },
    props: {
      decorations (i) {
        return r.getState(i)
      }
    }
  })
  return r
}
const Gx = Sx.extend({
  addOptions () {
    let t
    return {
      ...((t = this.parent) === null || t === void 0
        ? void 0
        : t.call(this)),
      lowlight: {},
      languageClassPrefix: 'language-',
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    }
  },
  addProseMirrorPlugins () {
    let t
    return [
      ...(((t = this.parent) === null || t === void 0
        ? void 0
        : t.call(this)) || []),
      EF({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ]
  }
})
const gm = Gx.extend({
  addKeyboardShortcuts () {
    return {
      ...this.parent?.(),
      ArrowDown: () => {
        const t = this.editor.state
        const { from: e, to: n } = t.selection
        if (e > 1 && e === n) {
          let r = !1
          t.doc.nodesBetween(e - 1, n - 1, (o) => {
            o.type.name === 'codeBlock' && (r = !0)
          })
          let i = !0
          if (
            (t.doc.nodesBetween(e + 1, n + 1, (o) => {
              o && (i = !1)
            }),
            r && i)
          ) {
            return this.editor.commands.setHardBreak()
          }
        }
        return !1
      }
    }
  }
})
const bm = ce.create({
  name: 'hurdle',
  group: 'block',
  content: 'block+',
  addOptions () {
    return {
      colors: [
        'gray_light',
        'gray',
        'gray_dark',
        'primary',
        'secondary',
        'tertiary',
        'accent'
      ],
      HTMLAttributes: { class: 'filament-tiptap-hurdle' }
    }
  },
  addAttributes () {
    return {
      color: {
        default: 'gray',
        parseHTML: (t) => t.getAttribute('data-color'),
        renderHTML: (t) => ({ 'data-color': t.color })
      }
    }
  },
  parseHTML () {
    return [
      {
        tag: 'div',
        getAttrs: (t) => t.classList.contains('filament-tiptap-hurdle')
      }
    ]
  },
  renderHTML ({ node: t, HTMLAttributes: e }) {
    return ['div', ee(this.options.HTMLAttributes, e), 0]
  },
  addCommands () {
    return {
      setHurdle:
                (t) =>
                  ({ commands: e }) =>
                    this.options.colors.includes(t.color)
                      ? e.toggleWrap(this.name, t)
                      : !1
    }
  }
})
const ym = We.create({
  name: 'textAlign',
  addOptions () {
    return {
      types: [],
      alignments: ['start', 'center', 'end', 'justify'],
      defaultAlignment: 'start'
    }
  },
  addGlobalAttributes () {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) =>
              t.style.textAlign || this.options.defaultAlignment,
            renderHTML: (t) =>
              t.style && t.style.includes('text-align')
                ? {}
                : t.textAlign === this.options.defaultAlignment
                  ? {}
                  : { style: `text-align: ${t.textAlign}` }
          }
        }
      }
    ]
  },
  addCommands () {
    return {
      setTextAlign:
                (t) =>
                  ({ commands: e }) =>
                    this.options.alignments.includes(t)
                      ? this.options.types.every((n) =>
                        e.updateAttributes(n, { textAlign: t })
                      )
                      : !1,
      unsetTextAlign:
                () =>
                  ({ commands: t }) =>
                    this.options.types.every((e) =>
                      t.resetAttributes(e, 'textAlign')
                    )
    }
  },
  addKeyboardShortcuts () {
    return {
      'Mod-Shift-l': () => this.editor.commands.setTextAlign('start'),
      'Mod-Shift-e': () => this.editor.commands.setTextAlign('center'),
      'Mod-Shift-r': () => this.editor.commands.setTextAlign('end'),
      'Mod-Shift-j': () => this.editor.commands.setTextAlign('justify')
    }
  }
})
function vu (t, e, n = null) {
  return n
    ? t.createChecked({ 'data-col-span': e }, n)
    : t.createAndFill({ 'data-col-span': e })
}
function qx (t) {
  if (t.cached.gridBuilderNodeTypes) return t.cached.gridBuilderNodeTypes
  const e = {}
  return (
    Object.keys(t.nodes).forEach((n) => {
      const r = t.nodes[n]
      r.spec.gridBuilderRole && (e[r.spec.gridBuilderRole] = r)
    }),
    (t.cached.gridBuilderNodeTypes = e),
    e
  )
}
function Yx (t, e, n, r, i, o, s) {
  const l = qx(t)
  const u = []
  if (n === 'asymmetric') {
    u.push(vu(l.builderColumn, i, s)), u.push(vu(l.builderColumn, o, s))
  } else {
    for (let d = 0; d < e; d += 1) {
      const f = vu(l.builderColumn, null, s)
      f && u.push(f)
    }
  }
  return l.gridBuilder.createChecked(
    { 'data-cols': e, 'data-type': n, 'data-stack-at': r },
    u
  )
}
const Em = ce.create({
  name: 'gridBuilder',
  group: 'block',
  defining: !0,
  isolating: !0,
  allowGapCursor: !1,
  content: 'gridBuilderColumn+',
  gridBuilderRole: 'gridBuilder',
  addOptions () {
    return { HTMLAttributes: { class: 'filament-tiptap-grid-builder' } }
  },
  addAttributes () {
    return {
      'data-type': {
        default: 'responsive',
        parseHTML: (t) => t.getAttribute('data-type')
      },
      'data-cols': {
        default: 2,
        parseHTML: (t) => t.getAttribute('data-cols')
      },
      'data-stack-at': {
        default: 'md',
        parseHTML: (t) => t.getAttribute('data-stack-at')
      },
      style: {
        default: null,
        parseHTML: (t) => t.getAttribute('style'),
        renderHTML: (t) => ({
          style: `grid-template-columns: repeat(${t['data-cols']}, 1fr);`
        })
      }
    }
  },
  parseHTML () {
    return [
      {
        tag: 'div',
        getAttrs: (t) =>
          t.classList.contains('filament-tiptap-grid-builder') &&
                    null
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['div', ee(this.options.HTMLAttributes, t), 0]
  },
  addCommands () {
    return {
      insertGridBuilder:
                ({
                  cols: t = 3,
                  type: e = 'responsive',
                  stackAt: n,
                  asymmetricLeft: r = null,
                  asymmetricRight: i = null
                } = {}) =>
                  ({ tr: o, dispatch: s, editor: l }) => {
                    const u = Yx(l.schema, t, e, n, r, i)
                    if (s) {
                      const d = o.selection.anchor + 1
                      o.replaceSelectionWith(u)
                        .scrollIntoView()
                        .setSelection(le.near(o.doc.resolve(d)))
                    }
                    return !0
                  }
    }
  },
  addKeyboardShortcuts () {
    return { 'Mod-Alt-G': () => this.editor.commands.insertGridBuilder() }
  },
  extendNodeSchema (t) {
    const e = { name: t.name, options: t.options, storage: t.storage }
    return { gridBuilderRole: Te(re(t, 'gridBuilderRole', e)) }
  }
})
const vm = ce.create({
  name: 'gridBuilderColumn',
  content: 'block+',
  gridBuilderRole: 'builderColumn',
  isolating: !0,
  addOptions () {
    return {
      HTMLAttributes: { class: 'filament-tiptap-grid-builder__column' }
    }
  },
  addAttributes () {
    return {
      'data-col-span': {
        default: 1,
        parseHTML: (t) => t.getAttribute('data-col-span')
      },
      style: {
        default: null,
        parseHTML: (t) => t.getAttribute('style'),
        renderHTML: (t) => ({
          style: `grid-column: span ${t['data-col-span']};`
        })
      }
    }
  },
  parseHTML () {
    return [
      {
        tag: 'div',
        getAttrs: (t) =>
          t.classList.contains(
            'filament-tiptap-grid-builder__column'
          ) && null
      }
    ]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['div', ee(this.options.HTMLAttributes, t), 0]
  }
})
const wm = We.create({
  name: 'dragAndDrop',
  addProseMirrorPlugins (t) {
    return [
      new Oe({
        props: {
          handleDrop (e, n) {
            if (!n) return !1
            n.preventDefault()
            const r = e.posAtCoords({
              left: n.clientX,
              top: n.clientY
            })
            return n.dataTransfer.getData('block')
              ? (n.target.dispatchEvent(
                  new CustomEvent('dragged-block', {
                    detail: {
                      type: n.dataTransfer.getData('block'),
                      coordinates: r
                    },
                    bubbles: !0
                  })
                ),
                !1)
              : (n.dataTransfer.getData('mergeTag') &&
                                  n.target.dispatchEvent(
                                    new CustomEvent('dragged-merge-tag', {
                                      detail: {
                                        tag: n.dataTransfer.getData(
                                          'mergeTag'
                                        ),
                                        coordinates: r
                                      },
                                      bubbles: !0
                                    })
                                  ),
                !1)
          }
        }
      })
    ]
  }
})
const xm = ce.create({
  name: 'tiptapBlock',
  group: 'block',
  atom: !0,
  defining: !0,
  draggable: !0,
  selectable: !0,
  isolating: !0,
  allowGapCursor: !0,
  inline: !1,
  addAttributes () {
    return {
      preview: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-preview'),
        renderHTML: (t) =>
          t.preview ? { 'data-preview': t.preview } : null
      },
      statePath: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-state-path'),
        renderHTML: (t) =>
          t.statePath ? { 'data-state-path': t.statePath } : null
      },
      type: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-type'),
        renderHTML: (t) => (t.type ? { 'data-type': t.type } : null)
      },
      label: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-label'),
        renderHTML: (t) => (t.label ? { 'data-label': t.label } : null)
      },
      data: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-data'),
        renderHTML: (t) =>
          t.data ? { 'data-data': JSON.stringify(t.data) } : null
      }
    }
  },
  parseHTML () {
    return [{ tag: 'tiptap-block' }]
  },
  renderHTML ({ HTMLAttributes: t }) {
    return ['tiptap-block', ee(t)]
  },
  addNodeView () {
    return ({ editor: t, node: e, getPos: n }) => {
      const r = document.createElement('div');
      (r.contentEditable = 'false'),
      r.classList.add('tiptap-block-wrapper')
      const i =
                typeof e.attrs.data === 'object'
                  ? JSON.stringify(e.attrs.data)
                  : e.attrs.data
      return (
        (r.innerHTML = `
                <div
                    x-data="{
                        showOptionsButton: ${i === '[]' ? 'false' : 'true'},
                        openSettings() {
                            this.$dispatch('open-block-settings', {
                                type: \`${e.attrs.type}\`,
                                statePath: \`${t.commands.getStatePath()}\`,
                                data: ${i},
                                coordinates: ${n()}
                            })
                        },
                        deleteBlock() {
                            this.$dispatch('delete-block', {
                                statePath: \`${t.commands.getStatePath()}\`
                            })
                        }
                    }"
                    class="tiptap-block"
                    style="min-height: 3rem;"
                >
                    <div class="tiptap-block-heading">
                        <h3 class="tiptap-block-title">${e.attrs.label}</h3>
                        <div x-show="! disabled" class="tiptap-block-actions">
                            <button x-show="showOptionsButton" type="button" x-on:click="openSettings">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M7.84 1.804A1 1 0 018.82 1h2.36a1 1 0 01.98.804l.331 1.652a6.993 6.993 0 011.929 1.115l1.598-.54a1 1 0 011.186.447l1.18 2.044a1 1 0 01-.205 1.251l-1.267 1.113a7.047 7.047 0 010 2.228l1.267 1.113a1 1 0 01.206 1.25l-1.18 2.045a1 1 0 01-1.187.447l-1.598-.54a6.993 6.993 0 01-1.929 1.115l-.33 1.652a1 1 0 01-.98.804H8.82a1 1 0 01-.98-.804l-.331-1.652a6.993 6.993 0 01-1.929-1.115l-1.598.54a1 1 0 01-1.186-.447l-1.18-2.044a1 1 0 01.205-1.251l1.267-1.114a7.05 7.05 0 010-2.227L1.821 7.773a1 1 0 01-.206-1.25l1.18-2.045a1 1 0 011.187-.447l1.598.54A6.993 6.993 0 017.51 3.456l.33-1.652zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button type="button" x-on:click="deleteBlock()">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="preview">
                        ${e.attrs.preview}
                    </div>
                </div>
            `),
        { dom: r }
      )
    }
  },
  addCommands () {
    return {
      insertBlock:
                (t) =>
                  ({ chain: e, state: n }) => {
                    const r = e()
                    if (![null, void 0].includes(t.coordinates?.pos)) {
                      return (
                        r.insertContentAt(
                          {
                            from: t.coordinates.pos,
                            to: t.coordinates.pos
                          },
                          { type: this.name, attrs: t }
                        ),
                        r.setTextSelection(t.coordinates.pos)
                      )
                    }
                    const { selection: i } = n
                    const { $from: o, $to: s } = i
                    const l = o.blockRange(s)
                    return l
                      ? (s.parentOffset === 0
                          ? r.insertContentAt(Math.max(s.pos - 1, 0), {
                            type: this.name,
                            attrs: t
                          })
                          : r.insertContentAt(
                            { from: l.start, to: l.end },
                            { type: this.name, attrs: t }
                          ),
                        r.setTextSelection(l.end))
                      : (s.parentOffset === 0
                          ? r
                            .insertContentAt(Math.max(s.pos - 1, 0), {
                              type: 'paragraph'
                            })
                            .insertContentAt(
                              { from: o.pos, to: s.pos },
                              { type: this.name, attrs: t }
                            )
                          : r
                            .setNode({ type: 'paragraph' })
                            .insertContentAt(
                              { from: o.pos, to: s.pos },
                              { type: this.name, attrs: t }
                            ),
                        r.setTextSelection(s.pos + 1))
                  },
      updateBlock:
                (t) =>
                  ({ commands: e, chain: n, state: r }) => {
                    const { selection: i } = r
                    const { $from: o, $to: s } = i
                    const l = o.blockRange(s)
                    const u = n()
                    return l
                      ? (u.insertContentAt(
                          { from: l.start, to: l.end },
                          { type: this.name, attrs: t }
                        ),
                        u.focus(l.end + 1))
                      : t.coordinates
                        ? (u.insertContentAt(
                            { from: t.coordinates, to: t.coordinates + 1 },
                            { type: this.name, attrs: t }
                          ),
                          !1)
                        : (u.insertContentAt(
                            { from: o.pos, to: o.pos + 1 },
                            { type: this.name, attrs: t }
                          ),
                          !1)
                  },
      removeBlock:
                () =>
                  ({ commands: t }) =>
                    t.deleteSelection()
    }
  }
})
function vF (t) {
  let e
  const {
    char: n,
    allowSpaces: r,
    allowToIncludeChar: i,
    allowedPrefixes: o,
    startOfLine: s,
    $position: l
  } = t
  const u = r && !i
  const d = ov(n)
  const f = new RegExp(`\\s${d}$`)
  const h = s ? '^' : ''
  const m = i ? '' : d
  const b = u
    ? new RegExp(`${h}${d}.*?(?=\\s${m}|$)`, 'gm')
    : new RegExp(`${h}(?:^)?${d}[^\\s${m}]*`, 'gm')
  const g =
        ((e = l.nodeBefore) === null || e === void 0 ? void 0 : e.isText) &&
        l.nodeBefore.text
  if (!g) return null
  const E = l.pos - g.length
  const w = Array.from(g.matchAll(b)).pop()
  if (!w || w.input === void 0 || w.index === void 0) return null
  const S = w.input.slice(Math.max(0, w.index - 1), w.index)
  const O = new RegExp(`^[${o?.join('')}\0]?$`).test(S)
  if (o !== null && !O) return null
  const k = E + w.index
  let T = k + w[0].length
  return (
    u && f.test(g.slice(T - 1, T + 1)) && ((w[0] += ' '), (T += 1)),
    k < l.pos && T >= l.pos
      ? {
          range: { from: k, to: T },
          query: w[0].slice(n.length),
          text: w[0]
        }
      : null
  )
}
const wF = new ze('suggestion')
function Jx ({
  pluginKey: t = wF,
  editor: e,
  char: n = '@',
  allowSpaces: r = !1,
  allowToIncludeChar: i = !1,
  allowedPrefixes: o = [' '],
  startOfLine: s = !1,
  decorationTag: l = 'span',
  decorationClass: u = 'suggestion',
  command: d = () => null,
  items: f = () => [],
  render: h = () => ({}),
  allow: m = () => !0,
  findSuggestionMatch: b = vF
}) {
  let g
  const E = h?.()
  const w = new Oe({
    key: t,
    view () {
      return {
        update: async (S, O) => {
          let k, T, P, I, Y, ne, q
          const Q =
                        (k = this.key) === null || k === void 0
                          ? void 0
                          : k.getState(O)
          const fe =
                        (T = this.key) === null || T === void 0
                          ? void 0
                          : T.getState(S.state)
          const we =
                        Q.active && fe.active && Q.range.from !== fe.range.from
          const me = !Q.active && fe.active
          const Ce = Q.active && !fe.active
          const ge = !me && !Ce && Q.query !== fe.query
          const ye = me || (we && ge)
          const A = ge || we
          const D = Ce || (we && ge)
          if (!ye && !A && !D) return
          const z = D && !ye ? Q : fe
          const j = S.dom.querySelector(
                        `[data-decoration-id="${z.decorationId}"]`
          );
          (g = {
            editor: e,
            range: z.range,
            query: z.query,
            text: z.text,
            items: [],
            command: (ie) =>
              d({ editor: e, range: z.range, props: ie }),
            decorationNode: j,
            clientRect: j
              ? () => {
                  let ie
                  const { decorationId: xe } =
                                      (ie = this.key) === null || ie === void 0
                                        ? void 0
                                        : ie.getState(e.state)
                  const Ae = S.dom.querySelector(
                                      `[data-decoration-id="${xe}"]`
                  )
                  return Ae?.getBoundingClientRect() || null
                }
              : null
          }),
          ye &&
                            ((P = E?.onBeforeStart) === null ||
                                P === void 0 ||
                                P.call(E, g)),
          A &&
                            ((I = E?.onBeforeUpdate) === null ||
                                I === void 0 ||
                                I.call(E, g)),
          (A || ye) &&
                            (g.items = await f({
                              editor: e,
                              query: z.query
                            })),
          D &&
                            ((Y = E?.onExit) === null ||
                                Y === void 0 ||
                                Y.call(E, g)),
          A &&
                            ((ne = E?.onUpdate) === null ||
                                ne === void 0 ||
                                ne.call(E, g)),
          ye &&
                            ((q = E?.onStart) === null ||
                                q === void 0 ||
                                q.call(E, g))
        },
        destroy: () => {
          let S
          g &&
                        ((S = E?.onExit) === null ||
                            S === void 0 ||
                            S.call(E, g))
        }
      }
    },
    state: {
      init () {
        return {
          active: !1,
          range: { from: 0, to: 0 },
          query: null,
          text: null,
          composing: !1
        }
      },
      apply (S, O, k, T) {
        const { isEditable: P } = e
        const { composing: I } = e.view
        const { selection: Y } = S
        const { empty: ne, from: q } = Y
        const Q = { ...O }
        if (((Q.composing = I), P && (ne || e.view.composing))) {
          (q < O.range.from || q > O.range.to) &&
                        !I &&
                        !O.composing &&
                        (Q.active = !1)
          const fe = b({
            char: n,
            allowSpaces: r,
            allowToIncludeChar: i,
            allowedPrefixes: o,
            startOfLine: s,
            $position: Y.$from
          })
          const we = `id_${Math.floor(Math.random() * 4294967295)}`
          fe &&
                    m({
                      editor: e,
                      state: T,
                      range: fe.range,
                      isActive: O.active
                    })
            ? ((Q.active = !0),
              (Q.decorationId = O.decorationId
                ? O.decorationId
                : we),
              (Q.range = fe.range),
              (Q.query = fe.query),
              (Q.text = fe.text))
            : (Q.active = !1)
        } else Q.active = !1
        return (
          Q.active ||
                        ((Q.decorationId = null),
                        (Q.range = { from: 0, to: 0 }),
                        (Q.query = null),
                        (Q.text = null)),
          Q
        )
      }
    },
    props: {
      handleKeyDown (S, O) {
        let k
        const { active: T, range: P } = w.getState(S.state)
        return (
          (T &&
                        ((k = E?.onKeyDown) === null || k === void 0
                          ? void 0
                          : k.call(E, {
                            view: S,
                            event: O,
                            range: P
                          }))) ||
                    !1
        )
      },
      decorations (S) {
        const { active: O, range: k, decorationId: T } = w.getState(S)
        return O
          ? ot.create(S.doc, [
            wt.inline(k.from, k.to, {
              nodeName: l,
              class: u,
              'data-decoration-id': T
            })
          ])
          : null
      }
    }
  })
  return w
}
const xF = new ze('mergeTag')
const _m = ce.create({
  name: 'mergeTag',
  group: 'inline',
  inline: !0,
  selectable: !1,
  atom: !0,
  addAttributes () {
    return {
      id: {
        default: null,
        parseHTML: (t) => t.getAttribute('data-id'),
        renderHTML: (t) => (t.id ? { 'data-id': t.id } : {})
      }
    }
  },
  parseHTML () {
    return [{ tag: `span[data-type='${this.name}']` }]
  },
  renderHTML ({ node: t, HTMLAttributes: e }) {
    return [
      'span',
      ee({ 'data-type': this.name }, e),
            `{{ ${t.attrs.id} }}`
    ]
  },
  renderText ({ node: t }) {
    return `{{ ${t.attrs.id} }}`
  },
  addKeyboardShortcuts () {
    return {
      Backspace: () =>
        this.editor.commands.command(({ tr: t, state: e }) => {
          let n = !1
          const { selection: r } = e
          const { empty: i, anchor: o } = r
          return i
            ? (e.doc.nodesBetween(o - 1, o, (s, l) => {
                if (s.type.name === this.name) {
                  return (
                    (n = !0),
                    t.insertText('{{', l, l + s.nodeSize),
                    !1
                  )
                }
              }),
              n)
            : !1
        })
    }
  },
  addCommands () {
    return {
      insertMergeTag:
                (t) =>
                  ({ chain: e, state: n }) => {
                    const r = e()
                    if (![null, void 0].includes(t.coordinates?.pos)) {
                      return (
                        r.insertContentAt(
                          {
                            from: t.coordinates.pos,
                            to: t.coordinates.pos
                          },
                          [
                            {
                              type: this.name,
                              attrs: { id: t.tag }
                            },
                            { type: 'text', text: ' ' }
                          ]
                        ),
                        r
                      )
                    }
                  }
    }
  },
  addProseMirrorPlugins () {
    return [
      Jx({
        editor: this.editor,
        char: '{{',
        items: ({ query: t }) =>
          this.options.mergeTags
            .filter((e) =>
              e.toLowerCase().startsWith(t.toLowerCase())
            )
            .slice(0, 5),
        pluginKey: xF,
        command: ({ editor: t, range: e, props: n }) => {
          t.view.state.selection.$to.nodeAfter?.text?.startsWith(
            ' '
          ) && (e.to += 1),
          t
            .chain()
            .focus()
            .insertContentAt(e, [
              { type: this.name, attrs: n },
              { type: 'text', text: ' ' }
            ])
            .run(),
          window.getSelection()?.collapseToEnd()
        },
        allow: ({ state: t, range: e }) => {
          const n = t.doc.resolve(e.from)
          const r = t.schema.nodes[this.name]
          return !!n.parent.type.contentMatch.matchType(r)
        },
        render: () => {
          let t, e
          return {
            onStart: (n) => {
              if (!n.clientRect) return
              const r = `
                                <div
                                    x-data="{

                                        items: ['${n.items.join("', '")}'],

                                        selectedIndex: 0,

                                        init: function () {
                                            this.$el.parentElement.addEventListener(
                                                'merge-tags-key-down',
                                                (event) => this.onKeyDown(event.detail),
                                            );

                                            this.$el.parentElement.addEventListener(
                                                'merge-tags-update-items',
                                                (event) => (items = event.detail),
                                            );
                                        },

                                        onKeyDown: function (event) {
                                            if (event.key === 'ArrowUp') {
                                                event.preventDefault();
                                                this.selectedIndex = ((this.selectedIndex + this.items.length) - 1) % this.items.length;

                                                return true;
                                            };

                                            if (event.key === 'ArrowDown') {
                                                event.preventDefault();
                                                this.selectedIndex = (this.selectedIndex + 1) % this.items.length;

                                                return true;
                                            };

                                            if (event.key === 'Enter') {
                                                event.preventDefault();
                                                this.selectItem(this.selectedIndex);

                                                return true;
                                            };

                                            return false;
                                        },

                                        selectItem: function (index) {
                                            const item = this.items[index];

                                            if (! item) {
                                                return;
                                            };

                                            $el.parentElement.dispatchEvent(new CustomEvent('merge-tags-select', { detail: { item } }));
                                        },

                                    }"
                                    class="tippy-content-p-0"
                                >
                                    <template x-for="(item, index) in items" :key="index">
                                        <button
                                            x-text="item"
                                            x-on:click="selectItem(index)"
                                            :class="{ 'bg-primary-500': index === selectedIndex }"
                                            class="block w-full text-left rounded px-2 py-1"
                                        ></button>
                                    </template>
                                </div>
                            `;
              (t = document.createElement('div')),
              (t.innerHTML = r),
              t.addEventListener('merge-tags-select', (i) => {
                n.command({ id: i.detail.item })
              }),
              (e = is('body', {
                getReferenceClientRect: n.clientRect,
                appendTo: () => document.body,
                content: t,
                allowHTML: !0,
                showOnCreate: !0,
                interactive: !0,
                trigger: 'manual',
                placement: 'bottom-start'
              }))
            },
            onUpdate (n) {
              if (!n.items.length) {
                e[0].hide()
                return
              }
              e[0].show(),
              t.dispatchEvent(
                new CustomEvent('merge-tags-update-items', {
                  detail: n.items
                })
              )
            },
            onKeyDown (n) {
              t.dispatchEvent(
                new CustomEvent('merge-tags-key-down', {
                  detail: n.event
                })
              )
            },
            onExit () {
              e[0].destroy()
            }
          }
        }
      })
    ]
  }
})
const Sm = We.create({
  name: 'classExtension',
  addGlobalAttributes () {
    return [
      {
        types: [
          'heading',
          'paragraph',
          'link',
          'image',
          'listItem',
          'bulletList',
          'orderedList',
          'table',
          'tableHeader',
          'tableRow',
          'tableCell',
          'textStyle'
        ],
        attributes: {
          class: {
            default: null,
            parseHTML: (t) => t.getAttribute('class') ?? null,
            renderHTML: (t) =>
              t.class ? { class: t.class } : null
          }
        }
      }
    ]
  }
})
const Tm = We.create({
  name: 'idExtension',
  addGlobalAttributes () {
    return [
      {
        types: ['heading', 'link'],
        attributes: {
          id: {
            default: null,
            parseHTML: (t) => t.getAttribute('id') ?? null,
            renderHTML: (t) => (t.id ? { id: t.id } : null)
          }
        }
      }
    ]
  }
})
const Cm = We.create({
  name: 'styleExtension',
  addGlobalAttributes () {
    return [
      {
        types: [
          'heading',
          'paragraph',
          'link',
          'image',
          'listItem',
          'bulletList',
          'orderedList',
          'table',
          'tableHeader',
          'tableRow',
          'tableCell',
          'textStyle'
        ],
        attributes: {
          style: {
            default: null,
            parseHTML: (t) => t.getAttribute('style') ?? null,
            renderHTML: (t) =>
              t.style ? { style: t.style } : null
          }
        }
      }
    ]
  }
})
const Am = We.create({
  name: 'statePath',
  addOptions () {
    return { statePath: null }
  },
  addStorage () {
    return { statePath: null }
  },
  onBeforeCreate () {
    this.storage.statePath = this.options.statePath
  },
  addCommands () {
    return { getStatePath: () => () => this.storage.statePath }
  }
})
function _F (t) {
  const e = t.regex
  const n = t.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] })
  const r = 'decltype\\(auto\\)'
  const i = '[a-zA-Z_]\\w*::'
  const s =
        '(?!struct)(' +
        r +
        '|' +
        e.optional(i) +
        '[a-zA-Z_]\\w*' +
        e.optional('<[^<>]+>') +
        ')'
  const l = { className: 'type', begin: '\\b[a-z\\d_]*_t\\b' }
  const d = {
    className: 'string',
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: '\\n',
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin:
                    "(u8?|U|L)?'(" +
                    '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)' +
                    '|.)',
        end: "'",
        illegal: '.'
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }
  const f = {
    className: 'number',
    variants: [
      { begin: "\\b(0b[01']+)" },
      {
        begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
      },
      {
        begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
      }
    ],
    relevance: 0
  }
  const h = {
    className: 'meta',
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: {
      keyword:
                'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include'
    },
    contains: [
      { begin: /\\\n/, relevance: 0 },
      t.inherit(d, { className: 'string' }),
      { className: 'string', begin: /<.*?>/ },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }
  const m = {
    className: 'title',
    begin: e.optional(i) + t.IDENT_RE,
    relevance: 0
  }
  const b = e.optional(i) + t.IDENT_RE + '\\s*\\('
  const g = [
    'alignas',
    'alignof',
    'and',
    'and_eq',
    'asm',
    'atomic_cancel',
    'atomic_commit',
    'atomic_noexcept',
    'auto',
    'bitand',
    'bitor',
    'break',
    'case',
    'catch',
    'class',
    'co_await',
    'co_return',
    'co_yield',
    'compl',
    'concept',
    'const_cast|10',
    'consteval',
    'constexpr',
    'constinit',
    'continue',
    'decltype',
    'default',
    'delete',
    'do',
    'dynamic_cast|10',
    'else',
    'enum',
    'explicit',
    'export',
    'extern',
    'false',
    'final',
    'for',
    'friend',
    'goto',
    'if',
    'import',
    'inline',
    'module',
    'mutable',
    'namespace',
    'new',
    'noexcept',
    'not',
    'not_eq',
    'nullptr',
    'operator',
    'or',
    'or_eq',
    'override',
    'private',
    'protected',
    'public',
    'reflexpr',
    'register',
    'reinterpret_cast|10',
    'requires',
    'return',
    'sizeof',
    'static_assert',
    'static_cast|10',
    'struct',
    'switch',
    'synchronized',
    'template',
    'this',
    'thread_local',
    'throw',
    'transaction_safe',
    'transaction_safe_dynamic',
    'true',
    'try',
    'typedef',
    'typeid',
    'typename',
    'union',
    'using',
    'virtual',
    'volatile',
    'while',
    'xor',
    'xor_eq'
  ]
  const E = [
    'bool',
    'char',
    'char16_t',
    'char32_t',
    'char8_t',
    'double',
    'float',
    'int',
    'long',
    'short',
    'void',
    'wchar_t',
    'unsigned',
    'signed',
    'const',
    'static'
  ]
  const w = [
    'any',
    'auto_ptr',
    'barrier',
    'binary_semaphore',
    'bitset',
    'complex',
    'condition_variable',
    'condition_variable_any',
    'counting_semaphore',
    'deque',
    'false_type',
    'future',
    'imaginary',
    'initializer_list',
    'istringstream',
    'jthread',
    'latch',
    'lock_guard',
    'multimap',
    'multiset',
    'mutex',
    'optional',
    'ostringstream',
    'packaged_task',
    'pair',
    'promise',
    'priority_queue',
    'queue',
    'recursive_mutex',
    'recursive_timed_mutex',
    'scoped_lock',
    'set',
    'shared_future',
    'shared_lock',
    'shared_mutex',
    'shared_timed_mutex',
    'shared_ptr',
    'stack',
    'string_view',
    'stringstream',
    'timed_mutex',
    'thread',
    'true_type',
    'tuple',
    'unique_lock',
    'unique_ptr',
    'unordered_map',
    'unordered_multimap',
    'unordered_multiset',
    'unordered_set',
    'variant',
    'vector',
    'weak_ptr',
    'wstring',
    'wstring_view'
  ]
  const S = [
    'abort',
    'abs',
    'acos',
    'apply',
    'as_const',
    'asin',
    'atan',
    'atan2',
    'calloc',
    'ceil',
    'cerr',
    'cin',
    'clog',
    'cos',
    'cosh',
    'cout',
    'declval',
    'endl',
    'exchange',
    'exit',
    'exp',
    'fabs',
    'floor',
    'fmod',
    'forward',
    'fprintf',
    'fputs',
    'free',
    'frexp',
    'fscanf',
    'future',
    'invoke',
    'isalnum',
    'isalpha',
    'iscntrl',
    'isdigit',
    'isgraph',
    'islower',
    'isprint',
    'ispunct',
    'isspace',
    'isupper',
    'isxdigit',
    'labs',
    'launder',
    'ldexp',
    'log',
    'log10',
    'make_pair',
    'make_shared',
    'make_shared_for_overwrite',
    'make_tuple',
    'make_unique',
    'malloc',
    'memchr',
    'memcmp',
    'memcpy',
    'memset',
    'modf',
    'move',
    'pow',
    'printf',
    'putchar',
    'puts',
    'realloc',
    'scanf',
    'sin',
    'sinh',
    'snprintf',
    'sprintf',
    'sqrt',
    'sscanf',
    'std',
    'stderr',
    'stdin',
    'stdout',
    'strcat',
    'strchr',
    'strcmp',
    'strcpy',
    'strcspn',
    'strlen',
    'strncat',
    'strncmp',
    'strncpy',
    'strpbrk',
    'strrchr',
    'strspn',
    'strstr',
    'swap',
    'tan',
    'tanh',
    'terminate',
    'to_underlying',
    'tolower',
    'toupper',
    'vfprintf',
    'visit',
    'vprintf',
    'vsprintf'
  ]
  const T = {
    type: E,
    keyword: g,
    literal: ['NULL', 'false', 'nullopt', 'nullptr', 'true'],
    built_in: ['_Pragma'],
    _type_hints: w
  }
  const P = {
    className: 'function.dispatch',
    relevance: 0,
    keywords: { _hint: S },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }
  const I = [P, h, l, n, t.C_BLOCK_COMMENT_MODE, f, d]
  const Y = {
    variants: [
      { begin: /=/, end: /;/ },
      { begin: /\(/, end: /\)/ },
      { beginKeywords: 'new throw return else', end: /;/ }
    ],
    keywords: T,
    contains: I.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: T,
        contains: I.concat(['self']),
        relevance: 0
      }
    ]),
    relevance: 0
  }
  const ne = {
    className: 'function',
    begin: '(' + s + '[\\*&\\s]+)+' + b,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: T,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      { begin: r, keywords: T, relevance: 0 },
      { begin: b, returnBegin: !0, contains: [m], relevance: 0 },
      { begin: /::/, relevance: 0 },
      { begin: /:/, endsWithParent: !0, contains: [d, f] },
      { relevance: 0, match: /,/ },
      {
        className: 'params',
        begin: /\(/,
        end: /\)/,
        keywords: T,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          d,
          f,
          l,
          {
            begin: /\(/,
            end: /\)/,
            keywords: T,
            relevance: 0,
            contains: ['self', n, t.C_BLOCK_COMMENT_MODE, d, f, l]
          }
        ]
      },
      l,
      n,
      t.C_BLOCK_COMMENT_MODE,
      h
    ]
  }
  return {
    name: 'C++',
    aliases: ['cc', 'c++', 'h++', 'hpp', 'hh', 'hxx', 'cxx'],
    keywords: T,
    illegal: '</',
    classNameAliases: { 'function.dispatch': 'built_in' },
    contains: [].concat(Y, ne, P, I, [
      h,
      {
        begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)',
        end: '>',
        keywords: T,
        contains: ['self', l]
      },
      { begin: t.IDENT_RE + '::', keywords: T },
      {
        match: [
          /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
          /\s+/,
          /\w+/
        ],
        className: { 1: 'keyword', 3: 'title.class' }
      }
    ])
  }
}
function Xx (t) {
  const e = {
    type: ['boolean', 'byte', 'word', 'String'],
    built_in: [
      'KeyboardController',
      'MouseController',
      'SoftwareSerial',
      'EthernetServer',
      'EthernetClient',
      'LiquidCrystal',
      'RobotControl',
      'GSMVoiceCall',
      'EthernetUDP',
      'EsploraTFT',
      'HttpClient',
      'RobotMotor',
      'WiFiClient',
      'GSMScanner',
      'FileSystem',
      'Scheduler',
      'GSMServer',
      'YunClient',
      'YunServer',
      'IPAddress',
      'GSMClient',
      'GSMModem',
      'Keyboard',
      'Ethernet',
      'Console',
      'GSMBand',
      'Esplora',
      'Stepper',
      'Process',
      'WiFiUDP',
      'GSM_SMS',
      'Mailbox',
      'USBHost',
      'Firmata',
      'PImage',
      'Client',
      'Server',
      'GSMPIN',
      'FileIO',
      'Bridge',
      'Serial',
      'EEPROM',
      'Stream',
      'Mouse',
      'Audio',
      'Servo',
      'File',
      'Task',
      'GPRS',
      'WiFi',
      'Wire',
      'TFT',
      'GSM',
      'SPI',
      'SD'
    ],
    _hints: [
      'setup',
      'loop',
      'runShellCommandAsynchronously',
      'analogWriteResolution',
      'retrieveCallingNumber',
      'printFirmwareVersion',
      'analogReadResolution',
      'sendDigitalPortPair',
      'noListenOnLocalhost',
      'readJoystickButton',
      'setFirmwareVersion',
      'readJoystickSwitch',
      'scrollDisplayRight',
      'getVoiceCallStatus',
      'scrollDisplayLeft',
      'writeMicroseconds',
      'delayMicroseconds',
      'beginTransmission',
      'getSignalStrength',
      'runAsynchronously',
      'getAsynchronously',
      'listenOnLocalhost',
      'getCurrentCarrier',
      'readAccelerometer',
      'messageAvailable',
      'sendDigitalPorts',
      'lineFollowConfig',
      'countryNameWrite',
      'runShellCommand',
      'readStringUntil',
      'rewindDirectory',
      'readTemperature',
      'setClockDivider',
      'readLightSensor',
      'endTransmission',
      'analogReference',
      'detachInterrupt',
      'countryNameRead',
      'attachInterrupt',
      'encryptionType',
      'readBytesUntil',
      'robotNameWrite',
      'readMicrophone',
      'robotNameRead',
      'cityNameWrite',
      'userNameWrite',
      'readJoystickY',
      'readJoystickX',
      'mouseReleased',
      'openNextFile',
      'scanNetworks',
      'noInterrupts',
      'digitalWrite',
      'beginSpeaker',
      'mousePressed',
      'isActionDone',
      'mouseDragged',
      'displayLogos',
      'noAutoscroll',
      'addParameter',
      'remoteNumber',
      'getModifiers',
      'keyboardRead',
      'userNameRead',
      'waitContinue',
      'processInput',
      'parseCommand',
      'printVersion',
      'readNetworks',
      'writeMessage',
      'blinkVersion',
      'cityNameRead',
      'readMessage',
      'setDataMode',
      'parsePacket',
      'isListening',
      'setBitOrder',
      'beginPacket',
      'isDirectory',
      'motorsWrite',
      'drawCompass',
      'digitalRead',
      'clearScreen',
      'serialEvent',
      'rightToLeft',
      'setTextSize',
      'leftToRight',
      'requestFrom',
      'keyReleased',
      'compassRead',
      'analogWrite',
      'interrupts',
      'WiFiServer',
      'disconnect',
      'playMelody',
      'parseFloat',
      'autoscroll',
      'getPINUsed',
      'setPINUsed',
      'setTimeout',
      'sendAnalog',
      'readSlider',
      'analogRead',
      'beginWrite',
      'createChar',
      'motorsStop',
      'keyPressed',
      'tempoWrite',
      'readButton',
      'subnetMask',
      'debugPrint',
      'macAddress',
      'writeGreen',
      'randomSeed',
      'attachGPRS',
      'readString',
      'sendString',
      'remotePort',
      'releaseAll',
      'mouseMoved',
      'background',
      'getXChange',
      'getYChange',
      'answerCall',
      'getResult',
      'voiceCall',
      'endPacket',
      'constrain',
      'getSocket',
      'writeJSON',
      'getButton',
      'available',
      'connected',
      'findUntil',
      'readBytes',
      'exitValue',
      'readGreen',
      'writeBlue',
      'startLoop',
      'IPAddress',
      'isPressed',
      'sendSysex',
      'pauseMode',
      'gatewayIP',
      'setCursor',
      'getOemKey',
      'tuneWrite',
      'noDisplay',
      'loadImage',
      'switchPIN',
      'onRequest',
      'onReceive',
      'changePIN',
      'playFile',
      'noBuffer',
      'parseInt',
      'overflow',
      'checkPIN',
      'knobRead',
      'beginTFT',
      'bitClear',
      'updateIR',
      'bitWrite',
      'position',
      'writeRGB',
      'highByte',
      'writeRed',
      'setSpeed',
      'readBlue',
      'noStroke',
      'remoteIP',
      'transfer',
      'shutdown',
      'hangCall',
      'beginSMS',
      'endWrite',
      'attached',
      'maintain',
      'noCursor',
      'checkReg',
      'checkPUK',
      'shiftOut',
      'isValid',
      'shiftIn',
      'pulseIn',
      'connect',
      'println',
      'localIP',
      'pinMode',
      'getIMEI',
      'display',
      'noBlink',
      'process',
      'getBand',
      'running',
      'beginSD',
      'drawBMP',
      'lowByte',
      'setBand',
      'release',
      'bitRead',
      'prepare',
      'pointTo',
      'readRed',
      'setMode',
      'noFill',
      'remove',
      'listen',
      'stroke',
      'detach',
      'attach',
      'noTone',
      'exists',
      'buffer',
      'height',
      'bitSet',
      'circle',
      'config',
      'cursor',
      'random',
      'IRread',
      'setDNS',
      'endSMS',
      'getKey',
      'micros',
      'millis',
      'begin',
      'print',
      'write',
      'ready',
      'flush',
      'width',
      'isPIN',
      'blink',
      'clear',
      'press',
      'mkdir',
      'rmdir',
      'close',
      'point',
      'yield',
      'image',
      'BSSID',
      'click',
      'delay',
      'read',
      'text',
      'move',
      'peek',
      'beep',
      'rect',
      'line',
      'open',
      'seek',
      'fill',
      'size',
      'turn',
      'stop',
      'home',
      'find',
      'step',
      'tone',
      'sqrt',
      'RSSI',
      'SSID',
      'end',
      'bit',
      'tan',
      'cos',
      'sin',
      'pow',
      'map',
      'abs',
      'max',
      'min',
      'get',
      'run',
      'put'
    ],
    literal: [
      'DIGITAL_MESSAGE',
      'FIRMATA_STRING',
      'ANALOG_MESSAGE',
      'REPORT_DIGITAL',
      'REPORT_ANALOG',
      'INPUT_PULLUP',
      'SET_PIN_MODE',
      'INTERNAL2V56',
      'SYSTEM_RESET',
      'LED_BUILTIN',
      'INTERNAL1V1',
      'SYSEX_START',
      'INTERNAL',
      'EXTERNAL',
      'DEFAULT',
      'OUTPUT',
      'INPUT',
      'HIGH',
      'LOW'
    ]
  }
  const n = _F(t)
  const r = n.keywords
  return (
    (r.type = [...r.type, ...e.type]),
    (r.literal = [...r.literal, ...e.literal]),
    (r.built_in = [...r.built_in, ...e.built_in]),
    (r._hints = e._hints),
    (n.name = 'Arduino'),
    (n.aliases = ['ino']),
    (n.supersetOf = 'cpp'),
    n
  )
}
function Zx (t) {
  const e = t.regex
  const n = {}
  const r = {
    begin: /\$\{/,
    end: /\}/,
    contains: ['self', { begin: /:-/, contains: [n] }]
  }
  Object.assign(n, {
    className: 'variable',
    variants: [
      { begin: e.concat(/\$[\w\d#@][\w\d_]*/, '(?![\\w\\d])(?![$])') },
      r
    ]
  })
  const i = {
    className: 'subst',
    begin: /\$\(/,
    end: /\)/,
    contains: [t.BACKSLASH_ESCAPE]
  }
  const o = {
    begin: /<<-?\s*(?=\w+)/,
    starts: {
      contains: [
        t.END_SAME_AS_BEGIN({
          begin: /(\w+)/,
          end: /(\w+)/,
          className: 'string'
        })
      ]
    }
  }
  const s = {
    className: 'string',
    begin: /"/,
    end: /"/,
    contains: [t.BACKSLASH_ESCAPE, n, i]
  }
  i.contains.push(s)
  const l = { className: '', begin: /\\"/ }
  const u = { className: 'string', begin: /'/, end: /'/ }
  const d = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      { begin: /\d+#[0-9a-f]+/, className: 'number' },
      t.NUMBER_MODE,
      n
    ]
  }
  const f = [
    'fish',
    'bash',
    'zsh',
    'sh',
    'csh',
    'ksh',
    'tcsh',
    'dash',
    'scsh'
  ]
  const h = t.SHEBANG({ binary: `(${f.join('|')})`, relevance: 10 })
  const m = {
    className: 'function',
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [t.inherit(t.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }
  const b = [
    'if',
    'then',
    'else',
    'elif',
    'fi',
    'for',
    'while',
    'until',
    'in',
    'do',
    'done',
    'case',
    'esac',
    'function',
    'select'
  ]
  const g = ['true', 'false']
  const E = { match: /(\/[a-z._-]+)+/ }
  const w = [
    'break',
    'cd',
    'continue',
    'eval',
    'exec',
    'exit',
    'export',
    'getopts',
    'hash',
    'pwd',
    'readonly',
    'return',
    'shift',
    'test',
    'times',
    'trap',
    'umask',
    'unset'
  ]
  const S = [
    'alias',
    'bind',
    'builtin',
    'caller',
    'command',
    'declare',
    'echo',
    'enable',
    'help',
    'let',
    'local',
    'logout',
    'mapfile',
    'printf',
    'read',
    'readarray',
    'source',
    'type',
    'typeset',
    'ulimit',
    'unalias'
  ]
  const O = [
    'autoload',
    'bg',
    'bindkey',
    'bye',
    'cap',
    'chdir',
    'clone',
    'comparguments',
    'compcall',
    'compctl',
    'compdescribe',
    'compfiles',
    'compgroups',
    'compquote',
    'comptags',
    'comptry',
    'compvalues',
    'dirs',
    'disable',
    'disown',
    'echotc',
    'echoti',
    'emulate',
    'fc',
    'fg',
    'float',
    'functions',
    'getcap',
    'getln',
    'history',
    'integer',
    'jobs',
    'kill',
    'limit',
    'log',
    'noglob',
    'popd',
    'print',
    'pushd',
    'pushln',
    'rehash',
    'sched',
    'setcap',
    'setopt',
    'stat',
    'suspend',
    'ttyctl',
    'unfunction',
    'unhash',
    'unlimit',
    'unsetopt',
    'vared',
    'wait',
    'whence',
    'where',
    'which',
    'zcompile',
    'zformat',
    'zftp',
    'zle',
    'zmodload',
    'zparseopts',
    'zprof',
    'zpty',
    'zregexparse',
    'zsocket',
    'zstyle',
    'ztcp'
  ]
  const k = [
    'chcon',
    'chgrp',
    'chown',
    'chmod',
    'cp',
    'dd',
    'df',
    'dir',
    'dircolors',
    'ln',
    'ls',
    'mkdir',
    'mkfifo',
    'mknod',
    'mktemp',
    'mv',
    'realpath',
    'rm',
    'rmdir',
    'shred',
    'sync',
    'touch',
    'truncate',
    'vdir',
    'b2sum',
    'base32',
    'base64',
    'cat',
    'cksum',
    'comm',
    'csplit',
    'cut',
    'expand',
    'fmt',
    'fold',
    'head',
    'join',
    'md5sum',
    'nl',
    'numfmt',
    'od',
    'paste',
    'ptx',
    'pr',
    'sha1sum',
    'sha224sum',
    'sha256sum',
    'sha384sum',
    'sha512sum',
    'shuf',
    'sort',
    'split',
    'sum',
    'tac',
    'tail',
    'tr',
    'tsort',
    'unexpand',
    'uniq',
    'wc',
    'arch',
    'basename',
    'chroot',
    'date',
    'dirname',
    'du',
    'echo',
    'env',
    'expr',
    'factor',
    'groups',
    'hostid',
    'id',
    'link',
    'logname',
    'nice',
    'nohup',
    'nproc',
    'pathchk',
    'pinky',
    'printenv',
    'printf',
    'pwd',
    'readlink',
    'runcon',
    'seq',
    'sleep',
    'stat',
    'stdbuf',
    'stty',
    'tee',
    'test',
    'timeout',
    'tty',
    'uname',
    'unlink',
    'uptime',
    'users',
    'who',
    'whoami',
    'yes'
  ]
  return {
    name: 'Bash',
    aliases: ['sh'],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: b,
      literal: g,
      built_in: [...w, ...S, 'set', 'shopt', ...O, ...k]
    },
    contains: [h, t.SHEBANG(), m, d, t.HASH_COMMENT_MODE, o, E, s, l, u, n]
  }
}
function jx (t) {
  const e = t.regex
  const n = t.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] })
  const r = 'decltype\\(auto\\)'
  const i = '[a-zA-Z_]\\w*::'
  const s =
        '(' +
        r +
        '|' +
        e.optional(i) +
        '[a-zA-Z_]\\w*' +
        e.optional('<[^<>]+>') +
        ')'
  const l = {
    className: 'type',
    variants: [
      { begin: '\\b[a-z\\d_]*_t\\b' },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }
  const d = {
    className: 'string',
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: '\\n',
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin:
                    "(u8?|U|L)?'(" +
                    '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)' +
                    '|.)',
        end: "'",
        illegal: '.'
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }
  const f = {
    className: 'number',
    variants: [
      { begin: "\\b(0b[01']+)" },
      {
        begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
      },
      {
        begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
      }
    ],
    relevance: 0
  }
  const h = {
    className: 'meta',
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: {
      keyword:
                'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include'
    },
    contains: [
      { begin: /\\\n/, relevance: 0 },
      t.inherit(d, { className: 'string' }),
      { className: 'string', begin: /<.*?>/ },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }
  const m = {
    className: 'title',
    begin: e.optional(i) + t.IDENT_RE,
    relevance: 0
  }
  const b = e.optional(i) + t.IDENT_RE + '\\s*\\('
  const w = {
    keyword: [
      'asm',
      'auto',
      'break',
      'case',
      'continue',
      'default',
      'do',
      'else',
      'enum',
      'extern',
      'for',
      'fortran',
      'goto',
      'if',
      'inline',
      'register',
      'restrict',
      'return',
      'sizeof',
      'struct',
      'switch',
      'typedef',
      'union',
      'volatile',
      'while',
      '_Alignas',
      '_Alignof',
      '_Atomic',
      '_Generic',
      '_Noreturn',
      '_Static_assert',
      '_Thread_local',
      'alignas',
      'alignof',
      'noreturn',
      'static_assert',
      'thread_local',
      '_Pragma'
    ],
    type: [
      'float',
      'double',
      'signed',
      'unsigned',
      'int',
      'short',
      'long',
      'char',
      'void',
      '_Bool',
      '_Complex',
      '_Imaginary',
      '_Decimal32',
      '_Decimal64',
      '_Decimal128',
      'const',
      'static',
      'complex',
      'bool',
      'imaginary'
    ],
    literal: 'true false NULL',
    built_in:
            'std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr'
  }
  const S = [h, l, n, t.C_BLOCK_COMMENT_MODE, f, d]
  const O = {
    variants: [
      { begin: /=/, end: /;/ },
      { begin: /\(/, end: /\)/ },
      { beginKeywords: 'new throw return else', end: /;/ }
    ],
    keywords: w,
    contains: S.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: w,
        contains: S.concat(['self']),
        relevance: 0
      }
    ]),
    relevance: 0
  }
  const k = {
    begin: '(' + s + '[\\*&\\s]+)+' + b,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: w,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      { begin: r, keywords: w, relevance: 0 },
      {
        begin: b,
        returnBegin: !0,
        contains: [t.inherit(m, { className: 'title.function' })],
        relevance: 0
      },
      { relevance: 0, match: /,/ },
      {
        className: 'params',
        begin: /\(/,
        end: /\)/,
        keywords: w,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          d,
          f,
          l,
          {
            begin: /\(/,
            end: /\)/,
            keywords: w,
            relevance: 0,
            contains: ['self', n, t.C_BLOCK_COMMENT_MODE, d, f, l]
          }
        ]
      },
      l,
      n,
      t.C_BLOCK_COMMENT_MODE,
      h
    ]
  }
  return {
    name: 'C',
    aliases: ['h'],
    keywords: w,
    disableAutodetect: !0,
    illegal: '</',
    contains: [].concat(O, k, S, [
      h,
      { begin: t.IDENT_RE + '::', keywords: w },
      {
        className: 'class',
        beginKeywords: 'enum class struct union',
        end: /[{;:<>=]/,
        contains: [
          { beginKeywords: 'final class struct' },
          t.TITLE_MODE
        ]
      }
    ]),
    exports: { preprocessor: h, strings: d, keywords: w }
  }
}
function Qx (t) {
  const e = t.regex
  const n = t.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] })
  const r = 'decltype\\(auto\\)'
  const i = '[a-zA-Z_]\\w*::'
  const s =
        '(?!struct)(' +
        r +
        '|' +
        e.optional(i) +
        '[a-zA-Z_]\\w*' +
        e.optional('<[^<>]+>') +
        ')'
  const l = { className: 'type', begin: '\\b[a-z\\d_]*_t\\b' }
  const d = {
    className: 'string',
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: '\\n',
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin:
                    "(u8?|U|L)?'(" +
                    '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)' +
                    '|.)',
        end: "'",
        illegal: '.'
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }
  const f = {
    className: 'number',
    variants: [
      { begin: "\\b(0b[01']+)" },
      {
        begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
      },
      {
        begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
      }
    ],
    relevance: 0
  }
  const h = {
    className: 'meta',
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: {
      keyword:
                'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include'
    },
    contains: [
      { begin: /\\\n/, relevance: 0 },
      t.inherit(d, { className: 'string' }),
      { className: 'string', begin: /<.*?>/ },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }
  const m = {
    className: 'title',
    begin: e.optional(i) + t.IDENT_RE,
    relevance: 0
  }
  const b = e.optional(i) + t.IDENT_RE + '\\s*\\('
  const g = [
    'alignas',
    'alignof',
    'and',
    'and_eq',
    'asm',
    'atomic_cancel',
    'atomic_commit',
    'atomic_noexcept',
    'auto',
    'bitand',
    'bitor',
    'break',
    'case',
    'catch',
    'class',
    'co_await',
    'co_return',
    'co_yield',
    'compl',
    'concept',
    'const_cast|10',
    'consteval',
    'constexpr',
    'constinit',
    'continue',
    'decltype',
    'default',
    'delete',
    'do',
    'dynamic_cast|10',
    'else',
    'enum',
    'explicit',
    'export',
    'extern',
    'false',
    'final',
    'for',
    'friend',
    'goto',
    'if',
    'import',
    'inline',
    'module',
    'mutable',
    'namespace',
    'new',
    'noexcept',
    'not',
    'not_eq',
    'nullptr',
    'operator',
    'or',
    'or_eq',
    'override',
    'private',
    'protected',
    'public',
    'reflexpr',
    'register',
    'reinterpret_cast|10',
    'requires',
    'return',
    'sizeof',
    'static_assert',
    'static_cast|10',
    'struct',
    'switch',
    'synchronized',
    'template',
    'this',
    'thread_local',
    'throw',
    'transaction_safe',
    'transaction_safe_dynamic',
    'true',
    'try',
    'typedef',
    'typeid',
    'typename',
    'union',
    'using',
    'virtual',
    'volatile',
    'while',
    'xor',
    'xor_eq'
  ]
  const E = [
    'bool',
    'char',
    'char16_t',
    'char32_t',
    'char8_t',
    'double',
    'float',
    'int',
    'long',
    'short',
    'void',
    'wchar_t',
    'unsigned',
    'signed',
    'const',
    'static'
  ]
  const w = [
    'any',
    'auto_ptr',
    'barrier',
    'binary_semaphore',
    'bitset',
    'complex',
    'condition_variable',
    'condition_variable_any',
    'counting_semaphore',
    'deque',
    'false_type',
    'future',
    'imaginary',
    'initializer_list',
    'istringstream',
    'jthread',
    'latch',
    'lock_guard',
    'multimap',
    'multiset',
    'mutex',
    'optional',
    'ostringstream',
    'packaged_task',
    'pair',
    'promise',
    'priority_queue',
    'queue',
    'recursive_mutex',
    'recursive_timed_mutex',
    'scoped_lock',
    'set',
    'shared_future',
    'shared_lock',
    'shared_mutex',
    'shared_timed_mutex',
    'shared_ptr',
    'stack',
    'string_view',
    'stringstream',
    'timed_mutex',
    'thread',
    'true_type',
    'tuple',
    'unique_lock',
    'unique_ptr',
    'unordered_map',
    'unordered_multimap',
    'unordered_multiset',
    'unordered_set',
    'variant',
    'vector',
    'weak_ptr',
    'wstring',
    'wstring_view'
  ]
  const S = [
    'abort',
    'abs',
    'acos',
    'apply',
    'as_const',
    'asin',
    'atan',
    'atan2',
    'calloc',
    'ceil',
    'cerr',
    'cin',
    'clog',
    'cos',
    'cosh',
    'cout',
    'declval',
    'endl',
    'exchange',
    'exit',
    'exp',
    'fabs',
    'floor',
    'fmod',
    'forward',
    'fprintf',
    'fputs',
    'free',
    'frexp',
    'fscanf',
    'future',
    'invoke',
    'isalnum',
    'isalpha',
    'iscntrl',
    'isdigit',
    'isgraph',
    'islower',
    'isprint',
    'ispunct',
    'isspace',
    'isupper',
    'isxdigit',
    'labs',
    'launder',
    'ldexp',
    'log',
    'log10',
    'make_pair',
    'make_shared',
    'make_shared_for_overwrite',
    'make_tuple',
    'make_unique',
    'malloc',
    'memchr',
    'memcmp',
    'memcpy',
    'memset',
    'modf',
    'move',
    'pow',
    'printf',
    'putchar',
    'puts',
    'realloc',
    'scanf',
    'sin',
    'sinh',
    'snprintf',
    'sprintf',
    'sqrt',
    'sscanf',
    'std',
    'stderr',
    'stdin',
    'stdout',
    'strcat',
    'strchr',
    'strcmp',
    'strcpy',
    'strcspn',
    'strlen',
    'strncat',
    'strncmp',
    'strncpy',
    'strpbrk',
    'strrchr',
    'strspn',
    'strstr',
    'swap',
    'tan',
    'tanh',
    'terminate',
    'to_underlying',
    'tolower',
    'toupper',
    'vfprintf',
    'visit',
    'vprintf',
    'vsprintf'
  ]
  const T = {
    type: E,
    keyword: g,
    literal: ['NULL', 'false', 'nullopt', 'nullptr', 'true'],
    built_in: ['_Pragma'],
    _type_hints: w
  }
  const P = {
    className: 'function.dispatch',
    relevance: 0,
    keywords: { _hint: S },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }
  const I = [P, h, l, n, t.C_BLOCK_COMMENT_MODE, f, d]
  const Y = {
    variants: [
      { begin: /=/, end: /;/ },
      { begin: /\(/, end: /\)/ },
      { beginKeywords: 'new throw return else', end: /;/ }
    ],
    keywords: T,
    contains: I.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: T,
        contains: I.concat(['self']),
        relevance: 0
      }
    ]),
    relevance: 0
  }
  const ne = {
    className: 'function',
    begin: '(' + s + '[\\*&\\s]+)+' + b,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: T,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      { begin: r, keywords: T, relevance: 0 },
      { begin: b, returnBegin: !0, contains: [m], relevance: 0 },
      { begin: /::/, relevance: 0 },
      { begin: /:/, endsWithParent: !0, contains: [d, f] },
      { relevance: 0, match: /,/ },
      {
        className: 'params',
        begin: /\(/,
        end: /\)/,
        keywords: T,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          d,
          f,
          l,
          {
            begin: /\(/,
            end: /\)/,
            keywords: T,
            relevance: 0,
            contains: ['self', n, t.C_BLOCK_COMMENT_MODE, d, f, l]
          }
        ]
      },
      l,
      n,
      t.C_BLOCK_COMMENT_MODE,
      h
    ]
  }
  return {
    name: 'C++',
    aliases: ['cc', 'c++', 'h++', 'hpp', 'hh', 'hxx', 'cxx'],
    keywords: T,
    illegal: '</',
    classNameAliases: { 'function.dispatch': 'built_in' },
    contains: [].concat(Y, ne, P, I, [
      h,
      {
        begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)',
        end: '>',
        keywords: T,
        contains: ['self', l]
      },
      { begin: t.IDENT_RE + '::', keywords: T },
      {
        match: [
          /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
          /\s+/,
          /\w+/
        ],
        className: { 1: 'keyword', 3: 'title.class' }
      }
    ])
  }
}
function e_ (t) {
  const e = [
    'bool',
    'byte',
    'char',
    'decimal',
    'delegate',
    'double',
    'dynamic',
    'enum',
    'float',
    'int',
    'long',
    'nint',
    'nuint',
    'object',
    'sbyte',
    'short',
    'string',
    'ulong',
    'uint',
    'ushort'
  ]
  const n = [
    'public',
    'private',
    'protected',
    'static',
    'internal',
    'protected',
    'abstract',
    'async',
    'extern',
    'override',
    'unsafe',
    'virtual',
    'new',
    'sealed',
    'partial'
  ]
  const r = ['default', 'false', 'null', 'true']
  const i = [
    'abstract',
    'as',
    'base',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'do',
    'else',
    'event',
    'explicit',
    'extern',
    'finally',
    'fixed',
    'for',
    'foreach',
    'goto',
    'if',
    'implicit',
    'in',
    'interface',
    'internal',
    'is',
    'lock',
    'namespace',
    'new',
    'operator',
    'out',
    'override',
    'params',
    'private',
    'protected',
    'public',
    'readonly',
    'record',
    'ref',
    'return',
    'scoped',
    'sealed',
    'sizeof',
    'stackalloc',
    'static',
    'struct',
    'switch',
    'this',
    'throw',
    'try',
    'typeof',
    'unchecked',
    'unsafe',
    'using',
    'virtual',
    'void',
    'volatile',
    'while'
  ]
  const o = [
    'add',
    'alias',
    'and',
    'ascending',
    'async',
    'await',
    'by',
    'descending',
    'equals',
    'from',
    'get',
    'global',
    'group',
    'init',
    'into',
    'join',
    'let',
    'nameof',
    'not',
    'notnull',
    'on',
    'or',
    'orderby',
    'partial',
    'remove',
    'select',
    'set',
    'unmanaged',
    'value|0',
    'var',
    'when',
    'where',
    'with',
    'yield'
  ]
  const s = { keyword: i.concat(o), built_in: e, literal: r }
  const l = t.inherit(t.TITLE_MODE, { begin: '[a-zA-Z](\\.?\\w)*' })
  const u = {
    className: 'number',
    variants: [
      { begin: "\\b(0b[01']+)" },
      {
        begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"
      },
      {
        begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
      }
    ],
    relevance: 0
  }
  const d = {
    className: 'string',
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }
  const f = t.inherit(d, { illegal: /\n/ })
  const h = { className: 'subst', begin: /\{/, end: /\}/, keywords: s }
  const m = t.inherit(h, { illegal: /\n/ })
  const b = {
    className: 'string',
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, t.BACKSLASH_ESCAPE, m]
  }
  const g = {
    className: 'string',
    begin: /\$@"/,
    end: '"',
    contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, h]
  }
  const E = t.inherit(g, {
    illegal: /\n/,
    contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, m]
  });
  (h.contains = [
    g,
    b,
    d,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    u,
    t.C_BLOCK_COMMENT_MODE
  ]),
  (m.contains = [
    E,
    b,
    f,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    u,
    t.inherit(t.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ])
  const w = { variants: [g, b, d, t.APOS_STRING_MODE, t.QUOTE_STRING_MODE] }
  const S = {
    begin: '<',
    end: '>',
    contains: [{ beginKeywords: 'in out' }, l]
  }
  const O =
        t.IDENT_RE +
        '(<' +
        t.IDENT_RE +
        '(\\s*,\\s*' +
        t.IDENT_RE +
        ')*>)?(\\[\\])?'
  const k = { begin: '@' + t.IDENT_RE, relevance: 0 }
  return {
    name: 'C#',
    aliases: ['cs', 'c#'],
    keywords: s,
    illegal: /::/,
    contains: [
      t.COMMENT('///', '$', {
        returnBegin: !0,
        contains: [
          {
            className: 'doctag',
            variants: [
              { begin: '///', relevance: 0 },
              { begin: '<!--|-->' },
              { begin: '</?', end: '>' }
            ]
          }
        ]
      }),
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: 'meta',
        begin: '#',
        end: '$',
        keywords: {
          keyword:
                        'if else elif endif define undef warning error line region endregion pragma checksum'
        }
      },
      w,
      u,
      {
        beginKeywords: 'class interface',
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: 'where class' },
          l,
          S,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: 'namespace',
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [l, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE]
      },
      {
        beginKeywords: 'record',
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [l, S, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE]
      },
      {
        className: 'meta',
        begin: '^\\s*\\[(?=[\\w])',
        excludeBegin: !0,
        end: '\\]',
        excludeEnd: !0,
        contains: [{ className: 'string', begin: /"/, end: /"/ }]
      },
      { beginKeywords: 'new return throw await else', relevance: 0 },
      {
        className: 'function',
        begin:
                    '(' + O + '\\s+)+' + t.IDENT_RE + '\\s*(<[^=]+>\\s*)?\\(',
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: s,
        contains: [
          { beginKeywords: n.join(' '), relevance: 0 },
          {
            begin: t.IDENT_RE + '\\s*(<[^=]+>\\s*)?\\(',
            returnBegin: !0,
            contains: [t.TITLE_MODE, S],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: s,
            relevance: 0,
            contains: [w, u, t.C_BLOCK_COMMENT_MODE]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      k
    ]
  }
}
const SF = (t) => ({
  IMPORTANT: { scope: 'meta', begin: '!important' },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: 'number',
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: 'selector-attr',
    begin: /\[/,
    end: /\]/,
    illegal: '$',
    contains: [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE]
  },
  CSS_NUMBER_MODE: {
    scope: 'number',
    begin:
            t.NUMBER_RE +
            '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
    relevance: 0
  },
  CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z][A-Za-z0-9_-]*/ }
})
const TF = [
  'a',
  'abbr',
  'address',
  'article',
  'aside',
  'audio',
  'b',
  'blockquote',
  'body',
  'button',
  'canvas',
  'caption',
  'cite',
  'code',
  'dd',
  'del',
  'details',
  'dfn',
  'div',
  'dl',
  'dt',
  'em',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'html',
  'i',
  'iframe',
  'img',
  'input',
  'ins',
  'kbd',
  'label',
  'legend',
  'li',
  'main',
  'mark',
  'menu',
  'nav',
  'object',
  'ol',
  'p',
  'q',
  'quote',
  'samp',
  'section',
  'span',
  'strong',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'thead',
  'time',
  'tr',
  'ul',
  'var',
  'video'
]
const CF = [
  'any-hover',
  'any-pointer',
  'aspect-ratio',
  'color',
  'color-gamut',
  'color-index',
  'device-aspect-ratio',
  'device-height',
  'device-width',
  'display-mode',
  'forced-colors',
  'grid',
  'height',
  'hover',
  'inverted-colors',
  'monochrome',
  'orientation',
  'overflow-block',
  'overflow-inline',
  'pointer',
  'prefers-color-scheme',
  'prefers-contrast',
  'prefers-reduced-motion',
  'prefers-reduced-transparency',
  'resolution',
  'scan',
  'scripting',
  'update',
  'width',
  'min-width',
  'max-width',
  'min-height',
  'max-height'
]
const AF = [
  'active',
  'any-link',
  'blank',
  'checked',
  'current',
  'default',
  'defined',
  'dir',
  'disabled',
  'drop',
  'empty',
  'enabled',
  'first',
  'first-child',
  'first-of-type',
  'fullscreen',
  'future',
  'focus',
  'focus-visible',
  'focus-within',
  'has',
  'host',
  'host-context',
  'hover',
  'indeterminate',
  'in-range',
  'invalid',
  'is',
  'lang',
  'last-child',
  'last-of-type',
  'left',
  'link',
  'local-link',
  'not',
  'nth-child',
  'nth-col',
  'nth-last-child',
  'nth-last-col',
  'nth-last-of-type',
  'nth-of-type',
  'only-child',
  'only-of-type',
  'optional',
  'out-of-range',
  'past',
  'placeholder-shown',
  'read-only',
  'read-write',
  'required',
  'right',
  'root',
  'scope',
  'target',
  'target-within',
  'user-invalid',
  'valid',
  'visited',
  'where'
]
const MF = [
  'after',
  'backdrop',
  'before',
  'cue',
  'cue-region',
  'first-letter',
  'first-line',
  'grammar-error',
  'marker',
  'part',
  'placeholder',
  'selection',
  'slotted',
  'spelling-error'
]
const NF = [
  'align-content',
  'align-items',
  'align-self',
  'all',
  'animation',
  'animation-delay',
  'animation-direction',
  'animation-duration',
  'animation-fill-mode',
  'animation-iteration-count',
  'animation-name',
  'animation-play-state',
  'animation-timing-function',
  'backface-visibility',
  'background',
  'background-attachment',
  'background-blend-mode',
  'background-clip',
  'background-color',
  'background-image',
  'background-origin',
  'background-position',
  'background-repeat',
  'background-size',
  'block-size',
  'border',
  'border-block',
  'border-block-color',
  'border-block-end',
  'border-block-end-color',
  'border-block-end-style',
  'border-block-end-width',
  'border-block-start',
  'border-block-start-color',
  'border-block-start-style',
  'border-block-start-width',
  'border-block-style',
  'border-block-width',
  'border-bottom',
  'border-bottom-color',
  'border-bottom-left-radius',
  'border-bottom-right-radius',
  'border-bottom-style',
  'border-bottom-width',
  'border-collapse',
  'border-color',
  'border-image',
  'border-image-outset',
  'border-image-repeat',
  'border-image-slice',
  'border-image-source',
  'border-image-width',
  'border-inline',
  'border-inline-color',
  'border-inline-end',
  'border-inline-end-color',
  'border-inline-end-style',
  'border-inline-end-width',
  'border-inline-start',
  'border-inline-start-color',
  'border-inline-start-style',
  'border-inline-start-width',
  'border-inline-style',
  'border-inline-width',
  'border-left',
  'border-left-color',
  'border-left-style',
  'border-left-width',
  'border-radius',
  'border-right',
  'border-right-color',
  'border-right-style',
  'border-right-width',
  'border-spacing',
  'border-style',
  'border-top',
  'border-top-color',
  'border-top-left-radius',
  'border-top-right-radius',
  'border-top-style',
  'border-top-width',
  'border-width',
  'bottom',
  'box-decoration-break',
  'box-shadow',
  'box-sizing',
  'break-after',
  'break-before',
  'break-inside',
  'caption-side',
  'caret-color',
  'clear',
  'clip',
  'clip-path',
  'clip-rule',
  'color',
  'column-count',
  'column-fill',
  'column-gap',
  'column-rule',
  'column-rule-color',
  'column-rule-style',
  'column-rule-width',
  'column-span',
  'column-width',
  'columns',
  'contain',
  'content',
  'content-visibility',
  'counter-increment',
  'counter-reset',
  'cue',
  'cue-after',
  'cue-before',
  'cursor',
  'direction',
  'display',
  'empty-cells',
  'filter',
  'flex',
  'flex-basis',
  'flex-direction',
  'flex-flow',
  'flex-grow',
  'flex-shrink',
  'flex-wrap',
  'float',
  'flow',
  'font',
  'font-display',
  'font-family',
  'font-feature-settings',
  'font-kerning',
  'font-language-override',
  'font-size',
  'font-size-adjust',
  'font-smoothing',
  'font-stretch',
  'font-style',
  'font-synthesis',
  'font-variant',
  'font-variant-caps',
  'font-variant-east-asian',
  'font-variant-ligatures',
  'font-variant-numeric',
  'font-variant-position',
  'font-variation-settings',
  'font-weight',
  'gap',
  'glyph-orientation-vertical',
  'grid',
  'grid-area',
  'grid-auto-columns',
  'grid-auto-flow',
  'grid-auto-rows',
  'grid-column',
  'grid-column-end',
  'grid-column-start',
  'grid-gap',
  'grid-row',
  'grid-row-end',
  'grid-row-start',
  'grid-template',
  'grid-template-areas',
  'grid-template-columns',
  'grid-template-rows',
  'hanging-punctuation',
  'height',
  'hyphens',
  'icon',
  'image-orientation',
  'image-rendering',
  'image-resolution',
  'ime-mode',
  'inline-size',
  'isolation',
  'justify-content',
  'left',
  'letter-spacing',
  'line-break',
  'line-height',
  'list-style',
  'list-style-image',
  'list-style-position',
  'list-style-type',
  'margin',
  'margin-block',
  'margin-block-end',
  'margin-block-start',
  'margin-bottom',
  'margin-inline',
  'margin-inline-end',
  'margin-inline-start',
  'margin-left',
  'margin-right',
  'margin-top',
  'marks',
  'mask',
  'mask-border',
  'mask-border-mode',
  'mask-border-outset',
  'mask-border-repeat',
  'mask-border-slice',
  'mask-border-source',
  'mask-border-width',
  'mask-clip',
  'mask-composite',
  'mask-image',
  'mask-mode',
  'mask-origin',
  'mask-position',
  'mask-repeat',
  'mask-size',
  'mask-type',
  'max-block-size',
  'max-height',
  'max-inline-size',
  'max-width',
  'min-block-size',
  'min-height',
  'min-inline-size',
  'min-width',
  'mix-blend-mode',
  'nav-down',
  'nav-index',
  'nav-left',
  'nav-right',
  'nav-up',
  'none',
  'normal',
  'object-fit',
  'object-position',
  'opacity',
  'order',
  'orphans',
  'outline',
  'outline-color',
  'outline-offset',
  'outline-style',
  'outline-width',
  'overflow',
  'overflow-wrap',
  'overflow-x',
  'overflow-y',
  'padding',
  'padding-block',
  'padding-block-end',
  'padding-block-start',
  'padding-bottom',
  'padding-inline',
  'padding-inline-end',
  'padding-inline-start',
  'padding-left',
  'padding-right',
  'padding-top',
  'page-break-after',
  'page-break-before',
  'page-break-inside',
  'pause',
  'pause-after',
  'pause-before',
  'perspective',
  'perspective-origin',
  'pointer-events',
  'position',
  'quotes',
  'resize',
  'rest',
  'rest-after',
  'rest-before',
  'right',
  'row-gap',
  'scroll-margin',
  'scroll-margin-block',
  'scroll-margin-block-end',
  'scroll-margin-block-start',
  'scroll-margin-bottom',
  'scroll-margin-inline',
  'scroll-margin-inline-end',
  'scroll-margin-inline-start',
  'scroll-margin-left',
  'scroll-margin-right',
  'scroll-margin-top',
  'scroll-padding',
  'scroll-padding-block',
  'scroll-padding-block-end',
  'scroll-padding-block-start',
  'scroll-padding-bottom',
  'scroll-padding-inline',
  'scroll-padding-inline-end',
  'scroll-padding-inline-start',
  'scroll-padding-left',
  'scroll-padding-right',
  'scroll-padding-top',
  'scroll-snap-align',
  'scroll-snap-stop',
  'scroll-snap-type',
  'scrollbar-color',
  'scrollbar-gutter',
  'scrollbar-width',
  'shape-image-threshold',
  'shape-margin',
  'shape-outside',
  'speak',
  'speak-as',
  'src',
  'tab-size',
  'table-layout',
  'text-align',
  'text-align-all',
  'text-align-last',
  'text-combine-upright',
  'text-decoration',
  'text-decoration-color',
  'text-decoration-line',
  'text-decoration-style',
  'text-emphasis',
  'text-emphasis-color',
  'text-emphasis-position',
  'text-emphasis-style',
  'text-indent',
  'text-justify',
  'text-orientation',
  'text-overflow',
  'text-rendering',
  'text-shadow',
  'text-transform',
  'text-underline-position',
  'top',
  'transform',
  'transform-box',
  'transform-origin',
  'transform-style',
  'transition',
  'transition-delay',
  'transition-duration',
  'transition-property',
  'transition-timing-function',
  'unicode-bidi',
  'vertical-align',
  'visibility',
  'voice-balance',
  'voice-duration',
  'voice-family',
  'voice-pitch',
  'voice-range',
  'voice-rate',
  'voice-stress',
  'voice-volume',
  'white-space',
  'widows',
  'width',
  'will-change',
  'word-break',
  'word-spacing',
  'word-wrap',
  'writing-mode',
  'z-index'
].reverse()
function t_ (t) {
  const e = t.regex
  const n = SF(t)
  const r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }
  const i = 'and or not only'
  const o = /@-?\w[\w]*(-\w+)*/
  const s = '[a-zA-Z-][a-zA-Z0-9_-]*'
  const l = [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE]
  return {
    name: 'CSS',
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: 'from to' },
    classNameAliases: { keyframePosition: 'selector-tag' },
    contains: [
      n.BLOCK_COMMENT,
      r,
      n.CSS_NUMBER_MODE,
      {
        className: 'selector-id',
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      { className: 'selector-class', begin: '\\.' + s, relevance: 0 },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: 'selector-pseudo',
        variants: [
          { begin: ':(' + AF.join('|') + ')' },
          { begin: ':(:)?(' + MF.join('|') + ')' }
        ]
      },
      n.CSS_VARIABLE,
      { className: 'attribute', begin: '\\b(' + NF.join('|') + ')\\b' },
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...l,
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            keywords: { built_in: 'url data-uri' },
            contains: [
              ...l,
              {
                className: 'string',
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: e.lookahead(/@/),
        end: '[{;]',
        relevance: 0,
        illegal: /:/,
        contains: [
          { className: 'keyword', begin: o },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: CF.join(' ')
            },
            contains: [
              { begin: /[a-z-]+(?=:)/, className: 'attribute' },
              ...l,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: 'selector-tag',
        begin: '\\b(' + TF.join('|') + ')\\b'
      }
    ]
  }
}
function n_ (t) {
  const e = t.regex
  return {
    name: 'Diff',
    aliases: ['patch'],
    contains: [
      {
        className: 'meta',
        relevance: 10,
        match: e.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: 'comment',
        variants: [
          {
            begin: e.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      { className: 'addition', begin: /^\+/, end: /$/ },
      { className: 'deletion', begin: /^-/, end: /$/ },
      { className: 'addition', begin: /^!/, end: /$/ }
    ]
  }
}
function r_ (t) {
  const o = {
    keyword: [
      'break',
      'case',
      'chan',
      'const',
      'continue',
      'default',
      'defer',
      'else',
      'fallthrough',
      'for',
      'func',
      'go',
      'goto',
      'if',
      'import',
      'interface',
      'map',
      'package',
      'range',
      'return',
      'select',
      'struct',
      'switch',
      'type',
      'var'
    ],
    type: [
      'bool',
      'byte',
      'complex64',
      'complex128',
      'error',
      'float32',
      'float64',
      'int8',
      'int16',
      'int32',
      'int64',
      'string',
      'uint8',
      'uint16',
      'uint32',
      'uint64',
      'int',
      'uint',
      'uintptr',
      'rune'
    ],
    literal: ['true', 'false', 'iota', 'nil'],
    built_in: [
      'append',
      'cap',
      'close',
      'complex',
      'copy',
      'imag',
      'len',
      'make',
      'new',
      'panic',
      'print',
      'println',
      'real',
      'recover',
      'delete'
    ]
  }
  return {
    name: 'Go',
    aliases: ['golang'],
    keywords: o,
    illegal: '</',
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: 'string',
        variants: [
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          { begin: '`', end: '`' }
        ]
      },
      {
        className: 'number',
        variants: [
          { begin: t.C_NUMBER_RE + '[i]', relevance: 1 },
          t.C_NUMBER_MODE
        ]
      },
      { begin: /:=/ },
      {
        className: 'function',
        beginKeywords: 'func',
        end: '\\s*(\\{|$)',
        excludeEnd: !0,
        contains: [
          t.TITLE_MODE,
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: o,
            illegal: /["']/
          }
        ]
      }
    ]
  }
}
function i_ (t) {
  const e = t.regex
  const n = /[_A-Za-z][_0-9A-Za-z]*/
  return {
    name: 'GraphQL',
    aliases: ['gql'],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        'query',
        'mutation',
        'subscription',
        'type',
        'input',
        'schema',
        'directive',
        'interface',
        'union',
        'scalar',
        'fragment',
        'enum',
        'on'
      ],
      literal: ['true', 'false', 'null']
    },
    contains: [
      t.HASH_COMMENT_MODE,
      t.QUOTE_STRING_MODE,
      t.NUMBER_MODE,
      { scope: 'punctuation', match: /[.]{3}/, relevance: 0 },
      {
        scope: 'punctuation',
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: 'variable',
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      { scope: 'meta', match: /@\w+/, excludeEnd: !0 },
      {
        scope: 'symbol',
        begin: e.concat(n, e.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [/[;<']/, /BEGIN/]
  }
}
function o_ (t) {
  const e = t.regex
  const n = {
    className: 'number',
    relevance: 0,
    variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, { begin: t.NUMBER_RE }]
  }
  const r = t.COMMENT()
  r.variants = [
    { begin: /;/, end: /$/ },
    { begin: /#/, end: /$/ }
  ]
  const i = {
    className: 'variable',
    variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }]
  }
  const o = { className: 'literal', begin: /\bon|off|true|false|yes|no\b/ }
  const s = {
    className: 'string',
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      { begin: "'''", end: "'''", relevance: 10 },
      { begin: '"""', end: '"""', relevance: 10 },
      { begin: '"', end: '"' },
      { begin: "'", end: "'" }
    ]
  }
  const l = {
    begin: /\[/,
    end: /\]/,
    contains: [r, o, i, s, n, 'self'],
    relevance: 0
  }
  const u = /[A-Za-z0-9_-]+/
  const d = /"(\\"|[^"])*"/
  const f = /'[^']*'/
  const h = e.either(u, d, f)
  const m = e.concat(
    h,
    '(\\s*\\.\\s*',
    h,
    ')*',
    e.lookahead(/\s*=\s*[^#\s]/)
  )
  return {
    name: 'TOML, also INI',
    aliases: ['toml'],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      { className: 'section', begin: /\[+/, end: /\]+/ },
      {
        begin: m,
        className: 'attr',
        starts: { end: /$/, contains: [r, l, o, i, s, n] }
      }
    ]
  }
}
const us = '[0-9](_*[0-9])*'
const wu = `\\.(${us})`
const xu = '[0-9a-fA-F](_*[0-9a-fA-F])*'
const s_ = {
  className: 'number',
  variants: [
    {
      begin: `(\\b(${us})((${wu})|\\.)?|(${wu}))[eE][+-]?(${us})[fFdD]?\\b`
    },
    { begin: `\\b(${us})((${wu})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${wu})[fFdD]?\\b` },
    { begin: `\\b(${us})[fFdD]\\b` },
    {
      begin: `\\b0[xX]((${xu})\\.?|(${xu})?\\.(${xu}))[pP][+-]?(${us})[fFdD]?\\b`
    },
    { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
    { begin: `\\b0[xX](${xu})[lL]?\\b` },
    { begin: '\\b0(_*[0-7])*[lL]?\\b' },
    { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' }
  ],
  relevance: 0
}
function a_ (t, e, n) {
  return n === -1 ? '' : t.replace(e, (r) => a_(t, e, n - 1))
}
function l_ (t) {
  const e = t.regex
  const n = '[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*'
  const r =
        n + a_('(?:<' + n + '~~~(?:\\s*,\\s*' + n + '~~~)*>)?', /~~~/g, 2)
  const u = {
    keyword: [
      'synchronized',
      'abstract',
      'private',
      'var',
      'static',
      'if',
      'const ',
      'for',
      'while',
      'strictfp',
      'finally',
      'protected',
      'import',
      'native',
      'final',
      'void',
      'enum',
      'else',
      'break',
      'transient',
      'catch',
      'instanceof',
      'volatile',
      'case',
      'assert',
      'package',
      'default',
      'public',
      'try',
      'switch',
      'continue',
      'throws',
      'protected',
      'public',
      'private',
      'module',
      'requires',
      'exports',
      'do',
      'sealed',
      'yield',
      'permits'
    ],
    literal: ['false', 'true', 'null'],
    type: [
      'char',
      'boolean',
      'long',
      'float',
      'int',
      'byte',
      'short',
      'double'
    ],
    built_in: ['super', 'this']
  }
  const d = {
    className: 'meta',
    begin: '@' + n,
    contains: [{ begin: /\(/, end: /\)/, contains: ['self'] }]
  }
  const f = {
    className: 'params',
    begin: /\(/,
    end: /\)/,
    keywords: u,
    relevance: 0,
    contains: [t.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  }
  return {
    name: 'Java',
    aliases: ['jsp'],
    keywords: u,
    illegal: /<\/|#/,
    contains: [
      t.COMMENT('/\\*\\*', '\\*/', {
        relevance: 0,
        contains: [
          { begin: /\w+@/, relevance: 0 },
          { className: 'doctag', begin: '@[A-Za-z]+' }
        ]
      }),
      {
        begin: /import java\.[a-z]+\./,
        keywords: 'import',
        relevance: 2
      },
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: 'string',
        contains: [t.BACKSLASH_ESCAPE]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: { 1: 'keyword', 3: 'title.class' }
      },
      { match: /non-sealed/, scope: 'keyword' },
      {
        begin: [e.concat(/(?!else)/, n), /\s+/, n, /\s+/, /=(?!=)/],
        className: { 1: 'type', 3: 'variable', 5: 'operator' }
      },
      {
        begin: [/record/, /\s+/, n],
        className: { 1: 'keyword', 3: 'title.class' },
        contains: [f, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE]
      },
      { beginKeywords: 'new throw return else', relevance: 0 },
      {
        begin: [
          '(?:' + r + '\\s+)',
          t.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: 'title.function' },
        keywords: u,
        contains: [
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            keywords: u,
            relevance: 0,
            contains: [
              d,
              t.APOS_STRING_MODE,
              t.QUOTE_STRING_MODE,
              s_,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      s_,
      d
    ]
  }
}
const c_ = '[A-Za-z$_][0-9A-Za-z$_]*'
const kF = [
  'as',
  'in',
  'of',
  'if',
  'for',
  'while',
  'finally',
  'var',
  'new',
  'function',
  'do',
  'return',
  'void',
  'else',
  'break',
  'catch',
  'instanceof',
  'with',
  'throw',
  'case',
  'default',
  'try',
  'switch',
  'continue',
  'typeof',
  'delete',
  'let',
  'yield',
  'const',
  'class',
  'debugger',
  'async',
  'await',
  'static',
  'import',
  'from',
  'export',
  'extends'
]
const OF = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity']
const u_ = [
  'Object',
  'Function',
  'Boolean',
  'Symbol',
  'Math',
  'Date',
  'Number',
  'BigInt',
  'String',
  'RegExp',
  'Array',
  'Float32Array',
  'Float64Array',
  'Int8Array',
  'Uint8Array',
  'Uint8ClampedArray',
  'Int16Array',
  'Int32Array',
  'Uint16Array',
  'Uint32Array',
  'BigInt64Array',
  'BigUint64Array',
  'Set',
  'Map',
  'WeakSet',
  'WeakMap',
  'ArrayBuffer',
  'SharedArrayBuffer',
  'Atomics',
  'DataView',
  'JSON',
  'Promise',
  'Generator',
  'GeneratorFunction',
  'AsyncFunction',
  'Reflect',
  'Proxy',
  'Intl',
  'WebAssembly'
]
const d_ = [
  'Error',
  'EvalError',
  'InternalError',
  'RangeError',
  'ReferenceError',
  'SyntaxError',
  'TypeError',
  'URIError'
]
const f_ = [
  'setInterval',
  'setTimeout',
  'clearInterval',
  'clearTimeout',
  'require',
  'exports',
  'eval',
  'isFinite',
  'isNaN',
  'parseFloat',
  'parseInt',
  'decodeURI',
  'decodeURIComponent',
  'encodeURI',
  'encodeURIComponent',
  'escape',
  'unescape'
]
const RF = [
  'arguments',
  'this',
  'super',
  'console',
  'window',
  'document',
  'localStorage',
  'sessionStorage',
  'module',
  'global'
]
const IF = [].concat(f_, u_, d_)
function p_ (t) {
  const e = t.regex
  const n = (D, { after: z }) => {
    const j = '</' + D[0].slice(1)
    return D.input.indexOf(j, z) !== -1
  }
  const r = c_
  const i = { begin: '<>', end: '</>' }
  const o = /<[A-Za-z0-9\\._:-]+\s*\/>/
  const s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    isTrulyOpeningTag: (D, z) => {
      const j = D[0].length + D.index
      const ie = D.input[j]
      if (ie === '<' || ie === ',') {
        z.ignoreMatch()
        return
      }
      ie === '>' && (n(D, { after: j }) || z.ignoreMatch())
      let xe
      const Ae = D.input.substring(j)
      if ((xe = Ae.match(/^\s*=/))) {
        z.ignoreMatch()
        return
      }
      if ((xe = Ae.match(/^\s+extends\s+/)) && xe.index === 0) {
        z.ignoreMatch()
      }
    }
  }
  const l = {
    $pattern: c_,
    keyword: kF,
    literal: OF,
    built_in: IF,
    'variable.language': RF
  }
  const u = '[0-9](_?[0-9])*'
  const d = `\\.(${u})`
  const f = '0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*'
  const h = {
    className: 'number',
    variants: [
      { begin: `(\\b(${f})((${d})|\\.)?|(${d}))[eE][+-]?(${u})\\b` },
      { begin: `\\b(${f})\\b((${d})\\b|\\.)?|(${d})\\b` },
      { begin: '\\b(0|[1-9](_?[0-9])*)n\\b' },
      { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b' },
      { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
      { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
      { begin: '\\b0[0-7]+n?\\b' }
    ],
    relevance: 0
  }
  const m = {
    className: 'subst',
    begin: '\\$\\{',
    end: '\\}',
    keywords: l,
    contains: []
  }
  const b = {
    begin: 'html`',
    end: '',
    starts: {
      end: '`',
      returnEnd: !1,
      contains: [t.BACKSLASH_ESCAPE, m],
      subLanguage: 'xml'
    }
  }
  const g = {
    begin: 'css`',
    end: '',
    starts: {
      end: '`',
      returnEnd: !1,
      contains: [t.BACKSLASH_ESCAPE, m],
      subLanguage: 'css'
    }
  }
  const E = {
    begin: 'gql`',
    end: '',
    starts: {
      end: '`',
      returnEnd: !1,
      contains: [t.BACKSLASH_ESCAPE, m],
      subLanguage: 'graphql'
    }
  }
  const w = {
    className: 'string',
    begin: '`',
    end: '`',
    contains: [t.BACKSLASH_ESCAPE, m]
  }
  const O = {
    className: 'comment',
    variants: [
      t.COMMENT(/\/\*\*(?!\/)/, '\\*/', {
        relevance: 0,
        contains: [
          {
            begin: '(?=@[A-Za-z]+)',
            relevance: 0,
            contains: [
              { className: 'doctag', begin: '@[A-Za-z]+' },
              {
                className: 'type',
                begin: '\\{',
                end: '\\}',
                excludeEnd: !0,
                excludeBegin: !0,
                relevance: 0
              },
              {
                className: 'variable',
                begin: r + '(?=\\s*(-)|$)',
                endsParent: !0,
                relevance: 0
              },
              { begin: /(?=[^\n])\s/, relevance: 0 }
            ]
          }
        ]
      }),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }
  const k = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    b,
    g,
    E,
    w,
    { match: /\$\d+/ },
    h
  ]
  m.contains = k.concat({
    begin: /\{/,
    end: /\}/,
    keywords: l,
    contains: ['self'].concat(k)
  })
  const T = [].concat(O, m.contains)
  const P = T.concat([
    {
      begin: /\(/,
      end: /\)/,
      keywords: l,
      contains: ['self'].concat(T)
    }
  ])
  const I = {
    className: 'params',
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: l,
    contains: P
  }
  const Y = {
    variants: [
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, '(', e.concat(/\./, r), ')*')
        ],
        scope: {
          1: 'keyword',
          3: 'title.class',
          5: 'keyword',
          7: 'title.class.inherited'
        }
      },
      {
        match: [/class/, /\s+/, r],
        scope: { 1: 'keyword', 3: 'title.class' }
      }
    ]
  }
  const ne = {
    relevance: 0,
    match: e.either(
      /\bJSON/,
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
    ),
    className: 'title.class',
    keywords: { _: [...u_, ...d_] }
  }
  const q = {
    label: 'use_strict',
    className: 'meta',
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }
  const Q = {
    variants: [
      { match: [/function/, /\s+/, r, /(?=\s*\()/] },
      { match: [/function/, /\s*(?=\()/] }
    ],
    className: { 1: 'keyword', 3: 'title.function' },
    label: 'func.def',
    contains: [I],
    illegal: /%/
  }
  const fe = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: 'variable.constant'
  }
  function we (D) {
    return e.concat('(?!', D.join('|'), ')')
  }
  const me = {
    match: e.concat(
      /\b/,
      we([...f_, 'super', 'import']),
      r,
      e.lookahead(/\(/)
    ),
    className: 'title.function',
    relevance: 0
  }
  const Ce = {
    begin: e.concat(/\./, e.lookahead(e.concat(r, /(?![0-9A-Za-z$_(])/))),
    end: r,
    excludeBegin: !0,
    keywords: 'prototype',
    className: 'property',
    relevance: 0
  }
  const ge = {
    match: [/get|set/, /\s+/, r, /(?=\()/],
    className: { 1: 'keyword', 3: 'title.function' },
    contains: [{ begin: /\(\)/ }, I]
  }
  const ye =
        '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' +
        t.UNDERSCORE_IDENT_RE +
        ')\\s*=>'
  const A = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      e.lookahead(ye)
    ],
    keywords: 'async',
    className: { 1: 'keyword', 3: 'title.function' },
    contains: [I]
  }
  return {
    name: 'JavaScript',
    aliases: ['js', 'jsx', 'mjs', 'cjs'],
    keywords: l,
    exports: { PARAMS_CONTAINS: P, CLASS_REFERENCE: ne },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({ label: 'shebang', binary: 'node', relevance: 5 }),
      q,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      b,
      g,
      E,
      w,
      O,
      { match: /\$\d+/ },
      h,
      ne,
      { className: 'attr', begin: r + e.lookahead(':'), relevance: 0 },
      A,
      {
        begin:
                    '(' + t.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
        keywords: 'return throw case',
        relevance: 0,
        contains: [
          O,
          t.REGEXP_MODE,
          {
            className: 'function',
            begin: ye,
            returnBegin: !0,
            end: '\\s*=>',
            contains: [
              {
                className: 'params',
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: l,
                    contains: P
                  }
                ]
              }
            ]
          },
          { begin: /,/, relevance: 0 },
          { match: /\s+/, relevance: 0 },
          {
            variants: [
              { begin: i.begin, end: i.end },
              { match: o },
              {
                begin: s.begin,
                'on:begin': s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: 'xml',
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ['self']
              }
            ]
          }
        ]
      },
      Q,
      { beginKeywords: 'while if switch catch for' },
      {
        begin:
                    '\\b(?!function)' +
                    t.UNDERSCORE_IDENT_RE +
                    '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
        returnBegin: !0,
        label: 'func.def',
        contains: [
          I,
          t.inherit(t.TITLE_MODE, {
            begin: r,
            className: 'title.function'
          })
        ]
      },
      { match: /\.\.\./, relevance: 0 },
      Ce,
      { match: '\\$' + r, relevance: 0 },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: 'title.function' },
        contains: [I]
      },
      me,
      fe,
      Y,
      ge,
      { match: /\$[(.]/ }
    ]
  }
}
function h_ (t) {
  const e = {
    className: 'attr',
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }
  const n = { match: /[{}[\],:]/, className: 'punctuation', relevance: 0 }
  const r = ['true', 'false', 'null']
  const i = { scope: 'literal', beginKeywords: r.join(' ') }
  return {
    name: 'JSON',
    keywords: { literal: r },
    contains: [
      e,
      n,
      t.QUOTE_STRING_MODE,
      i,
      t.C_NUMBER_MODE,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE
    ],
    illegal: '\\S'
  }
}
const ds = '[0-9](_*[0-9])*'
const _u = `\\.(${ds})`
const Su = '[0-9a-fA-F](_*[0-9a-fA-F])*'
const DF = {
  className: 'number',
  variants: [
    {
      begin: `(\\b(${ds})((${_u})|\\.)?|(${_u}))[eE][+-]?(${ds})[fFdD]?\\b`
    },
    { begin: `\\b(${ds})((${_u})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${_u})[fFdD]?\\b` },
    { begin: `\\b(${ds})[fFdD]\\b` },
    {
      begin: `\\b0[xX]((${Su})\\.?|(${Su})?\\.(${Su}))[pP][+-]?(${ds})[fFdD]?\\b`
    },
    { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
    { begin: `\\b0[xX](${Su})[lL]?\\b` },
    { begin: '\\b0(_*[0-7])*[lL]?\\b' },
    { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' }
  ],
  relevance: 0
}
function m_ (t) {
  const e = {
    keyword:
            'abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual',
    built_in:
            'Byte Short Char Int Long Boolean Float Double Void Unit Nothing',
    literal: 'true false null'
  }
  const n = {
    className: 'keyword',
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [{ className: 'symbol', begin: /@\w+/ }] }
  }
  const r = { className: 'symbol', begin: t.UNDERSCORE_IDENT_RE + '@' }
  const i = {
    className: 'subst',
    begin: /\$\{/,
    end: /\}/,
    contains: [t.C_NUMBER_MODE]
  }
  const o = { className: 'variable', begin: '\\$' + t.UNDERSCORE_IDENT_RE }
  const s = {
    className: 'string',
    variants: [
      { begin: '"""', end: '"""(?=[^"])', contains: [o, i] },
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [t.BACKSLASH_ESCAPE, o, i]
      }
    ]
  }
  i.contains.push(s)
  const l = {
    className: 'meta',
    begin:
            '@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*' +
            t.UNDERSCORE_IDENT_RE +
            ')?'
  }
  const u = {
    className: 'meta',
    begin: '@' + t.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [t.inherit(s, { className: 'string' }), 'self']
      }
    ]
  }
  const d = DF
  const f = t.COMMENT('/\\*', '\\*/', { contains: [t.C_BLOCK_COMMENT_MODE] })
  const h = {
    variants: [
      { className: 'type', begin: t.UNDERSCORE_IDENT_RE },
      { begin: /\(/, end: /\)/, contains: [] }
    ]
  }
  const m = h
  return (
    (m.variants[1].contains = [h]),
    (h.variants[1].contains = [m]),
    {
      name: 'Kotlin',
      aliases: ['kt', 'kts'],
      keywords: e,
      contains: [
        t.COMMENT('/\\*\\*', '\\*/', {
          relevance: 0,
          contains: [{ className: 'doctag', begin: '@[A-Za-z]+' }]
        }),
        t.C_LINE_COMMENT_MODE,
        f,
        n,
        r,
        l,
        u,
        {
          className: 'function',
          beginKeywords: 'fun',
          end: '[(]|$',
          returnBegin: !0,
          excludeEnd: !0,
          keywords: e,
          relevance: 5,
          contains: [
            {
              begin: t.UNDERSCORE_IDENT_RE + '\\s*\\(',
              returnBegin: !0,
              relevance: 0,
              contains: [t.UNDERSCORE_TITLE_MODE]
            },
            {
              className: 'type',
              begin: /</,
              end: />/,
              keywords: 'reified',
              relevance: 0
            },
            {
              className: 'params',
              begin: /\(/,
              end: /\)/,
              endsParent: !0,
              keywords: e,
              relevance: 0,
              contains: [
                {
                  begin: /:/,
                  end: /[=,\/]/,
                  endsWithParent: !0,
                  contains: [h, t.C_LINE_COMMENT_MODE, f],
                  relevance: 0
                },
                t.C_LINE_COMMENT_MODE,
                f,
                l,
                u,
                s,
                t.C_NUMBER_MODE
              ]
            },
            f
          ]
        },
        {
          begin: [
            /class|interface|trait/,
            /\s+/,
            t.UNDERSCORE_IDENT_RE
          ],
          beginScope: { 3: 'title.class' },
          keywords: 'class interface trait',
          end: /[:\{(]|$/,
          excludeEnd: !0,
          illegal: 'extends implements',
          contains: [
            {
              beginKeywords:
                                'public protected internal private constructor'
            },
            t.UNDERSCORE_TITLE_MODE,
            {
              className: 'type',
              begin: /</,
              end: />/,
              excludeBegin: !0,
              excludeEnd: !0,
              relevance: 0
            },
            {
              className: 'type',
              begin: /[,:]\s*/,
              end: /[<\(,){\s]|$/,
              excludeBegin: !0,
              returnEnd: !0
            },
            l,
            u
          ]
        },
        s,
        {
          className: 'meta',
          begin: '^#!/usr/bin/env',
          end: '$',
          illegal: `
`
        },
        d
      ]
    }
  )
}
const LF = (t) => ({
  IMPORTANT: { scope: 'meta', begin: '!important' },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: 'number',
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: 'selector-attr',
    begin: /\[/,
    end: /\]/,
    illegal: '$',
    contains: [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE]
  },
  CSS_NUMBER_MODE: {
    scope: 'number',
    begin:
            t.NUMBER_RE +
            '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
    relevance: 0
  },
  CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z][A-Za-z0-9_-]*/ }
})
const PF = [
  'a',
  'abbr',
  'address',
  'article',
  'aside',
  'audio',
  'b',
  'blockquote',
  'body',
  'button',
  'canvas',
  'caption',
  'cite',
  'code',
  'dd',
  'del',
  'details',
  'dfn',
  'div',
  'dl',
  'dt',
  'em',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'html',
  'i',
  'iframe',
  'img',
  'input',
  'ins',
  'kbd',
  'label',
  'legend',
  'li',
  'main',
  'mark',
  'menu',
  'nav',
  'object',
  'ol',
  'p',
  'q',
  'quote',
  'samp',
  'section',
  'span',
  'strong',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'thead',
  'time',
  'tr',
  'ul',
  'var',
  'video'
]
const BF = [
  'any-hover',
  'any-pointer',
  'aspect-ratio',
  'color',
  'color-gamut',
  'color-index',
  'device-aspect-ratio',
  'device-height',
  'device-width',
  'display-mode',
  'forced-colors',
  'grid',
  'height',
  'hover',
  'inverted-colors',
  'monochrome',
  'orientation',
  'overflow-block',
  'overflow-inline',
  'pointer',
  'prefers-color-scheme',
  'prefers-contrast',
  'prefers-reduced-motion',
  'prefers-reduced-transparency',
  'resolution',
  'scan',
  'scripting',
  'update',
  'width',
  'min-width',
  'max-width',
  'min-height',
  'max-height'
]
const g_ = [
  'active',
  'any-link',
  'blank',
  'checked',
  'current',
  'default',
  'defined',
  'dir',
  'disabled',
  'drop',
  'empty',
  'enabled',
  'first',
  'first-child',
  'first-of-type',
  'fullscreen',
  'future',
  'focus',
  'focus-visible',
  'focus-within',
  'has',
  'host',
  'host-context',
  'hover',
  'indeterminate',
  'in-range',
  'invalid',
  'is',
  'lang',
  'last-child',
  'last-of-type',
  'left',
  'link',
  'local-link',
  'not',
  'nth-child',
  'nth-col',
  'nth-last-child',
  'nth-last-col',
  'nth-last-of-type',
  'nth-of-type',
  'only-child',
  'only-of-type',
  'optional',
  'out-of-range',
  'past',
  'placeholder-shown',
  'read-only',
  'read-write',
  'required',
  'right',
  'root',
  'scope',
  'target',
  'target-within',
  'user-invalid',
  'valid',
  'visited',
  'where'
]
const b_ = [
  'after',
  'backdrop',
  'before',
  'cue',
  'cue-region',
  'first-letter',
  'first-line',
  'grammar-error',
  'marker',
  'part',
  'placeholder',
  'selection',
  'slotted',
  'spelling-error'
]
const FF = [
  'align-content',
  'align-items',
  'align-self',
  'all',
  'animation',
  'animation-delay',
  'animation-direction',
  'animation-duration',
  'animation-fill-mode',
  'animation-iteration-count',
  'animation-name',
  'animation-play-state',
  'animation-timing-function',
  'backface-visibility',
  'background',
  'background-attachment',
  'background-blend-mode',
  'background-clip',
  'background-color',
  'background-image',
  'background-origin',
  'background-position',
  'background-repeat',
  'background-size',
  'block-size',
  'border',
  'border-block',
  'border-block-color',
  'border-block-end',
  'border-block-end-color',
  'border-block-end-style',
  'border-block-end-width',
  'border-block-start',
  'border-block-start-color',
  'border-block-start-style',
  'border-block-start-width',
  'border-block-style',
  'border-block-width',
  'border-bottom',
  'border-bottom-color',
  'border-bottom-left-radius',
  'border-bottom-right-radius',
  'border-bottom-style',
  'border-bottom-width',
  'border-collapse',
  'border-color',
  'border-image',
  'border-image-outset',
  'border-image-repeat',
  'border-image-slice',
  'border-image-source',
  'border-image-width',
  'border-inline',
  'border-inline-color',
  'border-inline-end',
  'border-inline-end-color',
  'border-inline-end-style',
  'border-inline-end-width',
  'border-inline-start',
  'border-inline-start-color',
  'border-inline-start-style',
  'border-inline-start-width',
  'border-inline-style',
  'border-inline-width',
  'border-left',
  'border-left-color',
  'border-left-style',
  'border-left-width',
  'border-radius',
  'border-right',
  'border-right-color',
  'border-right-style',
  'border-right-width',
  'border-spacing',
  'border-style',
  'border-top',
  'border-top-color',
  'border-top-left-radius',
  'border-top-right-radius',
  'border-top-style',
  'border-top-width',
  'border-width',
  'bottom',
  'box-decoration-break',
  'box-shadow',
  'box-sizing',
  'break-after',
  'break-before',
  'break-inside',
  'caption-side',
  'caret-color',
  'clear',
  'clip',
  'clip-path',
  'clip-rule',
  'color',
  'column-count',
  'column-fill',
  'column-gap',
  'column-rule',
  'column-rule-color',
  'column-rule-style',
  'column-rule-width',
  'column-span',
  'column-width',
  'columns',
  'contain',
  'content',
  'content-visibility',
  'counter-increment',
  'counter-reset',
  'cue',
  'cue-after',
  'cue-before',
  'cursor',
  'direction',
  'display',
  'empty-cells',
  'filter',
  'flex',
  'flex-basis',
  'flex-direction',
  'flex-flow',
  'flex-grow',
  'flex-shrink',
  'flex-wrap',
  'float',
  'flow',
  'font',
  'font-display',
  'font-family',
  'font-feature-settings',
  'font-kerning',
  'font-language-override',
  'font-size',
  'font-size-adjust',
  'font-smoothing',
  'font-stretch',
  'font-style',
  'font-synthesis',
  'font-variant',
  'font-variant-caps',
  'font-variant-east-asian',
  'font-variant-ligatures',
  'font-variant-numeric',
  'font-variant-position',
  'font-variation-settings',
  'font-weight',
  'gap',
  'glyph-orientation-vertical',
  'grid',
  'grid-area',
  'grid-auto-columns',
  'grid-auto-flow',
  'grid-auto-rows',
  'grid-column',
  'grid-column-end',
  'grid-column-start',
  'grid-gap',
  'grid-row',
  'grid-row-end',
  'grid-row-start',
  'grid-template',
  'grid-template-areas',
  'grid-template-columns',
  'grid-template-rows',
  'hanging-punctuation',
  'height',
  'hyphens',
  'icon',
  'image-orientation',
  'image-rendering',
  'image-resolution',
  'ime-mode',
  'inline-size',
  'isolation',
  'justify-content',
  'left',
  'letter-spacing',
  'line-break',
  'line-height',
  'list-style',
  'list-style-image',
  'list-style-position',
  'list-style-type',
  'margin',
  'margin-block',
  'margin-block-end',
  'margin-block-start',
  'margin-bottom',
  'margin-inline',
  'margin-inline-end',
  'margin-inline-start',
  'margin-left',
  'margin-right',
  'margin-top',
  'marks',
  'mask',
  'mask-border',
  'mask-border-mode',
  'mask-border-outset',
  'mask-border-repeat',
  'mask-border-slice',
  'mask-border-source',
  'mask-border-width',
  'mask-clip',
  'mask-composite',
  'mask-image',
  'mask-mode',
  'mask-origin',
  'mask-position',
  'mask-repeat',
  'mask-size',
  'mask-type',
  'max-block-size',
  'max-height',
  'max-inline-size',
  'max-width',
  'min-block-size',
  'min-height',
  'min-inline-size',
  'min-width',
  'mix-blend-mode',
  'nav-down',
  'nav-index',
  'nav-left',
  'nav-right',
  'nav-up',
  'none',
  'normal',
  'object-fit',
  'object-position',
  'opacity',
  'order',
  'orphans',
  'outline',
  'outline-color',
  'outline-offset',
  'outline-style',
  'outline-width',
  'overflow',
  'overflow-wrap',
  'overflow-x',
  'overflow-y',
  'padding',
  'padding-block',
  'padding-block-end',
  'padding-block-start',
  'padding-bottom',
  'padding-inline',
  'padding-inline-end',
  'padding-inline-start',
  'padding-left',
  'padding-right',
  'padding-top',
  'page-break-after',
  'page-break-before',
  'page-break-inside',
  'pause',
  'pause-after',
  'pause-before',
  'perspective',
  'perspective-origin',
  'pointer-events',
  'position',
  'quotes',
  'resize',
  'rest',
  'rest-after',
  'rest-before',
  'right',
  'row-gap',
  'scroll-margin',
  'scroll-margin-block',
  'scroll-margin-block-end',
  'scroll-margin-block-start',
  'scroll-margin-bottom',
  'scroll-margin-inline',
  'scroll-margin-inline-end',
  'scroll-margin-inline-start',
  'scroll-margin-left',
  'scroll-margin-right',
  'scroll-margin-top',
  'scroll-padding',
  'scroll-padding-block',
  'scroll-padding-block-end',
  'scroll-padding-block-start',
  'scroll-padding-bottom',
  'scroll-padding-inline',
  'scroll-padding-inline-end',
  'scroll-padding-inline-start',
  'scroll-padding-left',
  'scroll-padding-right',
  'scroll-padding-top',
  'scroll-snap-align',
  'scroll-snap-stop',
  'scroll-snap-type',
  'scrollbar-color',
  'scrollbar-gutter',
  'scrollbar-width',
  'shape-image-threshold',
  'shape-margin',
  'shape-outside',
  'speak',
  'speak-as',
  'src',
  'tab-size',
  'table-layout',
  'text-align',
  'text-align-all',
  'text-align-last',
  'text-combine-upright',
  'text-decoration',
  'text-decoration-color',
  'text-decoration-line',
  'text-decoration-style',
  'text-emphasis',
  'text-emphasis-color',
  'text-emphasis-position',
  'text-emphasis-style',
  'text-indent',
  'text-justify',
  'text-orientation',
  'text-overflow',
  'text-rendering',
  'text-shadow',
  'text-transform',
  'text-underline-position',
  'top',
  'transform',
  'transform-box',
  'transform-origin',
  'transform-style',
  'transition',
  'transition-delay',
  'transition-duration',
  'transition-property',
  'transition-timing-function',
  'unicode-bidi',
  'vertical-align',
  'visibility',
  'voice-balance',
  'voice-duration',
  'voice-family',
  'voice-pitch',
  'voice-range',
  'voice-rate',
  'voice-stress',
  'voice-volume',
  'white-space',
  'widows',
  'width',
  'will-change',
  'word-break',
  'word-spacing',
  'word-wrap',
  'writing-mode',
  'z-index'
].reverse()
const HF = g_.concat(b_)
function y_ (t) {
  const e = LF(t)
  const n = HF
  const r = 'and or not only'
  const i = '[\\w-]+'
  const o = '(' + i + '|@\\{' + i + '\\})'
  const s = []
  const l = []
  const u = function (k) {
    return { className: 'string', begin: '~?' + k + '.*?' + k }
  }
  const d = function (k, T, P) {
    return { className: k, begin: T, relevance: P }
  }
  const f = { $pattern: /[a-z-]+/, keyword: r, attribute: BF.join(' ') }
  const h = {
    begin: '\\(',
    end: '\\)',
    contains: l,
    keywords: f,
    relevance: 0
  }
  l.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    u("'"),
    u('"'),
    e.CSS_NUMBER_MODE,
    {
      begin: '(url|data-uri)\\(',
      starts: { className: 'string', end: '[\\)\\n]', excludeEnd: !0 }
    },
    e.HEXCOLOR,
    h,
    d('variable', '@@?' + i, 10),
    d('variable', '@\\{' + i + '\\}'),
    d('built_in', '~?`[^`]*?`'),
    {
      className: 'attribute',
      begin: i + '\\s*:',
      end: ':',
      returnBegin: !0,
      excludeEnd: !0
    },
    e.IMPORTANT,
    { beginKeywords: 'and not' },
    e.FUNCTION_DISPATCH
  )
  const m = l.concat({ begin: /\{/, end: /\}/, contains: s })
  const b = {
    beginKeywords: 'when',
    endsWithParent: !0,
    contains: [{ beginKeywords: 'and not' }].concat(l)
  }
  const g = {
    begin: o + '\\s*:',
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      e.CSS_VARIABLE,
      {
        className: 'attribute',
        begin: '\\b(' + FF.join('|') + ')\\b',
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: '[<=$]',
          relevance: 0,
          contains: l
        }
      }
    ]
  }
  const E = {
    className: 'keyword',
    begin: '@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b',
    starts: {
      end: '[;{}]',
      keywords: f,
      returnEnd: !0,
      contains: l,
      relevance: 0
    }
  }
  const w = {
    className: 'variable',
    variants: [
      { begin: '@' + i + '\\s*:', relevance: 15 },
      { begin: '@' + i }
    ],
    starts: { end: '[;}]', returnEnd: !0, contains: m }
  }
  const S = {
    variants: [
      { begin: '[\\.#:&\\[>]', end: '[;{}]' },
      { begin: o, end: /\{/ }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: "[<='$\"]",
    relevance: 0,
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      b,
      d('keyword', 'all\\b'),
      d('variable', '@\\{' + i + '\\}'),
      {
        begin: '\\b(' + PF.join('|') + ')\\b',
        className: 'selector-tag'
      },
      e.CSS_NUMBER_MODE,
      d('selector-tag', o, 0),
      d('selector-id', '#' + o),
      d('selector-class', '\\.' + o, 0),
      d('selector-tag', '&', 0),
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: 'selector-pseudo',
        begin: ':(' + g_.join('|') + ')'
      },
      {
        className: 'selector-pseudo',
        begin: ':(:)?(' + b_.join('|') + ')'
      },
      { begin: /\(/, end: /\)/, relevance: 0, contains: m },
      { begin: '!important' },
      e.FUNCTION_DISPATCH
    ]
  }
  const O = {
    begin: i + `:(:)?(${n.join('|')})`,
    returnBegin: !0,
    contains: [S]
  }
  return (
    s.push(
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      E,
      w,
      O,
      g,
      S,
      b,
      e.FUNCTION_DISPATCH
    ),
    {
      name: 'Less',
      case_insensitive: !0,
      illegal: "[=>'/<($\"]",
      contains: s
    }
  )
}
function E_ (t) {
  const e = '\\[=*\\['
  const n = '\\]=*\\]'
  const r = { begin: e, end: n, contains: ['self'] }
  const i = [
    t.COMMENT('--(?!' + e + ')', '$'),
    t.COMMENT('--' + e, n, { contains: [r], relevance: 10 })
  ]
  return {
    name: 'Lua',
    keywords: {
      $pattern: t.UNDERSCORE_IDENT_RE,
      literal: 'true false nil',
      keyword:
                'and break do else elseif end for goto if in local not or repeat return then until while',
      built_in:
                '_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove'
    },
    contains: i.concat([
      {
        className: 'function',
        beginKeywords: 'function',
        end: '\\)',
        contains: [
          t.inherit(t.TITLE_MODE, {
            begin: '([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*'
          }),
          {
            className: 'params',
            begin: '\\(',
            endsWithParent: !0,
            contains: i
          }
        ].concat(i)
      },
      t.C_NUMBER_MODE,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        className: 'string',
        begin: e,
        end: n,
        contains: [r],
        relevance: 5
      }
    ])
  }
}
function v_ (t) {
  const e = {
    className: 'variable',
    variants: [
      {
        begin: '\\$\\(' + t.UNDERSCORE_IDENT_RE + '\\)',
        contains: [t.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }
  const n = {
    className: 'string',
    begin: /"/,
    end: /"/,
    contains: [t.BACKSLASH_ESCAPE, e]
  }
  const r = {
    className: 'variable',
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: {
      built_in:
                'subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value'
    },
    contains: [e]
  }
  const i = { begin: '^' + t.UNDERSCORE_IDENT_RE + '\\s*(?=[:+?]?=)' }
  const o = {
    className: 'meta',
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: { $pattern: /[\.\w]+/, keyword: '.PHONY' }
  }
  const s = {
    className: 'section',
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [e]
  }
  return {
    name: 'Makefile',
    aliases: ['mk', 'mak', 'make'],
    keywords: {
      $pattern: /[\w-]+/,
      keyword:
                'define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath'
    },
    contains: [t.HASH_COMMENT_MODE, e, n, r, i, o, s]
  }
}
function w_ (t) {
  const e = t.regex
  const n = {
    begin: /<\/?[A-Za-z_]/,
    end: '>',
    subLanguage: 'xml',
    relevance: 0
  }
  const r = { begin: '^[-\\*]{3,}', end: '$' }
  const i = {
    className: 'code',
    variants: [
      { begin: '(`{3,})[^`](.|\\n)*?\\1`*[ ]*' },
      { begin: '(~{3,})[^~](.|\\n)*?\\1~*[ ]*' },
      { begin: '```', end: '```+[ ]*$' },
      { begin: '~~~', end: '~~~+[ ]*$' },
      { begin: '`.+?`' },
      {
        begin: '(?=^( {4}|\\t))',
        contains: [{ begin: '^( {4}|\\t)', end: '(\\n)$' }],
        relevance: 0
      }
    ]
  }
  const o = {
    className: 'bullet',
    begin: '^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)',
    end: '\\s+',
    excludeEnd: !0
  }
  const s = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: 'symbol',
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: 'link',
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }
  const l = /[A-Za-z][A-Za-z0-9+.-]*/
  const u = {
    variants: [
      { begin: /\[.+?\]\[.*?\]/, relevance: 0 },
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      { begin: e.concat(/\[.+?\]\(/, l, /:\/\/.*?\)/), relevance: 2 },
      { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
      { begin: /\[.*?\]\(.*?\)/, relevance: 0 }
    ],
    returnBegin: !0,
    contains: [
      { match: /\[(?=\])/ },
      {
        className: 'string',
        relevance: 0,
        begin: '\\[',
        end: '\\]',
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: 'link',
        relevance: 0,
        begin: '\\]\\(',
        end: '\\)',
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: 'symbol',
        relevance: 0,
        begin: '\\]\\[',
        end: '\\]',
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }
  const d = {
    className: 'strong',
    contains: [],
    variants: [
      { begin: /_{2}(?!\s)/, end: /_{2}/ },
      { begin: /\*{2}(?!\s)/, end: /\*{2}/ }
    ]
  }
  const f = {
    className: 'emphasis',
    contains: [],
    variants: [
      { begin: /\*(?![*\s])/, end: /\*/ },
      { begin: /_(?![_\s])/, end: /_/, relevance: 0 }
    ]
  }
  const h = t.inherit(d, { contains: [] })
  const m = t.inherit(f, { contains: [] })
  d.contains.push(m), f.contains.push(h)
  let b = [n, u]
  return (
    [d, f, h, m].forEach((w) => {
      w.contains = w.contains.concat(b)
    }),
    (b = b.concat(d, f)),
    {
      name: 'Markdown',
      aliases: ['md', 'mkdown', 'mkd'],
      contains: [
        {
          className: 'section',
          variants: [
            { begin: '^#{1,6}', end: '$', contains: b },
            {
              begin: '(?=^.+?\\n[=-]{2,}$)',
              contains: [
                { begin: '^[=-]*$' },
                { begin: '^', end: '\\n', contains: b }
              ]
            }
          ]
        },
        n,
        o,
        d,
        f,
        { className: 'quote', begin: '^>\\s+', contains: b, end: '$' },
        i,
        r,
        u,
        s
      ]
    }
  )
}
function x_ (t) {
  const e = {
    className: 'built_in',
    begin: '\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+'
  }
  const n = /[a-zA-Z@][a-zA-Z0-9_]*/
  const l = {
    'variable.language': ['this', 'super'],
    $pattern: n,
    keyword: [
      'while',
      'export',
      'sizeof',
      'typedef',
      'const',
      'struct',
      'for',
      'union',
      'volatile',
      'static',
      'mutable',
      'if',
      'do',
      'return',
      'goto',
      'enum',
      'else',
      'break',
      'extern',
      'asm',
      'case',
      'default',
      'register',
      'explicit',
      'typename',
      'switch',
      'continue',
      'inline',
      'readonly',
      'assign',
      'readwrite',
      'self',
      '@synchronized',
      'id',
      'typeof',
      'nonatomic',
      'IBOutlet',
      'IBAction',
      'strong',
      'weak',
      'copy',
      'in',
      'out',
      'inout',
      'bycopy',
      'byref',
      'oneway',
      '__strong',
      '__weak',
      '__block',
      '__autoreleasing',
      '@private',
      '@protected',
      '@public',
      '@try',
      '@property',
      '@end',
      '@throw',
      '@catch',
      '@finally',
      '@autoreleasepool',
      '@synthesize',
      '@dynamic',
      '@selector',
      '@optional',
      '@required',
      '@encode',
      '@package',
      '@import',
      '@defs',
      '@compatibility_alias',
      '__bridge',
      '__bridge_transfer',
      '__bridge_retained',
      '__bridge_retain',
      '__covariant',
      '__contravariant',
      '__kindof',
      '_Nonnull',
      '_Nullable',
      '_Null_unspecified',
      '__FUNCTION__',
      '__PRETTY_FUNCTION__',
      '__attribute__',
      'getter',
      'setter',
      'retain',
      'unsafe_unretained',
      'nonnull',
      'nullable',
      'null_unspecified',
      'null_resettable',
      'class',
      'instancetype',
      'NS_DESIGNATED_INITIALIZER',
      'NS_UNAVAILABLE',
      'NS_REQUIRES_SUPER',
      'NS_RETURNS_INNER_POINTER',
      'NS_INLINE',
      'NS_AVAILABLE',
      'NS_DEPRECATED',
      'NS_ENUM',
      'NS_OPTIONS',
      'NS_SWIFT_UNAVAILABLE',
      'NS_ASSUME_NONNULL_BEGIN',
      'NS_ASSUME_NONNULL_END',
      'NS_REFINED_FOR_SWIFT',
      'NS_SWIFT_NAME',
      'NS_SWIFT_NOTHROW',
      'NS_DURING',
      'NS_HANDLER',
      'NS_ENDHANDLER',
      'NS_VALUERETURN',
      'NS_VOIDRETURN'
    ],
    literal: ['false', 'true', 'FALSE', 'TRUE', 'nil', 'YES', 'NO', 'NULL'],
    built_in: [
      'dispatch_once_t',
      'dispatch_queue_t',
      'dispatch_sync',
      'dispatch_async',
      'dispatch_once'
    ],
    type: [
      'int',
      'float',
      'char',
      'unsigned',
      'signed',
      'short',
      'long',
      'double',
      'wchar_t',
      'unichar',
      'void',
      'bool',
      'BOOL',
      'id|0',
      '_Bool'
    ]
  }
  const u = {
    $pattern: n,
    keyword: ['@interface', '@class', '@protocol', '@implementation']
  }
  return {
    name: 'Objective-C',
    aliases: ['mm', 'objc', 'obj-c', 'obj-c++', 'objective-c++'],
    keywords: l,
    illegal: '</',
    contains: [
      e,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      t.C_NUMBER_MODE,
      t.QUOTE_STRING_MODE,
      t.APOS_STRING_MODE,
      {
        className: 'string',
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: '\\n',
            contains: [t.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: 'meta',
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: {
          keyword:
                        'if else elif endif define undef warning error line pragma ifdef ifndef include'
        },
        contains: [
          { begin: /\\\n/, relevance: 0 },
          t.inherit(t.QUOTE_STRING_MODE, { className: 'string' }),
          {
            className: 'string',
            begin: /<.*?>/,
            end: /$/,
            illegal: '\\n'
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: 'class',
        begin: '(' + u.keyword.join('|') + ')\\b',
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: u,
        contains: [t.UNDERSCORE_TITLE_MODE]
      },
      { begin: '\\.' + t.UNDERSCORE_IDENT_RE, relevance: 0 }
    ]
  }
}
function __ (t) {
  const e = t.regex
  const n = [
    'abs',
    'accept',
    'alarm',
    'and',
    'atan2',
    'bind',
    'binmode',
    'bless',
    'break',
    'caller',
    'chdir',
    'chmod',
    'chomp',
    'chop',
    'chown',
    'chr',
    'chroot',
    'close',
    'closedir',
    'connect',
    'continue',
    'cos',
    'crypt',
    'dbmclose',
    'dbmopen',
    'defined',
    'delete',
    'die',
    'do',
    'dump',
    'each',
    'else',
    'elsif',
    'endgrent',
    'endhostent',
    'endnetent',
    'endprotoent',
    'endpwent',
    'endservent',
    'eof',
    'eval',
    'exec',
    'exists',
    'exit',
    'exp',
    'fcntl',
    'fileno',
    'flock',
    'for',
    'foreach',
    'fork',
    'format',
    'formline',
    'getc',
    'getgrent',
    'getgrgid',
    'getgrnam',
    'gethostbyaddr',
    'gethostbyname',
    'gethostent',
    'getlogin',
    'getnetbyaddr',
    'getnetbyname',
    'getnetent',
    'getpeername',
    'getpgrp',
    'getpriority',
    'getprotobyname',
    'getprotobynumber',
    'getprotoent',
    'getpwent',
    'getpwnam',
    'getpwuid',
    'getservbyname',
    'getservbyport',
    'getservent',
    'getsockname',
    'getsockopt',
    'given',
    'glob',
    'gmtime',
    'goto',
    'grep',
    'gt',
    'hex',
    'if',
    'index',
    'int',
    'ioctl',
    'join',
    'keys',
    'kill',
    'last',
    'lc',
    'lcfirst',
    'length',
    'link',
    'listen',
    'local',
    'localtime',
    'log',
    'lstat',
    'lt',
    'ma',
    'map',
    'mkdir',
    'msgctl',
    'msgget',
    'msgrcv',
    'msgsnd',
    'my',
    'ne',
    'next',
    'no',
    'not',
    'oct',
    'open',
    'opendir',
    'or',
    'ord',
    'our',
    'pack',
    'package',
    'pipe',
    'pop',
    'pos',
    'print',
    'printf',
    'prototype',
    'push',
    'q|0',
    'qq',
    'quotemeta',
    'qw',
    'qx',
    'rand',
    'read',
    'readdir',
    'readline',
    'readlink',
    'readpipe',
    'recv',
    'redo',
    'ref',
    'rename',
    'require',
    'reset',
    'return',
    'reverse',
    'rewinddir',
    'rindex',
    'rmdir',
    'say',
    'scalar',
    'seek',
    'seekdir',
    'select',
    'semctl',
    'semget',
    'semop',
    'send',
    'setgrent',
    'sethostent',
    'setnetent',
    'setpgrp',
    'setpriority',
    'setprotoent',
    'setpwent',
    'setservent',
    'setsockopt',
    'shift',
    'shmctl',
    'shmget',
    'shmread',
    'shmwrite',
    'shutdown',
    'sin',
    'sleep',
    'socket',
    'socketpair',
    'sort',
    'splice',
    'split',
    'sprintf',
    'sqrt',
    'srand',
    'stat',
    'state',
    'study',
    'sub',
    'substr',
    'symlink',
    'syscall',
    'sysopen',
    'sysread',
    'sysseek',
    'system',
    'syswrite',
    'tell',
    'telldir',
    'tie',
    'tied',
    'time',
    'times',
    'tr',
    'truncate',
    'uc',
    'ucfirst',
    'umask',
    'undef',
    'unless',
    'unlink',
    'unpack',
    'unshift',
    'untie',
    'until',
    'use',
    'utime',
    'values',
    'vec',
    'wait',
    'waitpid',
    'wantarray',
    'warn',
    'when',
    'while',
    'write',
    'x|0',
    'xor',
    'y|0'
  ]
  const r = /[dualxmsipngr]{0,12}/
  const i = { $pattern: /[\w.]+/, keyword: n.join(' ') }
  const o = { className: 'subst', begin: '[$@]\\{', end: '\\}', keywords: i }
  const s = { begin: /->\{/, end: /\}/ }
  const l = {
    variants: [
      { begin: /\$\d/ },
      {
        begin: e.concat(
          /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
          '(?![A-Za-z])(?![@$%])'
        )
      },
      { begin: /[$%@][^\s\w{]/, relevance: 0 }
    ]
  }
  const u = [t.BACKSLASH_ESCAPE, o, l]
  const d = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/]
  const f = (b, g, E = '\\1') => {
    const w = E === '\\1' ? E : e.concat(E, g)
    return e.concat(
      e.concat('(?:', b, ')'),
      g,
      /(?:\\.|[^\\\/])*?/,
      w,
      /(?:\\.|[^\\\/])*?/,
      E,
      r
    )
  }
  const h = (b, g, E) =>
    e.concat(e.concat('(?:', b, ')'), g, /(?:\\.|[^\\\/])*?/, E, r)
  const m = [
    l,
    t.HASH_COMMENT_MODE,
    t.COMMENT(/^=\w/, /=cut/, { endsWithParent: !0 }),
    s,
    {
      className: 'string',
      contains: u,
      variants: [
        { begin: 'q[qwxr]?\\s*\\(', end: '\\)', relevance: 5 },
        { begin: 'q[qwxr]?\\s*\\[', end: '\\]', relevance: 5 },
        { begin: 'q[qwxr]?\\s*\\{', end: '\\}', relevance: 5 },
        { begin: 'q[qwxr]?\\s*\\|', end: '\\|', relevance: 5 },
        { begin: 'q[qwxr]?\\s*<', end: '>', relevance: 5 },
        { begin: 'qw\\s+q', end: 'q', relevance: 5 },
        { begin: "'", end: "'", contains: [t.BACKSLASH_ESCAPE] },
        { begin: '"', end: '"' },
        { begin: '`', end: '`', contains: [t.BACKSLASH_ESCAPE] },
        { begin: /\{\w+\}/, relevance: 0 },
        { begin: '-?\\w+\\s*=>', relevance: 0 }
      ]
    },
    {
      className: 'number',
      begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
      relevance: 0
    },
    {
      begin:
                '(\\/\\/|' +
                t.RE_STARTERS_RE +
                '|\\b(split|return|print|reverse|grep)\\b)\\s*',
      keywords: 'split return print reverse grep',
      relevance: 0,
      contains: [
        t.HASH_COMMENT_MODE,
        {
          className: 'regexp',
          variants: [
            {
              begin: f('s|tr|y', e.either(...d, { capture: !0 }))
            },
            { begin: f('s|tr|y', '\\(', '\\)') },
            { begin: f('s|tr|y', '\\[', '\\]') },
            { begin: f('s|tr|y', '\\{', '\\}') }
          ],
          relevance: 2
        },
        {
          className: 'regexp',
          variants: [
            { begin: /(m|qr)\/\//, relevance: 0 },
            { begin: h('(?:m|qr)?', /\//, /\//) },
            {
              begin: h(
                'm|qr',
                e.either(...d, { capture: !0 }),
                /\1/
              )
            },
            { begin: h('m|qr', /\(/, /\)/) },
            { begin: h('m|qr', /\[/, /\]/) },
            { begin: h('m|qr', /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: 'function',
      beginKeywords: 'sub',
      end: '(\\s*\\(.*?\\))?[;{]',
      excludeEnd: !0,
      relevance: 5,
      contains: [t.TITLE_MODE]
    },
    { begin: '-\\w\\b', relevance: 0 },
    {
      begin: '^__DATA__$',
      end: '^__END__$',
      subLanguage: 'mojolicious',
      contains: [{ begin: '^@@.*', end: '$', className: 'comment' }]
    }
  ]
  return (
    (o.contains = m),
    (s.contains = m),
    { name: 'Perl', aliases: ['pl', 'pm'], keywords: i, contains: m }
  )
}
function S_ (t) {
  const e = t.regex
  const n = /(?![A-Za-z0-9])(?![$])/
  const r = e.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, n)
  const i = e.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  )
  const o = { scope: 'variable', match: '\\$+' + r }
  const s = {
    scope: 'meta',
    variants: [
      { begin: /<\?php/, relevance: 10 },
      { begin: /<\?=/ },
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
    ]
  }
  const l = {
    scope: 'subst',
    variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }]
  }
  const u = t.inherit(t.APOS_STRING_MODE, { illegal: null })
  const d = t.inherit(t.QUOTE_STRING_MODE, {
    illegal: null,
    contains: t.QUOTE_STRING_MODE.contains.concat(l)
  })
  const f = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: t.QUOTE_STRING_MODE.contains.concat(l),
    'on:begin': (me, Ce) => {
      Ce.data._beginMatch = me[1] || me[2]
    },
    'on:end': (me, Ce) => {
      Ce.data._beginMatch !== me[1] && Ce.ignoreMatch()
    }
  }
  const h = t.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  })
  const m = `[ 	
]`
  const b = { scope: 'string', variants: [d, u, f, h] }
  const g = {
    scope: 'number',
    variants: [
      { begin: '\\b0[bB][01]+(?:_[01]+)*\\b' },
      { begin: '\\b0[oO][0-7]+(?:_[0-7]+)*\\b' },
      { begin: '\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b' },
      {
        begin: '(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?'
      }
    ],
    relevance: 0
  }
  const E = ['false', 'null', 'true']
  const w = [
    '__CLASS__',
    '__DIR__',
    '__FILE__',
    '__FUNCTION__',
    '__COMPILER_HALT_OFFSET__',
    '__LINE__',
    '__METHOD__',
    '__NAMESPACE__',
    '__TRAIT__',
    'die',
    'echo',
    'exit',
    'include',
    'include_once',
    'print',
    'require',
    'require_once',
    'array',
    'abstract',
    'and',
    'as',
    'binary',
    'bool',
    'boolean',
    'break',
    'callable',
    'case',
    'catch',
    'class',
    'clone',
    'const',
    'continue',
    'declare',
    'default',
    'do',
    'double',
    'else',
    'elseif',
    'empty',
    'enddeclare',
    'endfor',
    'endforeach',
    'endif',
    'endswitch',
    'endwhile',
    'enum',
    'eval',
    'extends',
    'final',
    'finally',
    'float',
    'for',
    'foreach',
    'from',
    'global',
    'goto',
    'if',
    'implements',
    'instanceof',
    'insteadof',
    'int',
    'integer',
    'interface',
    'isset',
    'iterable',
    'list',
    'match|0',
    'mixed',
    'new',
    'never',
    'object',
    'or',
    'private',
    'protected',
    'public',
    'readonly',
    'real',
    'return',
    'string',
    'switch',
    'throw',
    'trait',
    'try',
    'unset',
    'use',
    'var',
    'void',
    'while',
    'xor',
    'yield'
  ]
  const S = [
    'Error|0',
    'AppendIterator',
    'ArgumentCountError',
    'ArithmeticError',
    'ArrayIterator',
    'ArrayObject',
    'AssertionError',
    'BadFunctionCallException',
    'BadMethodCallException',
    'CachingIterator',
    'CallbackFilterIterator',
    'CompileError',
    'Countable',
    'DirectoryIterator',
    'DivisionByZeroError',
    'DomainException',
    'EmptyIterator',
    'ErrorException',
    'Exception',
    'FilesystemIterator',
    'FilterIterator',
    'GlobIterator',
    'InfiniteIterator',
    'InvalidArgumentException',
    'IteratorIterator',
    'LengthException',
    'LimitIterator',
    'LogicException',
    'MultipleIterator',
    'NoRewindIterator',
    'OutOfBoundsException',
    'OutOfRangeException',
    'OuterIterator',
    'OverflowException',
    'ParentIterator',
    'ParseError',
    'RangeException',
    'RecursiveArrayIterator',
    'RecursiveCachingIterator',
    'RecursiveCallbackFilterIterator',
    'RecursiveDirectoryIterator',
    'RecursiveFilterIterator',
    'RecursiveIterator',
    'RecursiveIteratorIterator',
    'RecursiveRegexIterator',
    'RecursiveTreeIterator',
    'RegexIterator',
    'RuntimeException',
    'SeekableIterator',
    'SplDoublyLinkedList',
    'SplFileInfo',
    'SplFileObject',
    'SplFixedArray',
    'SplHeap',
    'SplMaxHeap',
    'SplMinHeap',
    'SplObjectStorage',
    'SplObserver',
    'SplPriorityQueue',
    'SplQueue',
    'SplStack',
    'SplSubject',
    'SplTempFileObject',
    'TypeError',
    'UnderflowException',
    'UnexpectedValueException',
    'UnhandledMatchError',
    'ArrayAccess',
    'BackedEnum',
    'Closure',
    'Fiber',
    'Generator',
    'Iterator',
    'IteratorAggregate',
    'Serializable',
    'Stringable',
    'Throwable',
    'Traversable',
    'UnitEnum',
    'WeakReference',
    'WeakMap',
    'Directory',
    '__PHP_Incomplete_Class',
    'parent',
    'php_user_filter',
    'self',
    'static',
    'stdClass'
  ]
  const k = {
    keyword: w,
    literal: ((me) => {
      const Ce = []
      return (
        me.forEach((ge) => {
          Ce.push(ge),
          ge.toLowerCase() === ge
            ? Ce.push(ge.toUpperCase())
            : Ce.push(ge.toLowerCase())
        }),
        Ce
      )
    })(E),
    built_in: S
  }
  const T = (me) => me.map((Ce) => Ce.replace(/\|\d+$/, ''))
  const P = {
    variants: [
      {
        match: [
          /new/,
          e.concat(m, '+'),
          e.concat('(?!', T(S).join('\\b|'), '\\b)'),
          i
        ],
        scope: { 1: 'keyword', 4: 'title.class' }
      }
    ]
  }
  const I = e.concat(r, '\\b(?!\\()')
  const Y = {
    variants: [
      {
        match: [e.concat(/::/, e.lookahead(/(?!class\b)/)), I],
        scope: { 2: 'variable.constant' }
      },
      { match: [/::/, /class/], scope: { 2: 'variable.language' } },
      {
        match: [i, e.concat(/::/, e.lookahead(/(?!class\b)/)), I],
        scope: { 1: 'title.class', 3: 'variable.constant' }
      },
      {
        match: [i, e.concat('::', e.lookahead(/(?!class\b)/))],
        scope: { 1: 'title.class' }
      },
      {
        match: [i, /::/, /class/],
        scope: { 1: 'title.class', 3: 'variable.language' }
      }
    ]
  }
  const ne = {
    scope: 'attr',
    match: e.concat(r, e.lookahead(':'), e.lookahead(/(?!::)/))
  }
  const q = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: k,
    contains: [ne, o, Y, t.C_BLOCK_COMMENT_MODE, b, g, P]
  }
  const Q = {
    relevance: 0,
    match: [
      /\b/,
      e.concat(
        '(?!fn\\b|function\\b|',
        T(w).join('\\b|'),
        '|',
        T(S).join('\\b|'),
        '\\b)'
      ),
      r,
      e.concat(m, '*'),
      e.lookahead(/(?=\()/)
    ],
    scope: { 3: 'title.function.invoke' },
    contains: [q]
  }
  q.contains.push(Q)
  const fe = [ne, Y, t.C_BLOCK_COMMENT_MODE, b, g, P]
  const we = {
    begin: e.concat(/#\[\s*/, i),
    beginScope: 'meta',
    end: /]/,
    endScope: 'meta',
    keywords: { literal: E, keyword: ['new', 'array'] },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: { literal: E, keyword: ['new', 'array'] },
        contains: ['self', ...fe]
      },
      ...fe,
      { scope: 'meta', match: i }
    ]
  }
  return {
    case_insensitive: !1,
    keywords: k,
    contains: [
      we,
      t.HASH_COMMENT_MODE,
      t.COMMENT('//', '$'),
      t.COMMENT('/\\*', '\\*/', {
        contains: [{ scope: 'doctag', match: '@[A-Za-z]+' }]
      }),
      {
        match: /__halt_compiler\(\);/,
        keywords: '__halt_compiler',
        starts: {
          scope: 'comment',
          end: t.MATCH_NOTHING_RE,
          contains: [{ match: /\?>/, scope: 'meta', endsParent: !0 }]
        }
      },
      s,
      { scope: 'variable.language', match: /\$this\b/ },
      o,
      Q,
      Y,
      {
        match: [/const/, /\s/, r],
        scope: { 1: 'keyword', 3: 'variable.constant' }
      },
      P,
      {
        scope: 'function',
        relevance: 0,
        beginKeywords: 'fn function',
        end: /[;{]/,
        excludeEnd: !0,
        illegal: '[$%\\[]',
        contains: [
          { beginKeywords: 'use' },
          t.UNDERSCORE_TITLE_MODE,
          { begin: '=>', endsParent: !0 },
          {
            scope: 'params',
            begin: '\\(',
            end: '\\)',
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: k,
            contains: ['self', o, Y, t.C_BLOCK_COMMENT_MODE, b, g]
          }
        ]
      },
      {
        scope: 'class',
        variants: [
          { beginKeywords: 'enum', illegal: /[($"]/ },
          {
            beginKeywords: 'class interface trait',
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: 'extends implements' },
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: 'namespace',
        relevance: 0,
        end: ';',
        illegal: /[.']/,
        contains: [
          t.inherit(t.UNDERSCORE_TITLE_MODE, {
            scope: 'title.class'
          })
        ]
      },
      {
        beginKeywords: 'use',
        relevance: 0,
        end: ';',
        contains: [
          { match: /\b(as|const|function)\b/, scope: 'keyword' },
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      b,
      g
    ]
  }
}
function T_ (t) {
  return {
    name: 'PHP template',
    subLanguage: 'xml',
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: 'php',
        contains: [
          { begin: '/\\*', end: '\\*/', skip: !0 },
          { begin: 'b"', end: '"', skip: !0 },
          { begin: "b'", end: "'", skip: !0 },
          t.inherit(t.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          t.inherit(t.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  }
}
function C_ (t) {
  return {
    name: 'Plain text',
    aliases: ['text', 'txt'],
    disableAutodetect: !0
  }
}
function A_ (t) {
  const e = t.regex
  const n = /[\p{XID_Start}_]\p{XID_Continue}*/u
  const r = [
    'and',
    'as',
    'assert',
    'async',
    'await',
    'break',
    'case',
    'class',
    'continue',
    'def',
    'del',
    'elif',
    'else',
    'except',
    'finally',
    'for',
    'from',
    'global',
    'if',
    'import',
    'in',
    'is',
    'lambda',
    'match',
    'nonlocal|10',
    'not',
    'or',
    'pass',
    'raise',
    'return',
    'try',
    'while',
    'with',
    'yield'
  ]
  const l = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      '__import__',
      'abs',
      'all',
      'any',
      'ascii',
      'bin',
      'bool',
      'breakpoint',
      'bytearray',
      'bytes',
      'callable',
      'chr',
      'classmethod',
      'compile',
      'complex',
      'delattr',
      'dict',
      'dir',
      'divmod',
      'enumerate',
      'eval',
      'exec',
      'filter',
      'float',
      'format',
      'frozenset',
      'getattr',
      'globals',
      'hasattr',
      'hash',
      'help',
      'hex',
      'id',
      'input',
      'int',
      'isinstance',
      'issubclass',
      'iter',
      'len',
      'list',
      'locals',
      'map',
      'max',
      'memoryview',
      'min',
      'next',
      'object',
      'oct',
      'open',
      'ord',
      'pow',
      'print',
      'property',
      'range',
      'repr',
      'reversed',
      'round',
      'set',
      'setattr',
      'slice',
      'sorted',
      'staticmethod',
      'str',
      'sum',
      'super',
      'tuple',
      'type',
      'vars',
      'zip'
    ],
    literal: [
      '__debug__',
      'Ellipsis',
      'False',
      'None',
      'NotImplemented',
      'True'
    ],
    type: [
      'Any',
      'Callable',
      'Coroutine',
      'Dict',
      'List',
      'Literal',
      'Generic',
      'Optional',
      'Sequence',
      'Set',
      'Tuple',
      'Type',
      'Union'
    ]
  }
  const u = { className: 'meta', begin: /^(>>>|\.\.\.) / }
  const d = {
    className: 'subst',
    begin: /\{/,
    end: /\}/,
    keywords: l,
    illegal: /#/
  }
  const f = { begin: /\{\{/, relevance: 0 }
  const h = {
    className: 'string',
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [t.BACKSLASH_ESCAPE, u],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [t.BACKSLASH_ESCAPE, u],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [t.BACKSLASH_ESCAPE, u, f, d]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [t.BACKSLASH_ESCAPE, u, f, d]
      },
      { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 },
      { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 },
      { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ },
      { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [t.BACKSLASH_ESCAPE, f, d]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [t.BACKSLASH_ESCAPE, f, d]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  }
  const m = '[0-9](_?[0-9])*'
  const b = `(\\b(${m}))?\\.(${m})|\\b(${m})\\.`
  const g = `\\b|${r.join('|')}`
  const E = {
    className: 'number',
    relevance: 0,
    variants: [
      { begin: `(\\b(${m})|(${b}))[eE][+-]?(${m})[jJ]?(?=${g})` },
      { begin: `(${b})[jJ]?` },
      { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${g})` },
      { begin: `\\b0[bB](_?[01])+[lL]?(?=${g})` },
      { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${g})` },
      { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${g})` },
      { begin: `\\b(${m})[jJ](?=${g})` }
    ]
  }
  const w = {
    className: 'comment',
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: l,
    contains: [
      { begin: /# type:/ },
      { begin: /#/, end: /\b\B/, endsWithParent: !0 }
    ]
  }
  const S = {
    className: 'params',
    variants: [
      { className: '', begin: /\(\s*\)/, skip: !0 },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: l,
        contains: ['self', u, E, h, t.HASH_COMMENT_MODE]
      }
    ]
  }
  return (
    (d.contains = [h, E, u]),
    {
      name: 'Python',
      aliases: ['py', 'gyp', 'ipython'],
      unicodeRegex: !0,
      keywords: l,
      illegal: /(<\/|\?)|=>/,
      contains: [
        u,
        E,
        { begin: /\bself\b/ },
        { beginKeywords: 'if', relevance: 0 },
        h,
        w,
        t.HASH_COMMENT_MODE,
        {
          match: [/\bdef/, /\s+/, n],
          scope: { 1: 'keyword', 3: 'title.function' },
          contains: [S]
        },
        {
          variants: [
            {
              match: [
                /\bclass/,
                /\s+/,
                n,
                /\s*/,
                /\(\s*/,
                n,
                /\s*\)/
              ]
            },
            { match: [/\bclass/, /\s+/, n] }
          ],
          scope: {
            1: 'keyword',
            3: 'title.class',
            6: 'title.class.inherited'
          }
        },
        {
          className: 'meta',
          begin: /^[\t ]*@/,
          end: /(?=#)|$/,
          contains: [E, S, h]
        }
      ]
    }
  )
}
function M_ (t) {
  return {
    aliases: ['pycon'],
    contains: [
      {
        className: 'meta.prompt',
        starts: {
          end: / |$/,
          starts: { end: '$', subLanguage: 'python' }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  }
}
function N_ (t) {
  const e = t.regex
  const n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/
  const r = e.either(
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  )
  const i =
        /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/
  const o = e.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/)
  return {
    name: 'R',
    keywords: {
      $pattern: n,
      keyword: 'function if in break next repeat else for while',
      literal:
                'NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10',
      built_in:
                'LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm'
    },
    contains: [
      t.COMMENT(/#'/, /$/, {
        contains: [
          {
            scope: 'doctag',
            match: /@examples/,
            starts: {
              end: e.lookahead(
                e.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)
              ),
              endsParent: !0
            }
          },
          {
            scope: 'doctag',
            begin: '@param',
            end: /$/,
            contains: [
              {
                scope: 'variable',
                variants: [
                  { match: n },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          { scope: 'doctag', match: /@[a-zA-Z]+/ },
          { scope: 'keyword', match: /\\[a-zA-Z]+/ }
        ]
      }),
      t.HASH_COMMENT_MODE,
      {
        scope: 'string',
        contains: [t.BACKSLASH_ESCAPE],
        variants: [
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          { begin: '"', end: '"', relevance: 0 },
          { begin: "'", end: "'", relevance: 0 }
        ]
      },
      {
        relevance: 0,
        variants: [
          { scope: { 1: 'operator', 2: 'number' }, match: [i, r] },
          {
            scope: { 1: 'operator', 2: 'number' },
            match: [/%[^%]*%/, r]
          },
          { scope: { 1: 'punctuation', 2: 'number' }, match: [o, r] },
          { scope: { 2: 'number' }, match: [/[^a-zA-Z0-9._]|^/, r] }
        ]
      },
      { scope: { 3: 'operator' }, match: [n, /\s+/, /<-/, /\s+/] },
      {
        scope: 'operator',
        relevance: 0,
        variants: [{ match: i }, { match: /%[^%]*%/ }]
      },
      { scope: 'punctuation', relevance: 0, match: o },
      { begin: '`', end: '`', contains: [{ begin: /\\./ }] }
    ]
  }
}
function k_ (t) {
  const e = t.regex
  const n =
        '([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)'
  const r = e.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/)
  const i = e.concat(r, /(::\w+)*/)
  const s = {
    'variable.constant': ['__FILE__', '__LINE__', '__ENCODING__'],
    'variable.language': ['self', 'super'],
    keyword: [
      'alias',
      'and',
      'begin',
      'BEGIN',
      'break',
      'case',
      'class',
      'defined',
      'do',
      'else',
      'elsif',
      'end',
      'END',
      'ensure',
      'for',
      'if',
      'in',
      'module',
      'next',
      'not',
      'or',
      'redo',
      'require',
      'rescue',
      'retry',
      'return',
      'then',
      'undef',
      'unless',
      'until',
      'when',
      'while',
      'yield',
      ...[
        'include',
        'extend',
        'prepend',
        'public',
        'private',
        'protected',
        'raise',
        'throw'
      ]
    ],
    built_in: [
      'proc',
      'lambda',
      'attr_accessor',
      'attr_reader',
      'attr_writer',
      'define_method',
      'private_constant',
      'module_function'
    ],
    literal: ['true', 'false', 'nil']
  }
  const l = { className: 'doctag', begin: '@[A-Za-z]+' }
  const u = { begin: '#<', end: '>' }
  const d = [
    t.COMMENT('#', '$', { contains: [l] }),
    t.COMMENT('^=begin', '^=end', { contains: [l], relevance: 10 }),
    t.COMMENT('^__END__', t.MATCH_NOTHING_RE)
  ]
  const f = { className: 'subst', begin: /#\{/, end: /\}/, keywords: s }
  const h = {
    className: 'string',
    contains: [t.BACKSLASH_ESCAPE, f],
    variants: [
      { begin: /'/, end: /'/ },
      { begin: /"/, end: /"/ },
      { begin: /`/, end: /`/ },
      { begin: /%[qQwWx]?\(/, end: /\)/ },
      { begin: /%[qQwWx]?\[/, end: /\]/ },
      { begin: /%[qQwWx]?\{/, end: /\}/ },
      { begin: /%[qQwWx]?</, end: />/ },
      { begin: /%[qQwWx]?\//, end: /\// },
      { begin: /%[qQwWx]?%/, end: /%/ },
      { begin: /%[qQwWx]?-/, end: /-/ },
      { begin: /%[qQwWx]?\|/, end: /\|/ },
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      {
        begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
      },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      {
        begin: e.concat(
          /<<[-~]?'?/,
          e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          t.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [t.BACKSLASH_ESCAPE, f]
          })
        ]
      }
    ]
  }
  const m = '[1-9](_?[0-9])*|0'
  const b = '[0-9](_?[0-9])*'
  const g = {
    className: 'number',
    relevance: 0,
    variants: [
      { begin: `\\b(${m})(\\.(${b}))?([eE][+-]?(${b})|r)?i?\\b` },
      { begin: '\\b0[dD][0-9](_?[0-9])*r?i?\\b' },
      { begin: '\\b0[bB][0-1](_?[0-1])*r?i?\\b' },
      { begin: '\\b0[oO][0-7](_?[0-7])*r?i?\\b' },
      { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b' },
      { begin: '\\b0(_?[0-7])+r?i?\\b' }
    ]
  }
  const E = {
    variants: [
      { match: /\(\)/ },
      {
        className: 'params',
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: s
      }
    ]
  }
  const I = [
    h,
    {
      variants: [
        { match: [/class\s+/, i, /\s+<\s+/, i] },
        { match: [/\b(class|module)\s+/, i] }
      ],
      scope: { 2: 'title.class', 4: 'title.class.inherited' },
      keywords: s
    },
    {
      match: [/(include|extend)\s+/, i],
      scope: { 2: 'title.class' },
      keywords: s
    },
    {
      relevance: 0,
      match: [i, /\.new[. (]/],
      scope: { 1: 'title.class' }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: 'variable.constant'
    },
    { relevance: 0, match: r, scope: 'title.class' },
    {
      match: [/def/, /\s+/, n],
      scope: { 1: 'keyword', 3: 'title.function' },
      contains: [E]
    },
    { begin: t.IDENT_RE + '::' },
    {
      className: 'symbol',
      begin: t.UNDERSCORE_IDENT_RE + '(!|\\?)?:',
      relevance: 0
    },
    {
      className: 'symbol',
      begin: ':(?!\\s)',
      contains: [h, { begin: n }],
      relevance: 0
    },
    g,
    {
      className: 'variable',
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: 'params',
      begin: /\|/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      keywords: s
    },
    {
      begin: '(' + t.RE_STARTERS_RE + '|unless)\\s*',
      keywords: 'unless',
      contains: [
        {
          className: 'regexp',
          contains: [t.BACKSLASH_ESCAPE, f],
          illegal: /\n/,
          variants: [
            { begin: '/', end: '/[a-z]*' },
            { begin: /%r\{/, end: /\}[a-z]*/ },
            { begin: '%r\\(', end: '\\)[a-z]*' },
            { begin: '%r!', end: '![a-z]*' },
            { begin: '%r\\[', end: '\\][a-z]*' }
          ]
        }
      ].concat(u, d),
      relevance: 0
    }
  ].concat(u, d);
  (f.contains = I), (E.contains = I)
  const Q = [
    { begin: /^\s*=>/, starts: { end: '$', contains: I } },
    {
      className: 'meta.prompt',
      begin:
                '^(' +
                '[>?]>' +
                '|' +
                '[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]' +
                '|' +
                '(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>' +
                ')(?=[ ])',
      starts: { end: '$', keywords: s, contains: I }
    }
  ]
  return (
    d.unshift(u),
    {
      name: 'Ruby',
      aliases: ['rb', 'gemspec', 'podspec', 'thor', 'irb'],
      keywords: s,
      illegal: /\/\*/,
      contains: [t.SHEBANG({ binary: 'ruby' })]
        .concat(Q)
        .concat(d)
        .concat(I)
    }
  )
}
function O_ (t) {
  const e = t.regex
  const n = {
    className: 'title.function.invoke',
    relevance: 0,
    begin: e.concat(/\b/, /(?!let\b)/, t.IDENT_RE, e.lookahead(/\s*\(/))
  }
  const r = '([ui](8|16|32|64|128|size)|f(32|64))?'
  const i = [
    'abstract',
    'as',
    'async',
    'await',
    'become',
    'box',
    'break',
    'const',
    'continue',
    'crate',
    'do',
    'dyn',
    'else',
    'enum',
    'extern',
    'false',
    'final',
    'fn',
    'for',
    'if',
    'impl',
    'in',
    'let',
    'loop',
    'macro',
    'match',
    'mod',
    'move',
    'mut',
    'override',
    'priv',
    'pub',
    'ref',
    'return',
    'self',
    'Self',
    'static',
    'struct',
    'super',
    'trait',
    'true',
    'try',
    'type',
    'typeof',
    'unsafe',
    'unsized',
    'use',
    'virtual',
    'where',
    'while',
    'yield'
  ]
  const o = ['true', 'false', 'Some', 'None', 'Ok', 'Err']
  const s = [
    'drop ',
    'Copy',
    'Send',
    'Sized',
    'Sync',
    'Drop',
    'Fn',
    'FnMut',
    'FnOnce',
    'ToOwned',
    'Clone',
    'Debug',
    'PartialEq',
    'PartialOrd',
    'Eq',
    'Ord',
    'AsRef',
    'AsMut',
    'Into',
    'From',
    'Default',
    'Iterator',
    'Extend',
    'IntoIterator',
    'DoubleEndedIterator',
    'ExactSizeIterator',
    'SliceConcatExt',
    'ToString',
    'assert!',
    'assert_eq!',
    'bitflags!',
    'bytes!',
    'cfg!',
    'col!',
    'concat!',
    'concat_idents!',
    'debug_assert!',
    'debug_assert_eq!',
    'env!',
    'panic!',
    'file!',
    'format!',
    'format_args!',
    'include_bytes!',
    'include_str!',
    'line!',
    'local_data_key!',
    'module_path!',
    'option_env!',
    'print!',
    'println!',
    'select!',
    'stringify!',
    'try!',
    'unimplemented!',
    'unreachable!',
    'vec!',
    'write!',
    'writeln!',
    'macro_rules!',
    'assert_ne!',
    'debug_assert_ne!'
  ]
  const l = [
    'i8',
    'i16',
    'i32',
    'i64',
    'i128',
    'isize',
    'u8',
    'u16',
    'u32',
    'u64',
    'u128',
    'usize',
    'f32',
    'f64',
    'str',
    'char',
    'bool',
    'Box',
    'Option',
    'Result',
    'String',
    'Vec'
  ]
  return {
    name: 'Rust',
    aliases: ['rs'],
    keywords: {
      $pattern: t.IDENT_RE + '!?',
      type: l,
      keyword: i,
      literal: o,
      built_in: s
    },
    illegal: '</',
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.COMMENT('/\\*', '\\*/', { contains: ['self'] }),
      t.inherit(t.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
      {
        className: 'string',
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }
        ]
      },
      { className: 'symbol', begin: /'[a-zA-Z_][a-zA-Z0-9_]*/ },
      {
        className: 'number',
        variants: [
          { begin: '\\b0b([01_]+)' + r },
          { begin: '\\b0o([0-7_]+)' + r },
          { begin: '\\b0x([A-Fa-f0-9_]+)' + r },
          {
            begin:
                            '\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)' +
                            r
          }
        ],
        relevance: 0
      },
      {
        begin: [/fn/, /\s+/, t.UNDERSCORE_IDENT_RE],
        className: { 1: 'keyword', 3: 'title.function' }
      },
      {
        className: 'meta',
        begin: '#!?\\[',
        end: '\\]',
        contains: [{ className: 'string', begin: /"/, end: /"/ }]
      },
      {
        begin: [/let/, /\s+/, /(?:mut\s+)?/, t.UNDERSCORE_IDENT_RE],
        className: { 1: 'keyword', 3: 'keyword', 4: 'variable' }
      },
      {
        begin: [/for/, /\s+/, t.UNDERSCORE_IDENT_RE, /\s+/, /in/],
        className: { 1: 'keyword', 3: 'variable', 5: 'keyword' }
      },
      {
        begin: [/type/, /\s+/, t.UNDERSCORE_IDENT_RE],
        className: { 1: 'keyword', 3: 'title.class' }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: { 1: 'keyword', 3: 'title.class' }
      },
      {
        begin: t.IDENT_RE + '::',
        keywords: { keyword: 'Self', built_in: s, type: l }
      },
      { className: 'punctuation', begin: '->' },
      n
    ]
  }
}
const $F = (t) => ({
  IMPORTANT: { scope: 'meta', begin: '!important' },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: 'number',
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: 'selector-attr',
    begin: /\[/,
    end: /\]/,
    illegal: '$',
    contains: [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE]
  },
  CSS_NUMBER_MODE: {
    scope: 'number',
    begin:
            t.NUMBER_RE +
            '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
    relevance: 0
  },
  CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z][A-Za-z0-9_-]*/ }
})
const zF = [
  'a',
  'abbr',
  'address',
  'article',
  'aside',
  'audio',
  'b',
  'blockquote',
  'body',
  'button',
  'canvas',
  'caption',
  'cite',
  'code',
  'dd',
  'del',
  'details',
  'dfn',
  'div',
  'dl',
  'dt',
  'em',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'html',
  'i',
  'iframe',
  'img',
  'input',
  'ins',
  'kbd',
  'label',
  'legend',
  'li',
  'main',
  'mark',
  'menu',
  'nav',
  'object',
  'ol',
  'p',
  'q',
  'quote',
  'samp',
  'section',
  'span',
  'strong',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'thead',
  'time',
  'tr',
  'ul',
  'var',
  'video'
]
const UF = [
  'any-hover',
  'any-pointer',
  'aspect-ratio',
  'color',
  'color-gamut',
  'color-index',
  'device-aspect-ratio',
  'device-height',
  'device-width',
  'display-mode',
  'forced-colors',
  'grid',
  'height',
  'hover',
  'inverted-colors',
  'monochrome',
  'orientation',
  'overflow-block',
  'overflow-inline',
  'pointer',
  'prefers-color-scheme',
  'prefers-contrast',
  'prefers-reduced-motion',
  'prefers-reduced-transparency',
  'resolution',
  'scan',
  'scripting',
  'update',
  'width',
  'min-width',
  'max-width',
  'min-height',
  'max-height'
]
const WF = [
  'active',
  'any-link',
  'blank',
  'checked',
  'current',
  'default',
  'defined',
  'dir',
  'disabled',
  'drop',
  'empty',
  'enabled',
  'first',
  'first-child',
  'first-of-type',
  'fullscreen',
  'future',
  'focus',
  'focus-visible',
  'focus-within',
  'has',
  'host',
  'host-context',
  'hover',
  'indeterminate',
  'in-range',
  'invalid',
  'is',
  'lang',
  'last-child',
  'last-of-type',
  'left',
  'link',
  'local-link',
  'not',
  'nth-child',
  'nth-col',
  'nth-last-child',
  'nth-last-col',
  'nth-last-of-type',
  'nth-of-type',
  'only-child',
  'only-of-type',
  'optional',
  'out-of-range',
  'past',
  'placeholder-shown',
  'read-only',
  'read-write',
  'required',
  'right',
  'root',
  'scope',
  'target',
  'target-within',
  'user-invalid',
  'valid',
  'visited',
  'where'
]
const KF = [
  'after',
  'backdrop',
  'before',
  'cue',
  'cue-region',
  'first-letter',
  'first-line',
  'grammar-error',
  'marker',
  'part',
  'placeholder',
  'selection',
  'slotted',
  'spelling-error'
]
const VF = [
  'align-content',
  'align-items',
  'align-self',
  'all',
  'animation',
  'animation-delay',
  'animation-direction',
  'animation-duration',
  'animation-fill-mode',
  'animation-iteration-count',
  'animation-name',
  'animation-play-state',
  'animation-timing-function',
  'backface-visibility',
  'background',
  'background-attachment',
  'background-blend-mode',
  'background-clip',
  'background-color',
  'background-image',
  'background-origin',
  'background-position',
  'background-repeat',
  'background-size',
  'block-size',
  'border',
  'border-block',
  'border-block-color',
  'border-block-end',
  'border-block-end-color',
  'border-block-end-style',
  'border-block-end-width',
  'border-block-start',
  'border-block-start-color',
  'border-block-start-style',
  'border-block-start-width',
  'border-block-style',
  'border-block-width',
  'border-bottom',
  'border-bottom-color',
  'border-bottom-left-radius',
  'border-bottom-right-radius',
  'border-bottom-style',
  'border-bottom-width',
  'border-collapse',
  'border-color',
  'border-image',
  'border-image-outset',
  'border-image-repeat',
  'border-image-slice',
  'border-image-source',
  'border-image-width',
  'border-inline',
  'border-inline-color',
  'border-inline-end',
  'border-inline-end-color',
  'border-inline-end-style',
  'border-inline-end-width',
  'border-inline-start',
  'border-inline-start-color',
  'border-inline-start-style',
  'border-inline-start-width',
  'border-inline-style',
  'border-inline-width',
  'border-left',
  'border-left-color',
  'border-left-style',
  'border-left-width',
  'border-radius',
  'border-right',
  'border-right-color',
  'border-right-style',
  'border-right-width',
  'border-spacing',
  'border-style',
  'border-top',
  'border-top-color',
  'border-top-left-radius',
  'border-top-right-radius',
  'border-top-style',
  'border-top-width',
  'border-width',
  'bottom',
  'box-decoration-break',
  'box-shadow',
  'box-sizing',
  'break-after',
  'break-before',
  'break-inside',
  'caption-side',
  'caret-color',
  'clear',
  'clip',
  'clip-path',
  'clip-rule',
  'color',
  'column-count',
  'column-fill',
  'column-gap',
  'column-rule',
  'column-rule-color',
  'column-rule-style',
  'column-rule-width',
  'column-span',
  'column-width',
  'columns',
  'contain',
  'content',
  'content-visibility',
  'counter-increment',
  'counter-reset',
  'cue',
  'cue-after',
  'cue-before',
  'cursor',
  'direction',
  'display',
  'empty-cells',
  'filter',
  'flex',
  'flex-basis',
  'flex-direction',
  'flex-flow',
  'flex-grow',
  'flex-shrink',
  'flex-wrap',
  'float',
  'flow',
  'font',
  'font-display',
  'font-family',
  'font-feature-settings',
  'font-kerning',
  'font-language-override',
  'font-size',
  'font-size-adjust',
  'font-smoothing',
  'font-stretch',
  'font-style',
  'font-synthesis',
  'font-variant',
  'font-variant-caps',
  'font-variant-east-asian',
  'font-variant-ligatures',
  'font-variant-numeric',
  'font-variant-position',
  'font-variation-settings',
  'font-weight',
  'gap',
  'glyph-orientation-vertical',
  'grid',
  'grid-area',
  'grid-auto-columns',
  'grid-auto-flow',
  'grid-auto-rows',
  'grid-column',
  'grid-column-end',
  'grid-column-start',
  'grid-gap',
  'grid-row',
  'grid-row-end',
  'grid-row-start',
  'grid-template',
  'grid-template-areas',
  'grid-template-columns',
  'grid-template-rows',
  'hanging-punctuation',
  'height',
  'hyphens',
  'icon',
  'image-orientation',
  'image-rendering',
  'image-resolution',
  'ime-mode',
  'inline-size',
  'isolation',
  'justify-content',
  'left',
  'letter-spacing',
  'line-break',
  'line-height',
  'list-style',
  'list-style-image',
  'list-style-position',
  'list-style-type',
  'margin',
  'margin-block',
  'margin-block-end',
  'margin-block-start',
  'margin-bottom',
  'margin-inline',
  'margin-inline-end',
  'margin-inline-start',
  'margin-left',
  'margin-right',
  'margin-top',
  'marks',
  'mask',
  'mask-border',
  'mask-border-mode',
  'mask-border-outset',
  'mask-border-repeat',
  'mask-border-slice',
  'mask-border-source',
  'mask-border-width',
  'mask-clip',
  'mask-composite',
  'mask-image',
  'mask-mode',
  'mask-origin',
  'mask-position',
  'mask-repeat',
  'mask-size',
  'mask-type',
  'max-block-size',
  'max-height',
  'max-inline-size',
  'max-width',
  'min-block-size',
  'min-height',
  'min-inline-size',
  'min-width',
  'mix-blend-mode',
  'nav-down',
  'nav-index',
  'nav-left',
  'nav-right',
  'nav-up',
  'none',
  'normal',
  'object-fit',
  'object-position',
  'opacity',
  'order',
  'orphans',
  'outline',
  'outline-color',
  'outline-offset',
  'outline-style',
  'outline-width',
  'overflow',
  'overflow-wrap',
  'overflow-x',
  'overflow-y',
  'padding',
  'padding-block',
  'padding-block-end',
  'padding-block-start',
  'padding-bottom',
  'padding-inline',
  'padding-inline-end',
  'padding-inline-start',
  'padding-left',
  'padding-right',
  'padding-top',
  'page-break-after',
  'page-break-before',
  'page-break-inside',
  'pause',
  'pause-after',
  'pause-before',
  'perspective',
  'perspective-origin',
  'pointer-events',
  'position',
  'quotes',
  'resize',
  'rest',
  'rest-after',
  'rest-before',
  'right',
  'row-gap',
  'scroll-margin',
  'scroll-margin-block',
  'scroll-margin-block-end',
  'scroll-margin-block-start',
  'scroll-margin-bottom',
  'scroll-margin-inline',
  'scroll-margin-inline-end',
  'scroll-margin-inline-start',
  'scroll-margin-left',
  'scroll-margin-right',
  'scroll-margin-top',
  'scroll-padding',
  'scroll-padding-block',
  'scroll-padding-block-end',
  'scroll-padding-block-start',
  'scroll-padding-bottom',
  'scroll-padding-inline',
  'scroll-padding-inline-end',
  'scroll-padding-inline-start',
  'scroll-padding-left',
  'scroll-padding-right',
  'scroll-padding-top',
  'scroll-snap-align',
  'scroll-snap-stop',
  'scroll-snap-type',
  'scrollbar-color',
  'scrollbar-gutter',
  'scrollbar-width',
  'shape-image-threshold',
  'shape-margin',
  'shape-outside',
  'speak',
  'speak-as',
  'src',
  'tab-size',
  'table-layout',
  'text-align',
  'text-align-all',
  'text-align-last',
  'text-combine-upright',
  'text-decoration',
  'text-decoration-color',
  'text-decoration-line',
  'text-decoration-style',
  'text-emphasis',
  'text-emphasis-color',
  'text-emphasis-position',
  'text-emphasis-style',
  'text-indent',
  'text-justify',
  'text-orientation',
  'text-overflow',
  'text-rendering',
  'text-shadow',
  'text-transform',
  'text-underline-position',
  'top',
  'transform',
  'transform-box',
  'transform-origin',
  'transform-style',
  'transition',
  'transition-delay',
  'transition-duration',
  'transition-property',
  'transition-timing-function',
  'unicode-bidi',
  'vertical-align',
  'visibility',
  'voice-balance',
  'voice-duration',
  'voice-family',
  'voice-pitch',
  'voice-range',
  'voice-rate',
  'voice-stress',
  'voice-volume',
  'white-space',
  'widows',
  'width',
  'will-change',
  'word-break',
  'word-spacing',
  'word-wrap',
  'writing-mode',
  'z-index'
].reverse()
function R_ (t) {
  const e = $F(t)
  const n = KF
  const r = WF
  const i = '@[a-z-]+'
  const o = 'and or not only'
  const l = {
    className: 'variable',
    begin: '(\\$' + '[a-zA-Z-][a-zA-Z0-9_-]*' + ')\\b',
    relevance: 0
  }
  return {
    name: 'SCSS',
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      e.CSS_NUMBER_MODE,
      {
        className: 'selector-id',
        begin: '#[A-Za-z0-9_-]+',
        relevance: 0
      },
      {
        className: 'selector-class',
        begin: '\\.[A-Za-z0-9_-]+',
        relevance: 0
      },
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: 'selector-tag',
        begin: '\\b(' + zF.join('|') + ')\\b',
        relevance: 0
      },
      { className: 'selector-pseudo', begin: ':(' + r.join('|') + ')' },
      {
        className: 'selector-pseudo',
        begin: ':(:)?(' + n.join('|') + ')'
      },
      l,
      { begin: /\(/, end: /\)/, contains: [e.CSS_NUMBER_MODE] },
      e.CSS_VARIABLE,
      { className: 'attribute', begin: '\\b(' + VF.join('|') + ')\\b' },
      {
        begin: '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b'
      },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          e.BLOCK_COMMENT,
          l,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.IMPORTANT,
          e.FUNCTION_DISPATCH
        ]
      },
      {
        begin: '@(page|font-face)',
        keywords: { $pattern: i, keyword: '@page @font-face' }
      },
      {
        begin: '@',
        end: '[{;]',
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: o,
          attribute: UF.join(' ')
        },
        contains: [
          { begin: i, className: 'keyword' },
          { begin: /[a-z-]+(?=:)/, className: 'attribute' },
          l,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE
        ]
      },
      e.FUNCTION_DISPATCH
    ]
  }
}
function I_ (t) {
  return {
    name: 'Shell Session',
    aliases: ['console', 'shellsession'],
    contains: [
      {
        className: 'meta.prompt',
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: { end: /[^\\](?=\s*$)/, subLanguage: 'bash' }
      }
    ]
  }
}
function D_ (t) {
  const e = t.regex
  const n = t.COMMENT('--', '$')
  const r = {
    className: 'string',
    variants: [{ begin: /'/, end: /'/, contains: [{ begin: /''/ }] }]
  }
  const i = { begin: /"/, end: /"/, contains: [{ begin: /""/ }] }
  const o = ['true', 'false', 'unknown']
  const s = [
    'double precision',
    'large object',
    'with timezone',
    'without timezone'
  ]
  const l = [
    'bigint',
    'binary',
    'blob',
    'boolean',
    'char',
    'character',
    'clob',
    'date',
    'dec',
    'decfloat',
    'decimal',
    'float',
    'int',
    'integer',
    'interval',
    'nchar',
    'nclob',
    'national',
    'numeric',
    'real',
    'row',
    'smallint',
    'time',
    'timestamp',
    'varchar',
    'varying',
    'varbinary'
  ]
  const u = [
    'add',
    'asc',
    'collation',
    'desc',
    'final',
    'first',
    'last',
    'view'
  ]
  const d = [
    'abs',
    'acos',
    'all',
    'allocate',
    'alter',
    'and',
    'any',
    'are',
    'array',
    'array_agg',
    'array_max_cardinality',
    'as',
    'asensitive',
    'asin',
    'asymmetric',
    'at',
    'atan',
    'atomic',
    'authorization',
    'avg',
    'begin',
    'begin_frame',
    'begin_partition',
    'between',
    'bigint',
    'binary',
    'blob',
    'boolean',
    'both',
    'by',
    'call',
    'called',
    'cardinality',
    'cascaded',
    'case',
    'cast',
    'ceil',
    'ceiling',
    'char',
    'char_length',
    'character',
    'character_length',
    'check',
    'classifier',
    'clob',
    'close',
    'coalesce',
    'collate',
    'collect',
    'column',
    'commit',
    'condition',
    'connect',
    'constraint',
    'contains',
    'convert',
    'copy',
    'corr',
    'corresponding',
    'cos',
    'cosh',
    'count',
    'covar_pop',
    'covar_samp',
    'create',
    'cross',
    'cube',
    'cume_dist',
    'current',
    'current_catalog',
    'current_date',
    'current_default_transform_group',
    'current_path',
    'current_role',
    'current_row',
    'current_schema',
    'current_time',
    'current_timestamp',
    'current_path',
    'current_role',
    'current_transform_group_for_type',
    'current_user',
    'cursor',
    'cycle',
    'date',
    'day',
    'deallocate',
    'dec',
    'decimal',
    'decfloat',
    'declare',
    'default',
    'define',
    'delete',
    'dense_rank',
    'deref',
    'describe',
    'deterministic',
    'disconnect',
    'distinct',
    'double',
    'drop',
    'dynamic',
    'each',
    'element',
    'else',
    'empty',
    'end',
    'end_frame',
    'end_partition',
    'end-exec',
    'equals',
    'escape',
    'every',
    'except',
    'exec',
    'execute',
    'exists',
    'exp',
    'external',
    'extract',
    'false',
    'fetch',
    'filter',
    'first_value',
    'float',
    'floor',
    'for',
    'foreign',
    'frame_row',
    'free',
    'from',
    'full',
    'function',
    'fusion',
    'get',
    'global',
    'grant',
    'group',
    'grouping',
    'groups',
    'having',
    'hold',
    'hour',
    'identity',
    'in',
    'indicator',
    'initial',
    'inner',
    'inout',
    'insensitive',
    'insert',
    'int',
    'integer',
    'intersect',
    'intersection',
    'interval',
    'into',
    'is',
    'join',
    'json_array',
    'json_arrayagg',
    'json_exists',
    'json_object',
    'json_objectagg',
    'json_query',
    'json_table',
    'json_table_primitive',
    'json_value',
    'lag',
    'language',
    'large',
    'last_value',
    'lateral',
    'lead',
    'leading',
    'left',
    'like',
    'like_regex',
    'listagg',
    'ln',
    'local',
    'localtime',
    'localtimestamp',
    'log',
    'log10',
    'lower',
    'match',
    'match_number',
    'match_recognize',
    'matches',
    'max',
    'member',
    'merge',
    'method',
    'min',
    'minute',
    'mod',
    'modifies',
    'module',
    'month',
    'multiset',
    'national',
    'natural',
    'nchar',
    'nclob',
    'new',
    'no',
    'none',
    'normalize',
    'not',
    'nth_value',
    'ntile',
    'null',
    'nullif',
    'numeric',
    'octet_length',
    'occurrences_regex',
    'of',
    'offset',
    'old',
    'omit',
    'on',
    'one',
    'only',
    'open',
    'or',
    'order',
    'out',
    'outer',
    'over',
    'overlaps',
    'overlay',
    'parameter',
    'partition',
    'pattern',
    'per',
    'percent',
    'percent_rank',
    'percentile_cont',
    'percentile_disc',
    'period',
    'portion',
    'position',
    'position_regex',
    'power',
    'precedes',
    'precision',
    'prepare',
    'primary',
    'procedure',
    'ptf',
    'range',
    'rank',
    'reads',
    'real',
    'recursive',
    'ref',
    'references',
    'referencing',
    'regr_avgx',
    'regr_avgy',
    'regr_count',
    'regr_intercept',
    'regr_r2',
    'regr_slope',
    'regr_sxx',
    'regr_sxy',
    'regr_syy',
    'release',
    'result',
    'return',
    'returns',
    'revoke',
    'right',
    'rollback',
    'rollup',
    'row',
    'row_number',
    'rows',
    'running',
    'savepoint',
    'scope',
    'scroll',
    'search',
    'second',
    'seek',
    'select',
    'sensitive',
    'session_user',
    'set',
    'show',
    'similar',
    'sin',
    'sinh',
    'skip',
    'smallint',
    'some',
    'specific',
    'specifictype',
    'sql',
    'sqlexception',
    'sqlstate',
    'sqlwarning',
    'sqrt',
    'start',
    'static',
    'stddev_pop',
    'stddev_samp',
    'submultiset',
    'subset',
    'substring',
    'substring_regex',
    'succeeds',
    'sum',
    'symmetric',
    'system',
    'system_time',
    'system_user',
    'table',
    'tablesample',
    'tan',
    'tanh',
    'then',
    'time',
    'timestamp',
    'timezone_hour',
    'timezone_minute',
    'to',
    'trailing',
    'translate',
    'translate_regex',
    'translation',
    'treat',
    'trigger',
    'trim',
    'trim_array',
    'true',
    'truncate',
    'uescape',
    'union',
    'unique',
    'unknown',
    'unnest',
    'update',
    'upper',
    'user',
    'using',
    'value',
    'values',
    'value_of',
    'var_pop',
    'var_samp',
    'varbinary',
    'varchar',
    'varying',
    'versioning',
    'when',
    'whenever',
    'where',
    'width_bucket',
    'window',
    'with',
    'within',
    'without',
    'year'
  ]
  const f = [
    'abs',
    'acos',
    'array_agg',
    'asin',
    'atan',
    'avg',
    'cast',
    'ceil',
    'ceiling',
    'coalesce',
    'corr',
    'cos',
    'cosh',
    'count',
    'covar_pop',
    'covar_samp',
    'cume_dist',
    'dense_rank',
    'deref',
    'element',
    'exp',
    'extract',
    'first_value',
    'floor',
    'json_array',
    'json_arrayagg',
    'json_exists',
    'json_object',
    'json_objectagg',
    'json_query',
    'json_table',
    'json_table_primitive',
    'json_value',
    'lag',
    'last_value',
    'lead',
    'listagg',
    'ln',
    'log',
    'log10',
    'lower',
    'max',
    'min',
    'mod',
    'nth_value',
    'ntile',
    'nullif',
    'percent_rank',
    'percentile_cont',
    'percentile_disc',
    'position',
    'position_regex',
    'power',
    'rank',
    'regr_avgx',
    'regr_avgy',
    'regr_count',
    'regr_intercept',
    'regr_r2',
    'regr_slope',
    'regr_sxx',
    'regr_sxy',
    'regr_syy',
    'row_number',
    'sin',
    'sinh',
    'sqrt',
    'stddev_pop',
    'stddev_samp',
    'substring',
    'substring_regex',
    'sum',
    'tan',
    'tanh',
    'translate',
    'translate_regex',
    'treat',
    'trim',
    'trim_array',
    'unnest',
    'upper',
    'value_of',
    'var_pop',
    'var_samp',
    'width_bucket'
  ]
  const h = [
    'current_catalog',
    'current_date',
    'current_default_transform_group',
    'current_path',
    'current_role',
    'current_schema',
    'current_transform_group_for_type',
    'current_user',
    'session_user',
    'system_time',
    'system_user',
    'current_time',
    'localtime',
    'current_timestamp',
    'localtimestamp'
  ]
  const m = [
    'create table',
    'insert into',
    'primary key',
    'foreign key',
    'not null',
    'alter table',
    'add constraint',
    'grouping sets',
    'on overflow',
    'character set',
    'respect nulls',
    'ignore nulls',
    'nulls first',
    'nulls last',
    'depth first',
    'breadth first'
  ]
  const b = f
  const g = [...d, ...u].filter((k) => !f.includes(k))
  const E = { className: 'variable', begin: /@[a-z0-9][a-z0-9_]*/ }
  const w = {
    className: 'operator',
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }
  const S = {
    begin: e.concat(/\b/, e.either(...b), /\s*\(/),
    relevance: 0,
    keywords: { built_in: b }
  }
  function O (k, { exceptions: T, when: P } = {}) {
    const I = P
    return (
      (T = T || []),
      k.map((Y) =>
        Y.match(/\|\d+$/) || T.includes(Y) ? Y : I(Y) ? `${Y}|0` : Y
      )
    )
  }
  return {
    name: 'SQL',
    case_insensitive: !0,
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: O(g, { when: (k) => k.length < 3 }),
      literal: o,
      type: l,
      built_in: h
    },
    contains: [
      {
        begin: e.either(...m),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: g.concat(m),
          literal: o,
          type: l
        }
      },
      { className: 'type', begin: e.either(...s) },
      S,
      E,
      r,
      i,
      t.C_NUMBER_MODE,
      t.C_BLOCK_COMMENT_MODE,
      n,
      w
    ]
  }
}
function F_ (t) {
  return t ? (typeof t === 'string' ? t : t.source) : null
}
function Tu (t) {
  return nt('(?=', t, ')')
}
function nt (...t) {
  return t.map((n) => F_(n)).join('')
}
function GF (t) {
  const e = t[t.length - 1]
  return typeof e === 'object' && e.constructor === Object
    ? (t.splice(t.length - 1, 1), e)
    : {}
}
function Sn (...t) {
  return (
    '(' + (GF(t).capture ? '' : '?:') + t.map((r) => F_(r)).join('|') + ')'
  )
}
const Om = (t) => nt(/\b/, t, /\w$/.test(t) ? /\b/ : /\B/)
const qF = ['Protocol', 'Type'].map(Om)
const L_ = ['init', 'self'].map(Om)
const YF = ['Any', 'Self']
const Mm = [
  'actor',
  'any',
  'associatedtype',
  'async',
  'await',
  /as\?/,
  /as!/,
  'as',
  'break',
  'case',
  'catch',
  'class',
  'continue',
  'convenience',
  'default',
  'defer',
  'deinit',
  'didSet',
  'distributed',
  'do',
  'dynamic',
  'else',
  'enum',
  'extension',
  'fallthrough',
  /fileprivate\(set\)/,
  'fileprivate',
  'final',
  'for',
  'func',
  'get',
  'guard',
  'if',
  'import',
  'indirect',
  'infix',
  /init\?/,
  /init!/,
  'inout',
  /internal\(set\)/,
  'internal',
  'in',
  'is',
  'isolated',
  'nonisolated',
  'lazy',
  'let',
  'mutating',
  'nonmutating',
  /open\(set\)/,
  'open',
  'operator',
  'optional',
  'override',
  'postfix',
  'precedencegroup',
  'prefix',
  /private\(set\)/,
  'private',
  'protocol',
  /public\(set\)/,
  'public',
  'repeat',
  'required',
  'rethrows',
  'return',
  'set',
  'some',
  'static',
  'struct',
  'subscript',
  'super',
  'switch',
  'throws',
  'throw',
  /try\?/,
  /try!/,
  'try',
  'typealias',
  /unowned\(safe\)/,
  /unowned\(unsafe\)/,
  'unowned',
  'var',
  'weak',
  'where',
  'while',
  'willSet'
]
const P_ = ['false', 'nil', 'true']
const JF = [
  'assignment',
  'associativity',
  'higherThan',
  'left',
  'lowerThan',
  'none',
  'right'
]
const XF = [
  '#colorLiteral',
  '#column',
  '#dsohandle',
  '#else',
  '#elseif',
  '#endif',
  '#error',
  '#file',
  '#fileID',
  '#fileLiteral',
  '#filePath',
  '#function',
  '#if',
  '#imageLiteral',
  '#keyPath',
  '#line',
  '#selector',
  '#sourceLocation',
  '#warn_unqualified_access',
  '#warning'
]
const B_ = [
  'abs',
  'all',
  'any',
  'assert',
  'assertionFailure',
  'debugPrint',
  'dump',
  'fatalError',
  'getVaList',
  'isKnownUniquelyReferenced',
  'max',
  'min',
  'numericCast',
  'pointwiseMax',
  'pointwiseMin',
  'precondition',
  'preconditionFailure',
  'print',
  'readLine',
  'repeatElement',
  'sequence',
  'stride',
  'swap',
  'swift_unboxFromSwiftValueWithType',
  'transcode',
  'type',
  'unsafeBitCast',
  'unsafeDowncast',
  'withExtendedLifetime',
  'withUnsafeMutablePointer',
  'withUnsafePointer',
  'withVaList',
  'withoutActuallyEscaping',
  'zip'
]
const H_ = Sn(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
)
const $_ = Sn(
  H_,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
)
const Nm = nt(H_, $_, '*')
const z_ = Sn(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
)
const Cu = Sn(
  z_,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
)
const Xr = nt(z_, Cu, '*')
const km = nt(/[A-Z]/, Cu, '*')
const ZF = [
  'autoclosure',
  nt(/convention\(/, Sn('swift', 'block', 'c'), /\)/),
  'discardableResult',
  'dynamicCallable',
  'dynamicMemberLookup',
  'escaping',
  'frozen',
  'GKInspectable',
  'IBAction',
  'IBDesignable',
  'IBInspectable',
  'IBOutlet',
  'IBSegueAction',
  'inlinable',
  'main',
  'nonobjc',
  'NSApplicationMain',
  'NSCopying',
  'NSManaged',
  nt(/objc\(/, Xr, /\)/),
  'objc',
  'objcMembers',
  'propertyWrapper',
  'requires_stored_property_inits',
  'resultBuilder',
  'testable',
  'UIApplicationMain',
  'unknown',
  'usableFromInline'
]
const jF = [
  'iOS',
  'iOSApplicationExtension',
  'macOS',
  'macOSApplicationExtension',
  'macCatalyst',
  'macCatalystApplicationExtension',
  'watchOS',
  'watchOSApplicationExtension',
  'tvOS',
  'tvOSApplicationExtension',
  'swift'
]
function U_ (t) {
  const e = { match: /\s+/, relevance: 0 }
  const n = t.COMMENT('/\\*', '\\*/', { contains: ['self'] })
  const r = [t.C_LINE_COMMENT_MODE, n]
  const i = { match: [/\./, Sn(...qF, ...L_)], className: { 2: 'keyword' } }
  const o = { match: nt(/\./, Sn(...Mm)), relevance: 0 }
  const s = Mm.filter((Re) => typeof Re === 'string').concat(['_|0'])
  const l = Mm.filter((Re) => typeof Re !== 'string')
    .concat(YF)
    .map(Om)
  const u = { variants: [{ className: 'keyword', match: Sn(...l, ...L_) }] }
  const d = {
    $pattern: Sn(/\b\w+/, /#\w+/),
    keyword: s.concat(XF),
    literal: P_
  }
  const f = [i, o, u]
  const h = { match: nt(/\./, Sn(...B_)), relevance: 0 }
  const m = { className: 'built_in', match: nt(/\b/, Sn(...B_), /(?=\()/) }
  const b = [h, m]
  const g = { match: /->/, relevance: 0 }
  const E = {
    className: 'operator',
    relevance: 0,
    variants: [{ match: Nm }, { match: `\\.(\\.|${$_})+` }]
  }
  const w = [g, E]
  const S = '([0-9]_*)+'
  const O = '([0-9a-fA-F]_*)+'
  const k = {
    className: 'number',
    relevance: 0,
    variants: [
      { match: `\\b(${S})(\\.(${S}))?([eE][+-]?(${S}))?\\b` },
      { match: `\\b0x(${O})(\\.(${O}))?([pP][+-]?(${S}))?\\b` },
      { match: /\b0o([0-7]_*)+\b/ },
      { match: /\b0b([01]_*)+\b/ }
    ]
  }
  const T = (Re = '') => ({
    className: 'subst',
    variants: [
      { match: nt(/\\/, Re, /[0\\tnr"']/) },
      { match: nt(/\\/, Re, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  })
  const P = (Re = '') => ({
    className: 'subst',
    match: nt(/\\/, Re, /[\t ]*(?:[\r\n]|\r\n)/)
  })
  const I = (Re = '') => ({
    className: 'subst',
    label: 'interpol',
    begin: nt(/\\/, Re, /\(/),
    end: /\)/
  })
  const Y = (Re = '') => ({
    begin: nt(Re, /"""/),
    end: nt(/"""/, Re),
    contains: [T(Re), P(Re), I(Re)]
  })
  const ne = (Re = '') => ({
    begin: nt(Re, /"/),
    end: nt(/"/, Re),
    contains: [T(Re), I(Re)]
  })
  const q = {
    className: 'string',
    variants: [
      Y(),
      Y('#'),
      Y('##'),
      Y('###'),
      ne(),
      ne('#'),
      ne('##'),
      ne('###')
    ]
  }
  const Q = { match: nt(/`/, Xr, /`/) }
  const fe = { className: 'variable', match: /\$\d+/ }
  const we = { className: 'variable', match: `\\$${Cu}+` }
  const me = [Q, fe, we]
  const Ce = {
    match: /(@|#(un)?)available/,
    className: 'keyword',
    starts: {
      contains: [
        {
          begin: /\(/,
          end: /\)/,
          keywords: jF,
          contains: [...w, k, q]
        }
      ]
    }
  }
  const ge = { className: 'keyword', match: nt(/@/, Sn(...ZF)) }
  const ye = { className: 'meta', match: nt(/@/, Xr) }
  const A = [Ce, ge, ye]
  const D = {
    match: Tu(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        className: 'type',
        match: nt(
          /(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/,
          Cu,
          '+'
        )
      },
      { className: 'type', match: km, relevance: 0 },
      { match: /[?!]+/, relevance: 0 },
      { match: /\.\.\./, relevance: 0 },
      { match: nt(/\s+&\s+/, Tu(km)), relevance: 0 }
    ]
  }
  const z = {
    begin: /</,
    end: />/,
    keywords: d,
    contains: [...r, ...f, ...A, g, D]
  }
  D.contains.push(z)
  const j = { match: nt(Xr, /\s*:/), keywords: '_|0', relevance: 0 }
  const ie = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: d,
    contains: ['self', j, ...r, ...f, ...b, ...w, k, q, ...me, ...A, D]
  }
  const xe = { begin: /</, end: />/, contains: [...r, D] }
  const Ae = {
    begin: Sn(Tu(nt(Xr, /\s*:/)), Tu(nt(Xr, /\s+/, Xr, /\s*:/))),
    end: /:/,
    relevance: 0,
    contains: [
      { className: 'keyword', match: /\b_\b/ },
      { className: 'params', match: Xr }
    ]
  }
  const je = {
    begin: /\(/,
    end: /\)/,
    keywords: d,
    contains: [Ae, ...r, ...f, ...w, k, q, ...A, D, ie],
    endsParent: !0,
    illegal: /["']/
  }
  const Ne = {
    match: [/func/, /\s+/, Sn(Q.match, Xr, Nm)],
    className: { 1: 'keyword', 3: 'title.function' },
    contains: [xe, je, e],
    illegal: [/\[/, /%/]
  }
  const Be = {
    match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
    className: { 1: 'keyword' },
    contains: [xe, je, e],
    illegal: /\[|%/
  }
  const _t = {
    match: [/operator/, /\s+/, Nm],
    className: { 1: 'keyword', 3: 'title' }
  }
  const kt = {
    begin: [/precedencegroup/, /\s+/, km],
    className: { 1: 'keyword', 3: 'title' },
    contains: [D],
    keywords: [...JF, ...P_],
    end: /}/
  }
  for (const Re of q.variants) {
    const St = Re.contains.find((pt) => pt.label === 'interpol')
    St.keywords = d
    const Xt = [...f, ...b, ...w, k, q, ...me]
    St.contains = [
      ...Xt,
      { begin: /\(/, end: /\)/, contains: ['self', ...Xt] }
    ]
  }
  return {
    name: 'Swift',
    keywords: d,
    contains: [
      ...r,
      Ne,
      Be,
      {
        beginKeywords: 'struct protocol class extension enum actor',
        end: '\\{',
        excludeEnd: !0,
        keywords: d,
        contains: [
          t.inherit(t.TITLE_MODE, {
            className: 'title.class',
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }),
          ...f
        ]
      },
      _t,
      kt,
      {
        beginKeywords: 'import',
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      ...f,
      ...b,
      ...w,
      k,
      q,
      ...me,
      ...A,
      D,
      ie
    ]
  }
}
const Au = '[A-Za-z$_][0-9A-Za-z$_]*'
const W_ = [
  'as',
  'in',
  'of',
  'if',
  'for',
  'while',
  'finally',
  'var',
  'new',
  'function',
  'do',
  'return',
  'void',
  'else',
  'break',
  'catch',
  'instanceof',
  'with',
  'throw',
  'case',
  'default',
  'try',
  'switch',
  'continue',
  'typeof',
  'delete',
  'let',
  'yield',
  'const',
  'class',
  'debugger',
  'async',
  'await',
  'static',
  'import',
  'from',
  'export',
  'extends'
]
const K_ = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity']
const V_ = [
  'Object',
  'Function',
  'Boolean',
  'Symbol',
  'Math',
  'Date',
  'Number',
  'BigInt',
  'String',
  'RegExp',
  'Array',
  'Float32Array',
  'Float64Array',
  'Int8Array',
  'Uint8Array',
  'Uint8ClampedArray',
  'Int16Array',
  'Int32Array',
  'Uint16Array',
  'Uint32Array',
  'BigInt64Array',
  'BigUint64Array',
  'Set',
  'Map',
  'WeakSet',
  'WeakMap',
  'ArrayBuffer',
  'SharedArrayBuffer',
  'Atomics',
  'DataView',
  'JSON',
  'Promise',
  'Generator',
  'GeneratorFunction',
  'AsyncFunction',
  'Reflect',
  'Proxy',
  'Intl',
  'WebAssembly'
]
const G_ = [
  'Error',
  'EvalError',
  'InternalError',
  'RangeError',
  'ReferenceError',
  'SyntaxError',
  'TypeError',
  'URIError'
]
const q_ = [
  'setInterval',
  'setTimeout',
  'clearInterval',
  'clearTimeout',
  'require',
  'exports',
  'eval',
  'isFinite',
  'isNaN',
  'parseFloat',
  'parseInt',
  'decodeURI',
  'decodeURIComponent',
  'encodeURI',
  'encodeURIComponent',
  'escape',
  'unescape'
]
const Y_ = [
  'arguments',
  'this',
  'super',
  'console',
  'window',
  'document',
  'localStorage',
  'sessionStorage',
  'module',
  'global'
]
const J_ = [].concat(q_, V_, G_)
function QF (t) {
  const e = t.regex
  const n = (D, { after: z }) => {
    const j = '</' + D[0].slice(1)
    return D.input.indexOf(j, z) !== -1
  }
  const r = Au
  const i = { begin: '<>', end: '</>' }
  const o = /<[A-Za-z0-9\\._:-]+\s*\/>/
  const s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    isTrulyOpeningTag: (D, z) => {
      const j = D[0].length + D.index
      const ie = D.input[j]
      if (ie === '<' || ie === ',') {
        z.ignoreMatch()
        return
      }
      ie === '>' && (n(D, { after: j }) || z.ignoreMatch())
      let xe
      const Ae = D.input.substring(j)
      if ((xe = Ae.match(/^\s*=/))) {
        z.ignoreMatch()
        return
      }
      if ((xe = Ae.match(/^\s+extends\s+/)) && xe.index === 0) {
        z.ignoreMatch()
      }
    }
  }
  const l = {
    $pattern: Au,
    keyword: W_,
    literal: K_,
    built_in: J_,
    'variable.language': Y_
  }
  const u = '[0-9](_?[0-9])*'
  const d = `\\.(${u})`
  const f = '0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*'
  const h = {
    className: 'number',
    variants: [
      { begin: `(\\b(${f})((${d})|\\.)?|(${d}))[eE][+-]?(${u})\\b` },
      { begin: `\\b(${f})\\b((${d})\\b|\\.)?|(${d})\\b` },
      { begin: '\\b(0|[1-9](_?[0-9])*)n\\b' },
      { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b' },
      { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
      { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
      { begin: '\\b0[0-7]+n?\\b' }
    ],
    relevance: 0
  }
  const m = {
    className: 'subst',
    begin: '\\$\\{',
    end: '\\}',
    keywords: l,
    contains: []
  }
  const b = {
    begin: 'html`',
    end: '',
    starts: {
      end: '`',
      returnEnd: !1,
      contains: [t.BACKSLASH_ESCAPE, m],
      subLanguage: 'xml'
    }
  }
  const g = {
    begin: 'css`',
    end: '',
    starts: {
      end: '`',
      returnEnd: !1,
      contains: [t.BACKSLASH_ESCAPE, m],
      subLanguage: 'css'
    }
  }
  const E = {
    begin: 'gql`',
    end: '',
    starts: {
      end: '`',
      returnEnd: !1,
      contains: [t.BACKSLASH_ESCAPE, m],
      subLanguage: 'graphql'
    }
  }
  const w = {
    className: 'string',
    begin: '`',
    end: '`',
    contains: [t.BACKSLASH_ESCAPE, m]
  }
  const O = {
    className: 'comment',
    variants: [
      t.COMMENT(/\/\*\*(?!\/)/, '\\*/', {
        relevance: 0,
        contains: [
          {
            begin: '(?=@[A-Za-z]+)',
            relevance: 0,
            contains: [
              { className: 'doctag', begin: '@[A-Za-z]+' },
              {
                className: 'type',
                begin: '\\{',
                end: '\\}',
                excludeEnd: !0,
                excludeBegin: !0,
                relevance: 0
              },
              {
                className: 'variable',
                begin: r + '(?=\\s*(-)|$)',
                endsParent: !0,
                relevance: 0
              },
              { begin: /(?=[^\n])\s/, relevance: 0 }
            ]
          }
        ]
      }),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }
  const k = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    b,
    g,
    E,
    w,
    { match: /\$\d+/ },
    h
  ]
  m.contains = k.concat({
    begin: /\{/,
    end: /\}/,
    keywords: l,
    contains: ['self'].concat(k)
  })
  const T = [].concat(O, m.contains)
  const P = T.concat([
    {
      begin: /\(/,
      end: /\)/,
      keywords: l,
      contains: ['self'].concat(T)
    }
  ])
  const I = {
    className: 'params',
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: l,
    contains: P
  }
  const Y = {
    variants: [
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, '(', e.concat(/\./, r), ')*')
        ],
        scope: {
          1: 'keyword',
          3: 'title.class',
          5: 'keyword',
          7: 'title.class.inherited'
        }
      },
      {
        match: [/class/, /\s+/, r],
        scope: { 1: 'keyword', 3: 'title.class' }
      }
    ]
  }
  const ne = {
    relevance: 0,
    match: e.either(
      /\bJSON/,
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
    ),
    className: 'title.class',
    keywords: { _: [...V_, ...G_] }
  }
  const q = {
    label: 'use_strict',
    className: 'meta',
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }
  const Q = {
    variants: [
      { match: [/function/, /\s+/, r, /(?=\s*\()/] },
      { match: [/function/, /\s*(?=\()/] }
    ],
    className: { 1: 'keyword', 3: 'title.function' },
    label: 'func.def',
    contains: [I],
    illegal: /%/
  }
  const fe = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: 'variable.constant'
  }
  function we (D) {
    return e.concat('(?!', D.join('|'), ')')
  }
  const me = {
    match: e.concat(
      /\b/,
      we([...q_, 'super', 'import']),
      r,
      e.lookahead(/\(/)
    ),
    className: 'title.function',
    relevance: 0
  }
  const Ce = {
    begin: e.concat(/\./, e.lookahead(e.concat(r, /(?![0-9A-Za-z$_(])/))),
    end: r,
    excludeBegin: !0,
    keywords: 'prototype',
    className: 'property',
    relevance: 0
  }
  const ge = {
    match: [/get|set/, /\s+/, r, /(?=\()/],
    className: { 1: 'keyword', 3: 'title.function' },
    contains: [{ begin: /\(\)/ }, I]
  }
  const ye =
        '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' +
        t.UNDERSCORE_IDENT_RE +
        ')\\s*=>'
  const A = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      e.lookahead(ye)
    ],
    keywords: 'async',
    className: { 1: 'keyword', 3: 'title.function' },
    contains: [I]
  }
  return {
    name: 'JavaScript',
    aliases: ['js', 'jsx', 'mjs', 'cjs'],
    keywords: l,
    exports: { PARAMS_CONTAINS: P, CLASS_REFERENCE: ne },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({ label: 'shebang', binary: 'node', relevance: 5 }),
      q,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      b,
      g,
      E,
      w,
      O,
      { match: /\$\d+/ },
      h,
      ne,
      { className: 'attr', begin: r + e.lookahead(':'), relevance: 0 },
      A,
      {
        begin:
                    '(' + t.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
        keywords: 'return throw case',
        relevance: 0,
        contains: [
          O,
          t.REGEXP_MODE,
          {
            className: 'function',
            begin: ye,
            returnBegin: !0,
            end: '\\s*=>',
            contains: [
              {
                className: 'params',
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: l,
                    contains: P
                  }
                ]
              }
            ]
          },
          { begin: /,/, relevance: 0 },
          { match: /\s+/, relevance: 0 },
          {
            variants: [
              { begin: i.begin, end: i.end },
              { match: o },
              {
                begin: s.begin,
                'on:begin': s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: 'xml',
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ['self']
              }
            ]
          }
        ]
      },
      Q,
      { beginKeywords: 'while if switch catch for' },
      {
        begin:
                    '\\b(?!function)' +
                    t.UNDERSCORE_IDENT_RE +
                    '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
        returnBegin: !0,
        label: 'func.def',
        contains: [
          I,
          t.inherit(t.TITLE_MODE, {
            begin: r,
            className: 'title.function'
          })
        ]
      },
      { match: /\.\.\./, relevance: 0 },
      Ce,
      { match: '\\$' + r, relevance: 0 },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: 'title.function' },
        contains: [I]
      },
      me,
      fe,
      Y,
      ge,
      { match: /\$[(.]/ }
    ]
  }
}
function X_ (t) {
  const e = QF(t)
  const n = Au
  const r = [
    'any',
    'void',
    'number',
    'boolean',
    'string',
    'object',
    'never',
    'symbol',
    'bigint',
    'unknown'
  ]
  const i = {
    beginKeywords: 'namespace',
    end: /\{/,
    excludeEnd: !0,
    contains: [e.exports.CLASS_REFERENCE]
  }
  const o = {
    beginKeywords: 'interface',
    end: /\{/,
    excludeEnd: !0,
    keywords: { keyword: 'interface extends', built_in: r },
    contains: [e.exports.CLASS_REFERENCE]
  }
  const s = {
    className: 'meta',
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }
  const l = [
    'type',
    'namespace',
    'interface',
    'public',
    'private',
    'protected',
    'implements',
    'declare',
    'abstract',
    'readonly',
    'enum',
    'override'
  ]
  const u = {
    $pattern: Au,
    keyword: W_.concat(l),
    literal: K_,
    built_in: J_.concat(r),
    'variable.language': Y_
  }
  const d = { className: 'meta', begin: '@' + n }
  const f = (m, b, g) => {
    const E = m.contains.findIndex((w) => w.label === b)
    if (E === -1) throw new Error('can not find mode to replace')
    m.contains.splice(E, 1, g)
  }
  Object.assign(e.keywords, u),
  e.exports.PARAMS_CONTAINS.push(d),
  (e.contains = e.contains.concat([d, i, o])),
  f(e, 'shebang', t.SHEBANG()),
  f(e, 'use_strict', s)
  const h = e.contains.find((m) => m.label === 'func.def')
  return (
    (h.relevance = 0),
    Object.assign(e, {
      name: 'TypeScript',
      aliases: ['ts', 'tsx', 'mts', 'cts']
    }),
    e
  )
}
function Z_ (t) {
  const e = t.regex
  const n = { className: 'string', begin: /"(""|[^/n])"C\b/ }
  const r = {
    className: 'string',
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [{ begin: /""/ }]
  }
  const i = /\d{1,2}\/\d{1,2}\/\d{4}/
  const o = /\d{4}-\d{1,2}-\d{1,2}/
  const s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/
  const l = /\d{1,2}(:\d{1,2}){1,2}/
  const u = {
    className: 'literal',
    variants: [
      { begin: e.concat(/# */, e.either(o, i), / *#/) },
      { begin: e.concat(/# */, l, / *#/) },
      { begin: e.concat(/# */, s, / *#/) },
      {
        begin: e.concat(
          /# */,
          e.either(o, i),
          / +/,
          e.either(s, l),
          / *#/
        )
      }
    ]
  }
  const d = {
    className: 'number',
    relevance: 0,
    variants: [
      {
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ },
      { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ },
      { begin: /&O[0-7_]+((U?[SIL])|[%&])?/ },
      { begin: /&B[01_]+((U?[SIL])|[%&])?/ }
    ]
  }
  const f = { className: 'label', begin: /^\w+:/ }
  const h = t.COMMENT(/'''/, /$/, {
    contains: [{ className: 'doctag', begin: /<\/?/, end: />/ }]
  })
  const m = t.COMMENT(null, /$/, {
    variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }]
  })
  return {
    name: 'Visual Basic .NET',
    aliases: ['vb'],
    case_insensitive: !0,
    classNameAliases: { label: 'symbol' },
    keywords: {
      keyword:
                'addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield',
      built_in:
                'addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort',
      type: 'boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort',
      literal: 'true false nothing'
    },
    illegal: '//|\\{|\\}|endif|gosub|variant|wend|^\\$ ',
    contains: [
      n,
      r,
      u,
      d,
      f,
      h,
      m,
      {
        className: 'meta',
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: {
          keyword:
                        'const disable else elseif enable end externalsource if region then'
        },
        contains: [m]
      }
    ]
  }
}
function j_ (t) {
  t.regex
  const e = t.COMMENT(/\(;/, /;\)/)
  e.contains.push('self')
  const n = t.COMMENT(/;;/, /$/)
  const r = [
    'anyfunc',
    'block',
    'br',
    'br_if',
    'br_table',
    'call',
    'call_indirect',
    'data',
    'drop',
    'elem',
    'else',
    'end',
    'export',
    'func',
    'global.get',
    'global.set',
    'local.get',
    'local.set',
    'local.tee',
    'get_global',
    'get_local',
    'global',
    'if',
    'import',
    'local',
    'loop',
    'memory',
    'memory.grow',
    'memory.size',
    'module',
    'mut',
    'nop',
    'offset',
    'param',
    'result',
    'return',
    'select',
    'set_global',
    'set_local',
    'start',
    'table',
    'tee_local',
    'then',
    'type',
    'unreachable'
  ]
  const i = {
    begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/],
    className: { 1: 'keyword', 3: 'title.function' }
  }
  const o = { className: 'variable', begin: /\$[\w_]+/ }
  const s = {
    match: /(\((?!;)|\))+/,
    className: 'punctuation',
    relevance: 0
  }
  const l = {
    className: 'number',
    relevance: 0,
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }
  const u = { match: /(i32|i64|f32|f64)(?!\.)/, className: 'type' }
  const d = {
    className: 'keyword',
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  }
  return {
    name: 'WebAssembly',
    keywords: { $pattern: /[\w.]+/, keyword: r },
    contains: [
      n,
      e,
      {
        match: [/(?:offset|align)/, /\s*/, /=/],
        className: { 1: 'keyword', 3: 'operator' }
      },
      o,
      s,
      i,
      t.QUOTE_STRING_MODE,
      u,
      d,
      l
    ]
  }
}
function Q_ (t) {
  const e = t.regex
  const n = e.concat(
    /[\p{L}_]/u,
    e.optional(/[\p{L}0-9_.-]*:/u),
    /[\p{L}0-9_.-]*/u
  )
  const r = /[\p{L}0-9._:-]+/u
  const i = {
    className: 'symbol',
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }
  const o = {
    begin: /\s/,
    contains: [
      {
        className: 'keyword',
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }
  const s = t.inherit(o, { begin: /\(/, end: /\)/ })
  const l = t.inherit(t.APOS_STRING_MODE, { className: 'string' })
  const u = t.inherit(t.QUOTE_STRING_MODE, { className: 'string' })
  const d = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      { className: 'attr', begin: r, relevance: 0 },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: 'string',
            endsParent: !0,
            variants: [
              { begin: /"/, end: /"/, contains: [i] },
              { begin: /'/, end: /'/, contains: [i] },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  }
  return {
    name: 'HTML, XML',
    aliases: [
      'html',
      'xhtml',
      'rss',
      'atom',
      'xjb',
      'xsd',
      'xsl',
      'plist',
      'wsf',
      'svg'
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: 'meta',
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          o,
          u,
          l,
          s,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: 'meta',
                begin: /<![a-z]/,
                end: />/,
                contains: [o, s, u, l]
              }
            ]
          }
        ]
      },
      t.COMMENT(/<!--/, /-->/, { relevance: 10 }),
      { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
      i,
      {
        className: 'meta',
        end: /\?>/,
        variants: [
          { begin: /<\?xml/, relevance: 10, contains: [u] },
          { begin: /<\?[a-z][a-z0-9]+/ }
        ]
      },
      {
        className: 'tag',
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: 'style' },
        contains: [d],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: ['css', 'xml']
        }
      },
      {
        className: 'tag',
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: 'script' },
        contains: [d],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: ['javascript', 'handlebars', 'xml']
        }
      },
      { className: 'tag', begin: /<>|<\/>/ },
      {
        className: 'tag',
        begin: e.concat(
          /</,
          e.lookahead(e.concat(n, e.either(/\/>/, />/, /\s/)))
        ),
        end: /\/?>/,
        contains: [
          { className: 'name', begin: n, relevance: 0, starts: d }
        ]
      },
      {
        className: 'tag',
        begin: e.concat(/<\//, e.lookahead(e.concat(n, />/))),
        contains: [
          { className: 'name', begin: n, relevance: 0 },
          { begin: />/, relevance: 0, endsParent: !0 }
        ]
      }
    ]
  }
}
function eS (t) {
  const e = 'true false yes no null'
  const n = "[\\w#;/?:@&=+$,.~*'()[\\]]+"
  const r = {
    className: 'attr',
    variants: [
      { begin: '\\w[\\w :\\/.-]*:(?=[ 	]|$)' },
      { begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)' },
      { begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)" }
    ]
  }
  const i = {
    className: 'template-variable',
    variants: [
      { begin: /\{\{/, end: /\}\}/ },
      { begin: /%\{/, end: /\}/ }
    ]
  }
  const o = {
    className: 'string',
    relevance: 0,
    variants: [
      { begin: /'/, end: /'/ },
      { begin: /"/, end: /"/ },
      { begin: /\S+/ }
    ],
    contains: [t.BACKSLASH_ESCAPE, i]
  }
  const s = t.inherit(o, {
    variants: [
      { begin: /'/, end: /'/ },
      { begin: /"/, end: /"/ },
      { begin: /[^\s,{}[\]]+/ }
    ]
  })
  const h = {
    className: 'number',
    begin:
            '\\b' +
            '[0-9]{4}(-[0-9][0-9]){0,2}' +
            '([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?' +
            '(\\.[0-9]*)?' +
            '([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?' +
            '\\b'
  }
  const m = {
    end: ',',
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: e,
    relevance: 0
  }
  const b = {
    begin: /\{/,
    end: /\}/,
    contains: [m],
    illegal: '\\n',
    relevance: 0
  }
  const g = {
    begin: '\\[',
    end: '\\]',
    contains: [m],
    illegal: '\\n',
    relevance: 0
  }
  const E = [
    r,
    { className: 'meta', begin: '^---\\s*$', relevance: 10 },
    {
      className: 'string',
      begin: '[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*'
    },
    {
      begin: '<%[%=-]?',
      end: '[%-]?%>',
      subLanguage: 'ruby',
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    { className: 'type', begin: '!\\w+!' + n },
    { className: 'type', begin: '!<' + n + '>' },
    { className: 'type', begin: '!' + n },
    { className: 'type', begin: '!!' + n },
    { className: 'meta', begin: '&' + t.UNDERSCORE_IDENT_RE + '$' },
    { className: 'meta', begin: '\\*' + t.UNDERSCORE_IDENT_RE + '$' },
    { className: 'bullet', begin: '-(?=[ ]|$)', relevance: 0 },
    t.HASH_COMMENT_MODE,
    { beginKeywords: e, keywords: { literal: e } },
    h,
    { className: 'number', begin: t.C_NUMBER_RE + '\\b', relevance: 0 },
    b,
    g,
    o
  ]
  const w = [...E]
  return (
    w.pop(),
    w.push(s),
    (m.contains = w),
    { name: 'YAML', case_insensitive: !0, aliases: ['yml'], contains: E }
  )
}
const wS = ef(vS(), 1)
const Zn = wS.default
const _S = ef(xS(), 1)
const ka = Object.assign(wo(Error), {
  eval: wo(EvalError),
  range: wo(RangeError),
  reference: wo(ReferenceError),
  syntax: wo(SyntaxError),
  type: wo(TypeError),
  uri: wo(URIError)
})
function wo (t) {
  return (e.displayName = t.displayName || t.name), e
  function e (n, ...r) {
    const i = n && (0, _S.default)(n, ...r)
    return new t(i)
  }
}
const WH = {}.hasOwnProperty
const SS = 'hljs-'
function TS (t, e, n = {}) {
  let r = n.prefix
  if (typeof t !== 'string') {
    throw ka('Expected `string` for name, got `%s`', t)
  }
  if (!Zn.getLanguage(t)) {
    throw ka('Unknown language: `%s` is not registered', t)
  }
  if (typeof e !== 'string') {
    throw ka('Expected `string` for value, got `%s`', e)
  }
  r == null && (r = SS), Zn.configure({ __emitter: zm, classPrefix: r })
  const i = Zn.highlight(e, { language: t, ignoreIllegals: !0 })
  if ((Zn.configure({}), i.errorRaised)) throw i.errorRaised
  return (
    (i._emitter.root.data.language = i.language),
    (i._emitter.root.data.relevance = i.relevance),
    i._emitter.root
  )
}
function KH (t, e = {}) {
  const n = e.subset || Zn.listLanguages()
  let r = e.prefix
  let i = -1
  let o = {
    type: 'root',
    data: { language: null, relevance: 0 },
    children: []
  }
  if ((r == null && (r = SS), typeof t !== 'string')) {
    throw ka('Expected `string` for value, got `%s`', t)
  }
  for (; ++i < n.length;) {
    const s = n[i]
    if (!Zn.getLanguage(s)) continue
    const l = TS(s, t, e)
    l.data.relevance > o.data.relevance && (o = l)
  }
  return o
}
function VH (t, e) {
  Zn.registerLanguage(t, e)
}
const GH = function (t, e) {
  if (typeof t === 'string') Zn.registerAliases(e, { languageName: t })
  else {
    let n
    for (n in t) {
      WH.call(t, n) && Zn.registerAliases(t[n], { languageName: n })
    }
  }
}
function qH (t) {
  return !!Zn.getLanguage(t)
}
function YH () {
  return Zn.listLanguages()
}
var zm = class {
  constructor (e) {
    (this.options = e),
    (this.root = {
      type: 'root',
      data: { language: null, relevance: 0 },
      children: []
    }),
    (this.stack = [this.root])
  }

  addText (e) {
    if (e === '') return
    const n = this.stack[this.stack.length - 1]
    const r = n.children[n.children.length - 1]
    r && r.type === 'text'
      ? (r.value += e)
      : n.children.push({ type: 'text', value: e })
  }

  startScope (e) {
    this.openNode(String(e))
  }

  endScope () {
    this.closeNode()
  }

  __addSublanguage (e, n) {
    const r = this.stack[this.stack.length - 1]
    const i = e.root.children
    n
      ? r.children.push({
        type: 'element',
        tagName: 'span',
        properties: { className: [n] },
        children: i
      })
      : r.children.push(...i)
  }

  openNode (e) {
    const n = e
      .split('.')
      .map((o, s) =>
        s ? o + '_'.repeat(s) : this.options.classPrefix + o
      )
    const r = this.stack[this.stack.length - 1]
    const i = {
      type: 'element',
      tagName: 'span',
      properties: { className: n },
      children: []
    }
    r.children.push(i), this.stack.push(i)
  }

  closeNode () {
    this.stack.pop()
  }

  finalize () {}
  toHTML () {
    return ''
  }
}
const De = {
  highlight: TS,
  highlightAuto: KH,
  registerLanguage: VH,
  registered: qH,
  listLanguages: YH,
  registerAlias: GH
}
De.registerLanguage('arduino', Xx)
De.registerLanguage('bash', Zx)
De.registerLanguage('c', jx)
De.registerLanguage('cpp', Qx)
De.registerLanguage('csharp', e_)
De.registerLanguage('css', t_)
De.registerLanguage('diff', n_)
De.registerLanguage('go', r_)
De.registerLanguage('graphql', i_)
De.registerLanguage('ini', o_)
De.registerLanguage('java', l_)
De.registerLanguage('javascript', p_)
De.registerLanguage('json', h_)
De.registerLanguage('kotlin', m_)
De.registerLanguage('less', y_)
De.registerLanguage('lua', E_)
De.registerLanguage('makefile', v_)
De.registerLanguage('markdown', w_)
De.registerLanguage('objectivec', x_)
De.registerLanguage('perl', __)
De.registerLanguage('php', S_)
De.registerLanguage('php-template', T_)
De.registerLanguage('plaintext', C_)
De.registerLanguage('python', A_)
De.registerLanguage('python-repl', M_)
De.registerLanguage('r', N_)
De.registerLanguage('ruby', k_)
De.registerLanguage('rust', O_)
De.registerLanguage('scss', R_)
De.registerLanguage('shell', I_)
De.registerLanguage('sql', D_)
De.registerLanguage('swift', U_)
De.registerLanguage('typescript', X_)
De.registerLanguage('vbnet', Z_)
De.registerLanguage('wasm', j_)
De.registerLanguage('xml', Q_)
De.registerLanguage('yaml', eS)
const Mi = (t, e = 0, n = 1) => (t > n ? n : t < e ? e : t)
const Nt = (t, e = 0, n = Math.pow(10, e)) => Math.round(n * t) / n
const u6 = { grad: 360 / 400, turn: 360, rad: 360 / (Math.PI * 2) }
const CS = (t) => jH(Iu(t))
var Iu = (t) => (
  t[0] === '#' && (t = t.substring(1)),
  t.length < 6
    ? {
        r: parseInt(t[0] + t[0], 16),
        g: parseInt(t[1] + t[1], 16),
        b: parseInt(t[2] + t[2], 16),
        a: t.length === 4 ? Nt(parseInt(t[3] + t[3], 16) / 255, 2) : 1
      }
    : {
        r: parseInt(t.substring(0, 2), 16),
        g: parseInt(t.substring(2, 4), 16),
        b: parseInt(t.substring(4, 6), 16),
        a:
                  t.length === 8
                    ? Nt(parseInt(t.substring(6, 8), 16) / 255, 2)
                    : 1
      }
)
const AS = (t) => ZH(XH(t))
const JH = ({ h: t, s: e, v: n, a: r }) => {
  const i = ((200 - e) * n) / 100
  return {
    h: Nt(t),
    s: Nt(
      i > 0 && i < 200
        ? ((e * n) / 100 / (i <= 100 ? i : 200 - i)) * 100
        : 0
    ),
    l: Nt(i / 2),
    a: Nt(r, 2)
  }
}
const Oa = (t) => {
  const { h: e, s: n, l: r } = JH(t)
  return `hsl(${e}, ${n}%, ${r}%)`
}
var XH = ({ h: t, s: e, v: n, a: r }) => {
  (t = (t / 360) * 6), (e = e / 100), (n = n / 100)
  const i = Math.floor(t)
  const o = n * (1 - e)
  const s = n * (1 - (t - i) * e)
  const l = n * (1 - (1 - t + i) * e)
  const u = i % 6
  return {
    r: Nt([n, s, o, o, l, n][u] * 255),
    g: Nt([l, n, n, s, o, o][u] * 255),
    b: Nt([o, o, l, n, n, s][u] * 255),
    a: Nt(r, 2)
  }
}
const Ru = (t) => {
  const e = t.toString(16)
  return e.length < 2 ? '0' + e : e
}
var ZH = ({ r: t, g: e, b: n, a: r }) => {
  const i = r < 1 ? Ru(Nt(r * 255)) : ''
  return '#' + Ru(t) + Ru(e) + Ru(n) + i
}
var jH = ({ r: t, g: e, b: n, a: r }) => {
  const i = Math.max(t, e, n)
  const o = i - Math.min(t, e, n)
  const s = o
    ? i === t
      ? (e - n) / o
      : i === e
        ? 2 + (n - t) / o
        : 4 + (t - e) / o
    : 0
  return {
    h: Nt(60 * (s < 0 ? s + 6 : s)),
    s: Nt(i ? (o / i) * 100 : 0),
    v: Nt((i / 255) * 100),
    a: r
  }
}
const Um = (t, e) => {
  if (t === e) return !0
  for (const n in t) if (t[n] !== e[n]) return !1
  return !0
}
const MS = (t, e) =>
  t.toLowerCase() === e.toLowerCase() ? !0 : Um(Iu(t), Iu(e))
const NS = {}
const Du = (t) => {
  let e = NS[t]
  return (
    e ||
            ((e = document.createElement('template')),
            (e.innerHTML = t),
            (NS[t] = e)),
    e
  )
}
const Ra = (t, e, n) => {
  t.dispatchEvent(new CustomEvent(e, { bubbles: !0, detail: n }))
}
let hs = !1
const Wm = (t) => 'touches' in t
const QH = (t) => (hs && !Wm(t) ? !1 : (hs || (hs = Wm(t)), !0))
const kS = (t, e) => {
  const n = Wm(e) ? e.touches[0] : e
  const r = t.el.getBoundingClientRect()
  Ra(
    t.el,
    'move',
    t.getMove({
      x: Mi((n.pageX - (r.left + window.pageXOffset)) / r.width),
      y: Mi((n.pageY - (r.top + window.pageYOffset)) / r.height)
    })
  )
}
const e$ = (t, e) => {
  const n = e.keyCode
  n > 40 ||
        (t.xy && n < 37) ||
        n < 33 ||
        (e.preventDefault(),
        Ra(
          t.el,
          'move',
          t.getMove(
            {
              x:
                        n === 39
                          ? 0.01
                          : n === 37
                            ? -0.01
                            : n === 34
                              ? 0.05
                              : n === 33
                                ? -0.05
                                : n === 35
                                  ? 1
                                  : n === 36
                                    ? -1
                                    : 0,
              y: n === 40 ? 0.01 : n === 38 ? -0.01 : 0
            },
            !0
          )
        ))
}
const ms = class {
  constructor (e, n, r, i) {
    const o = Du(
            `<div role="slider" tabindex="0" part="${n}" ${r}><div part="${n}-pointer"></div></div>`
    )
    e.appendChild(o.content.cloneNode(!0))
    const s = e.querySelector(`[part=${n}]`)
    s.addEventListener('mousedown', this),
    s.addEventListener('touchstart', this),
    s.addEventListener('keydown', this),
    (this.el = s),
    (this.xy = i),
    (this.nodes = [s.firstChild, s])
  }

  set dragging (e) {
    const n = e ? document.addEventListener : document.removeEventListener
    n(hs ? 'touchmove' : 'mousemove', this),
    n(hs ? 'touchend' : 'mouseup', this)
  }

  handleEvent (e) {
    switch (e.type) {
      case 'mousedown':
      case 'touchstart':
        if ((e.preventDefault(), !QH(e) || (!hs && e.button != 0))) {
          return
        }
        this.el.focus(), kS(this, e), (this.dragging = !0)
        break
      case 'mousemove':
      case 'touchmove':
        e.preventDefault(), kS(this, e)
        break
      case 'mouseup':
      case 'touchend':
        this.dragging = !1
        break
      case 'keydown':
        e$(this, e)
        break
    }
  }

  style (e) {
    e.forEach((n, r) => {
      for (const i in n) this.nodes[r].style.setProperty(i, n[i])
    })
  }
}
const Lu = class extends ms {
  constructor (e) {
    super(
      e,
      'hue',
      'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"',
      !1
    )
  }

  update ({ h: e }) {
    (this.h = e),
    this.style([
      {
        left: `${(e / 360) * 100}%`,
        color: Oa({ h: e, s: 100, v: 100, a: 1 })
      }
    ]),
    this.el.setAttribute('aria-valuenow', `${Nt(e)}`)
  }

  getMove (e, n) {
    return { h: n ? Mi(this.h + e.x * 360, 0, 360) : 360 * e.x }
  }
}
const Pu = class extends ms {
  constructor (e) {
    super(e, 'saturation', 'aria-label="Color"', !0)
  }

  update (e) {
    (this.hsva = e),
    this.style([
      { top: `${100 - e.v}%`, left: `${e.s}%`, color: Oa(e) },
      { 'background-color': Oa({ h: e.h, s: 100, v: 100, a: 1 }) }
    ]),
    this.el.setAttribute(
      'aria-valuetext',
                `Saturation ${Nt(e.s)}%, Brightness ${Nt(e.v)}%`
    )
  }

  getMove (e, n) {
    return {
      s: n ? Mi(this.hsva.s + e.x * 100, 0, 100) : e.x * 100,
      v: n
        ? Mi(this.hsva.v - e.y * 100, 0, 100)
        : Math.round(100 - e.y * 100)
    }
  }
}
const OS =
    ':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}'
const RS =
    '[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}'
const IS =
    '[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}'
const Bu = Symbol('same')
const Km = Symbol('color')
const DS = Symbol('hsva')
const Vm = Symbol('update')
const LS = Symbol('parts')
const PS = Symbol('css')
const BS = Symbol('sliders')
const Fu = class extends HTMLElement {
  static get observedAttributes () {
    return ['color']
  }

  get [PS] () {
    return [OS, RS, IS]
  }

  get [BS] () {
    return [Pu, Lu]
  }

  get color () {
    return this[Km]
  }

  set color (e) {
    if (!this[Bu](e)) {
      const n = this.colorModel.toHsva(e)
      this[Vm](n), (this[Km] = e)
    }
  }

  constructor () {
    super()
    const e = Du(`<style>${this[PS].join('')}</style>`)
    const n = this.attachShadow({ mode: 'open' })
    n.appendChild(e.content.cloneNode(!0)),
    n.addEventListener('move', this),
    (this[LS] = this[BS].map((r) => new r(n)))
  }

  connectedCallback () {
    if (this.hasOwnProperty('color')) {
      const e = this.color
      delete this.color, (this.color = e)
    } else this.color || (this.color = this.colorModel.defaultColor)
  }

  attributeChangedCallback (e, n, r) {
    const i = this.colorModel.fromAttr(r)
    this[Bu](i) || (this.color = i)
  }

  handleEvent (e) {
    const n = this[DS]
    const r = { ...n, ...e.detail }
    this[Vm](r)
    let i
    !Um(r, n) &&
            !this[Bu]((i = this.colorModel.fromHsva(r))) &&
            ((this[Km] = i), Ra(this, 'color-changed', { value: i }))
  }

  [Bu] (e) {
    return this.color && this.colorModel.equal(e, this.color)
  }

  [Vm] (e) {
    (this[DS] = e), this[LS].forEach((n) => n.update(e))
  }
}
const t$ = {
  defaultColor: '#000',
  toHsva: CS,
  fromHsva: ({ h: t, s: e, v: n }) => AS({ h: t, s: e, v: n, a: 1 }),
  equal: MS,
  fromAttr: (t) => t
}
const Hu = class extends Fu {
  get colorModel () {
    return t$
  }
}
const $S = ef(FS(), 1)
customElements.define('tiptap-hex-color-picker', Hu)
const n$ = {
  blockquote: [sv],
  bold: [av],
  'bullet-list': [uv],
  'checked-list': [_h],
  code: [dv],
  'code-block': [
    gm.configure({ lowlight: De, HTMLAttributes: { class: 'hljs' } })
  ],
  color: [pv],
  details: [om, sm, am],
  grid: [jh, Qh],
  'grid-builder': [Em, vm],
  heading: [Ev.configure({ levels: [1, 2, 3, 4, 5, 6] })],
  highlight: [gw],
  hr: [Tv],
  hurdle: [bm],
  italic: [Cv],
  lead: [Sh],
  link: [
    Jh.configure({
      openOnClick: !1,
      autolink: !1,
      HTMLAttributes: { rel: null, hreflang: null, class: null }
    })
  ],
  media: [Xh.configure({ inline: !0 })],
  oembed: [tm, rm, im],
  'ordered-list': [Nv],
  small: [Zh],
  strike: [Ov],
  subscript: [Rv],
  superscript: [Iv],
  table: [uw.configure({ resizable: !0 }), fw, dw, pw],
  underline: [mw]
}
const r$ = window.TiptapEditorExtensions || {}
const HS = { ...n$, ...r$ }
const $u = document.getElementById('activeLocale')
$u &&
    $u.addEventListener('change', () => {
      const t = new CustomEvent('locale-change', {
        bubbles: !0,
        detail: { locale: $u.value }
      })
      $u.dispatchEvent(t)
    })
document.addEventListener('livewire:navigating', () => {
  window.filamentTiptapEditors = {}
})
document.addEventListener('dblclick', function (t) {
  ((t.target &&
        (t.target.hasAttribute('data-youtube-video') ||
            t.target.hasAttribute('data-vimeo-video'))) ||
        t.target.hasAttribute('data-native-video')) &&
        (t.target.firstChild.style.pointerEvents = 'all')
})
Livewire.on('insertFromAction', (t) => {
  setTimeout(() => {
    const e = new CustomEvent('insert-content', { bubble: !0, detail: t })
    window.dispatchEvent(e)
  }, 100)
})
Livewire.on('insertBlockFromAction', (t) => {
  setTimeout(() => {
    const e = new CustomEvent('insert-block', { bubble: !0, detail: t })
    window.dispatchEvent(e)
  }, 100)
})
Livewire.on('updateBlockFromAction', (t) => {
  setTimeout(() => {
    const e = new CustomEvent('update-block', { bubble: !0, detail: t })
    window.dispatchEvent(e)
  }, 100)
})
function i$ ({
  state: t,
  statePath: e,
  tools: n = [],
  disabled: r = !1,
  locale: i = 'en',
  bubbleMenuTools: o = [],
  floatingMenuTools: s = [],
  placeholder: l = null,
  mergeTags: u = [],
  customDocument: d = null,
  nodePlaceholders: f = [],
  showOnlyCurrentPlaceholder: h = !0,
  debounce: m = null
}) {
  let b = null
  return {
    id: null,
    modalId: null,
    tools: n,
    state: t,
    statePath: e,
    fullScreenMode: !1,
    updatedAt: Date.now(),
    disabled: r,
    locale: i,
    bubbleMenuTools: o,
    floatingMenuTools: s,
    getExtensions () {
      const g = this.tools.map((w) => (typeof w === 'string' ? w : w.id))
      const E = [
        d ? Rp.extend({ content: d }) : Rp,
        hw,
        wc,
        mv,
        bv,
        yv,
        Sv,
        fv,
        wm,
        Sm,
        Tm,
        Cm,
        Am.configure({ statePath: e }),
        xm
      ]
      if (
        ((l || f) &&
                    !r &&
                    E.push(
                      kv.configure({
                        showOnlyCurrent: h,
                        placeholder: ({ node: w }) =>
                          f?.[w.type.name] || l || ''
                      })
                    ),
        g.length)
      ) {
        const w = Object.keys(HS)
        const S = []
        const O = ['paragraph']
        E.push(
          ex.configure({
            element: this.$refs.bubbleMenu,
            tippyOptions: {
              duration: [500, 0],
              maxWidth: 'none',
              placement: 'auto',
              theme: 'tiptap-editor-bubble',
              interactive: !0,
              appendTo: this.$refs.element,
              zIndex: 10
            },
            shouldShow: ({ state: k, from: T, to: P }) => {
              if (
                Ur(k, 'oembed') ||
                                Ur(k, 'vimeo') ||
                                Ur(k, 'youtube') ||
                                Ur(k, 'video') ||
                                Ur(k, 'tiptapBlock')
              ) {
                return !1
              }
              if (Ur(k, 'link') || Ur(k, 'table') || T !== P) {
                return !0
              }
            }
          })
        ),
        this.floatingMenuTools.length &&
                        (E.push(
                          tx.configure({
                            element: this.$refs.floatingMenu,
                            tippyOptions: {
                              duration: [500, 0],
                              maxWidth: 'none',
                              theme: 'tiptap-editor-bubble',
                              interactive: !0,
                              appendTo: this.$refs.element,
                              zIndex: 10
                            }
                          })
                        ),
                        this.floatingMenuTools.forEach((k) => {
                          g.includes(k) || g.push(k)
                        })),
        this.bubbleMenuTools.length &&
                        this.bubbleMenuTools.forEach((k) => {
                          g.includes(k) || g.push(k)
                        }),
        g.forEach((k) => {
          w.includes(k)
            ? HS[k].forEach((T) => {
              [
                'ordered-list',
                'bullet-list',
                'checked-list'
              ].includes(k)
                ? (E.push(T),
                  E.includes($p) || E.push($p))
                : E.push(T)
            })
            : [
                'align-left',
                'align-right',
                'align-center',
                'align-justify'
              ].includes(k) &&
                              (k === 'align-left' && S.push('start'),
                              k === 'align-center' && S.push('center'),
                              k === 'align-right' && S.push('end'),
                              k === 'align-justify' && S.push('justify'),
                              g.includes('heading') && O.push('heading'),
                              typeof E.find((P) => P.name === 'textAlign') >
                                  'u' &&
                                  E.push(
                                    ym.configure({ types: O, alignments: S })
                                  ))
        })
      }
      return u?.length && E.push(_m.configure({ mergeTags: u })), E
    },
    init: function () {
      const g = this.$refs.element.querySelector('.tiptap')
      g && (g.remove(), (b = null)), this.initEditor(this.state)
      const E = this.$el.parentElement.closest('[x-sortable]')
      E &&
                (window.Sortable.utils.on(E, 'start', () => {
                  E.classList.add('sorting')
                }),
                window.Sortable.utils.on(E, 'end', () => {
                  E.classList.remove('sorting')
                })),
      this.$watch('state', (w, S) => {
        typeof w < 'u' &&
                        ((0, $S.isEqual)(S, Alpine.raw(w)) ||
                            this.updateEditorContent(w))
      })
    },
    initEditor (g) {
      if (!this.$el.querySelector('.tiptap')) {
        const E = this
        b = new sc({
          element: E.$refs.element,
          extensions: E.getExtensions(),
          editable: !E.disabled,
          content: g,
          editorProps: {
            handlePaste (w, S, O) {
              O.content.descendants((k) => {
                k.type.name === 'tiptapBlock' &&
                                    ((k.attrs.statePath = E.statePath),
                                    (k.attrs.data = JSON.parse(k.attrs.data)))
              })
            }
          },
          onUpdate ({ editor: w }) {
            (E.updatedAt = Date.now()),
            clearTimeout(E.timeOut),
            (E.timeOut = setTimeout(function () {
              E.state = w.isEmpty ? null : w.getJSON()
            }, m ?? 0))
          },
          onSelectionUpdate () {
            E.updatedAt = Date.now()
          },
          onBlur () {
            E.updatedAt = Date.now()
          },
          onFocus () {
            E.updatedAt = Date.now()
          }
        })
      }
    },
    isActive (g, E = {}) {
      return b.isActive(g, E)
    },
    editor () {
      return b
    },
    blur () {
      const g = this.$el.querySelectorAll('[data-tippy-content]')
      g && g.forEach((E) => E.destroy()), (this.updatedAt = Date.now())
    },
    updateEditorContent (g) {
      if (b.isEditable) {
        const { from: E, to: w } = b.state.selection
        b.commands.setContent(g, !0),
        b
          .chain()
          .focus()
          .setTextSelection({ from: E, to: w })
          .run()
      }
    },
    refreshEditorContent () {
      this.$nextTick(() => this.updateEditorContent(this.state))
    },
    updateLocale (g) {
      this.locale = g.detail.locale
    },
    insertContent (g) {
      if (g.detail.statePath === this.statePath) {
        switch (g.detail.type) {
          case 'media':
            this.insertMedia(g)
            return
          case 'video':
            this.insertVideo(g)
            return
          case 'link':
            this.insertLink(g)
            return
          case 'source':
            this.insertSource(g)
            return
          case 'grid':
            this.insertGridBuilder(g)

          default:
        }
      }
    },
    insertMedia (g) {
      Array.isArray(g.detail.media)
        ? g.detail.media.forEach((E) => {
          this.executeMediaInsert(E)
        })
        : this.executeMediaInsert(g.detail.media)
    },
    executeMediaInsert (g = null) {
      if (!(!g || g?.url === null) && g) {
        const E = g?.url || g?.src
        const w = [
          'jpg',
          'jpeg',
          'svg',
          'png',
          'webp',
          'gif',
          'avif',
          'jxl',
          'heic'
        ]
        const O = /.*\.([a-zA-Z]*)\??/.exec(E.toLowerCase())
        O !== null && w.includes(O[1])
          ? b
            .chain()
            .focus()
            .setImage({
              src: E,
              alt: g?.alt,
              title: g?.title,
              width: g?.width,
              height: g?.height,
              lazy: g?.lazy,
              srcset: g?.srcset,
              sizes: g?.sizes,
              media: g?.media
            })
            .run()
          : b
            .chain()
            .focus()
            .extendMarkRange('link')
            .setLink({ href: E })
            .insertContent(g?.link_text)
            .run()
      }
    },
    insertVideo (g) {
      const E = g.detail.video
      if (!E || E.url === null) return
      const w = {
        src: E.url,
        width: E.responsive ? E.width * 100 : E.width,
        height: E.responsive ? E.height * 100 : E.height,
        responsive: E.responsive ?? !0,
        'data-aspect-width': E.width,
        'data-aspect-height': E.height
      }
      E.url.includes('youtube') || E.url.includes('youtu.be')
        ? b
          .chain()
          .focus()
          .setYoutubeVideo({
            ...w,
            controls: E.youtube_options.includes('controls'),
            nocookie: E.youtube_options.includes('nocookie'),
            start: E.start_at ?? 0
          })
          .run()
        : E.url.includes('vimeo')
          ? b
            .chain()
            .focus()
            .setVimeoVideo({
              ...w,
              autoplay: E.vimeo_options.includes('autoplay'),
              loop: E.vimeo_options.includes('loop'),
              title: E.vimeo_options.includes('show_title'),
              byline: E.vimeo_options.includes('byline'),
              portrait: E.vimeo_options.includes('portrait')
            })
            .run()
          : b
            .chain()
            .focus()
            .setVideo({
              ...w,
              autoplay: E.native_options.includes('autoplay'),
              loop: E.native_options.includes('loop'),
              controls: E.native_options.includes('controls')
            })
            .run()
    },
    insertLink (g) {
      const E = g.detail
      if (!(E.href === null && E.id === null)) {
        if (E.href === '' && E.id === null) {
          this.unsetLink()
          return
        }
        b.chain()
          .focus()
          .setTextSelection({
            from: E.coordinates[0].$from.pos,
            to: E.coordinates[0].$to.pos
          })
          .extendMarkRange('link')
          .setLink({
            href: E.href,
            id: E.id ?? null,
            target: E.target ?? null,
            hreflang: E.hreflang ?? null,
            rel: E.rel ?? null,
            referrerpolicy: E.referrerpolicy ?? null,
            as_button: E.as_button ?? null,
            button_theme: E.button_theme ?? null
          })
          .selectTextblockEnd()
          .run()
      }
    },
    unsetLink () {
      b.chain()
        .focus()
        .extendMarkRange('link')
        .unsetLink()
        .selectTextblockEnd()
        .run()
    },
    insertSource (g) {
      this.updateEditorContent(g.detail.source)
    },
    insertGridBuilder (g) {
      const E = g.detail.data
      let w = 'responsive'
      const S = parseInt(E.asymmetric_left) ?? null
      const O = parseInt(E.asymmetric_right) ?? null
      E.fixed && (w = 'fixed'),
      E.asymmetric && (w = 'asymmetric'),
      b
        .chain()
        .focus()
        .insertGridBuilder({
          cols: E.columns,
          type: w,
          stackAt: E.stack_at,
          asymmetricLeft: S,
          asymmetricRight: O
        })
        .run()
    },
    insertBlock (g) {
      g.detail.statePath === this.statePath &&
                (b.commands.insertBlock({
                  type: g.detail.type,
                  statePath: g.detail.statePath,
                  data: g.detail.data,
                  preview: g.detail.preview,
                  label: g.detail.label,
                  coordinates: g.detail.coordinates
                }),
                b.isFocused || b.commands.focus())
    },
    insertMergeTag (g) {
      b.commands.insertMergeTag({
        tag: g.detail.tag,
        coordinates: g.detail.coordinates
      }),
      b.isFocused || b.commands.focus()
    },
    openBlockSettings (g) {
      g.detail.statePath === this.statePath &&
                this.$wire.dispatchFormEvent(
                  'tiptap::updateBlock',
                  this.statePath,
                  g.detail
                )
    },
    updateBlock (g) {
      g.detail.statePath === this.statePath &&
                (b.commands.updateBlock({
                  type: g.detail.type,
                  statePath: g.detail.statePath,
                  data: g.detail.data,
                  preview: g.detail.preview,
                  label: g.detail.label,
                  coordinates: g.detail.coordinates
                }),
                b.isFocused || b.commands.focus())
    },
    deleteBlock (g) {
      g.detail.statePath === this.statePath && b.commands.removeBlock()
    }
  }
}
export { i$ as default }
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
